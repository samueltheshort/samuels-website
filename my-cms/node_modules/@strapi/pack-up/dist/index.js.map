{"version":3,"file":"index.js","sources":["../src/node/core/config.ts","../src/node/core/errors.ts","../src/node/core/exports.ts","../src/node/core/logger.ts","../src/node/core/pkg.ts","../src/node/core/tsconfig.ts","../src/node/createBuildContext.ts","../src/node/createTasks.ts","../src/node/tasks/dts/diagnostic.ts","../src/node/tasks/dts/build.ts","../src/node/tasks/dts/watch.ts","../src/node/tasks/vite/config.ts","../src/node/tasks/vite/build.ts","../src/node/tasks/vite/watch.ts","../src/node/tasks/index.ts","../src/node/build.ts","../src/node/watch.ts","../src/node/core/files.ts","../src/node/check.ts","../src/node/core/git.ts","../src/node/templates/create.ts","../src/node/templates/internal/files/editorConfig.ts","../src/node/templates/internal/files/gitIgnore.ts","../src/node/templates/internal/files/prettier.ts","../src/node/templates/internal/default.ts","../src/node/templates/load.ts","../src/node/init.ts"],"sourcesContent":["import { register } from 'esbuild-register/dist/node';\nimport * as fs from 'fs';\nimport os from 'os';\nimport * as path from 'path';\nimport pkgUp from 'pkg-up';\n\nimport type { Export } from './exports';\nimport type { Logger } from './logger';\nimport type { Runtime } from '../createBuildContext';\nimport type { InlineConfig, PluginOption } from 'vite';\n\ninterface LoadConfigOptions {\n  cwd: string;\n  logger: Logger;\n}\n\nconst CONFIG_FILE_NAMES = [\n  'packup.config.ts',\n  'packup.config.js',\n  'packup.config.cjs',\n  'packup.config.mjs',\n];\n\nconst loadConfig = async ({ cwd, logger }: LoadConfigOptions): Promise<Config | undefined> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    logger.debug(\n      'Could not find a package.json in the current directory, therefore no config was loaded'\n    );\n\n    return undefined;\n  }\n\n  const root = path.dirname(pkgPath);\n\n  for (const fileName of CONFIG_FILE_NAMES) {\n    const configPath = path.resolve(root, fileName);\n\n    const exists = fs.existsSync(configPath);\n\n    if (exists) {\n      const esbuildOptions = { extensions: ['.js', '.mjs', '.ts'] };\n\n      const { unregister } = register(esbuildOptions);\n\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const mod = require(configPath);\n\n      unregister();\n\n      /**\n       * handles esm or cjs exporting.\n       */\n      const config = mod?.default || mod || undefined;\n\n      if (config) {\n        logger.debug('Loaded configuration:', os.EOL, config);\n      }\n\n      return config;\n    }\n  }\n\n  return undefined;\n};\n\ninterface ConfigBundle {\n  source: string;\n  import?: string;\n  require?: string;\n  runtime?: Runtime;\n  tsconfig?: string;\n  types?: string;\n}\n\ninterface ConfigOptions {\n  bundles?: ConfigBundle[];\n  /**\n   * @description the directory to output the bundle to.\n   */\n  dist?: string;\n  /**\n   * @description Overwrite the default exports.\n   */\n  exports?: ConfigProperty<Record<string, Export>>;\n  /**\n   * @description a list of external dependencies to exclude from the bundle.\n   * We already collect the dependencies & peerDeps from the package.json.\n   */\n  externals?: string[];\n  minify?: boolean;\n  plugins?: PluginOption[] | (({ runtime }: { runtime: Runtime }) => PluginOption[]);\n  /**\n   * @alpha\n   *\n   * @description Instead of creating as few chunks as possible, this mode\n   * will create separate chunks for all modules using the original module\n   * names as file names\n   */\n  preserveModules?: boolean;\n  sourcemap?: boolean;\n  runtime?: Runtime;\n  /**\n   * @description path to the tsconfig file to use for the bundle.\n   *\n   * @default tsconfig.build.json\n   */\n  tsconfig?: string;\n\n  /**\n   * @experimental\n   * @description option to overwrite vite's config\n   */\n  unstable_viteConfig?: InlineConfig;\n}\n\n/**\n * @public\n *\n * @description a helper function to define your config in a typesafe manner.\n */\nconst defineConfig = (configOptions: ConfigOptions): ConfigOptions => configOptions;\n\ntype Config = ConfigOptions;\n\ntype ConfigPropertyResolver<T> = (currentValue: T) => T;\n\ntype ConfigProperty<T> = T | ConfigPropertyResolver<T>;\n\n/** @internal */\nexport function resolveConfigProperty<T>(prop: ConfigProperty<T> | undefined, initialValue: T): T {\n  if (prop === undefined || prop === null) {\n    return initialValue;\n  }\n\n  if (typeof prop === 'function') {\n    return (prop as ConfigPropertyResolver<T>)(initialValue);\n  }\n\n  return prop;\n}\n\nexport { loadConfig, defineConfig, CONFIG_FILE_NAMES };\nexport type {\n  Config,\n  ConfigOptions,\n  ConfigBundle,\n  ConfigPropertyResolver,\n  ConfigProperty,\n  PluginOption,\n  Runtime,\n};\n","const isError = (err: unknown): err is Error => err instanceof Error;\n\nexport { isError };\n","import os from 'os';\n\nimport type { Logger } from './logger';\nimport type { PackageJson } from './pkg';\n\n/**\n * @description validate the `exports` property of the package.json against a set of rules.\n * If the validation fails, the process will throw with an appropriate error message. If\n * there is no `exports` property we check the standard export-like properties on the root\n * of the package.json.\n */\nconst validateExportsOrdering = async ({\n  pkg,\n  logger,\n}: {\n  pkg: PackageJson;\n  logger: Logger;\n}): Promise<PackageJson> => {\n  if (pkg.exports) {\n    const exports = Object.entries(pkg.exports);\n\n    for (const [expPath, exp] of exports) {\n      if (typeof exp === 'string') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const keys = Object.keys(exp);\n\n      if (!assertFirst('types', keys)) {\n        throw new Error(`exports[\"${expPath}\"]: the 'types' property should be the first property`);\n      }\n\n      if (exp.node) {\n        const nodeKeys = Object.keys(exp.node);\n\n        if (!assertOrder('module', 'import', nodeKeys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.module' property should come before the 'node.import' property`\n          );\n        }\n\n        if (!assertOrder('import', 'require', nodeKeys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.import' property should come before the 'node.require' property`\n          );\n        }\n\n        if (!assertOrder('module', 'require', nodeKeys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.module' property should come before 'node.require' property`\n          );\n        }\n\n        if (exp.import && exp.node.import && !assertOrder('node', 'import', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'import' property`\n          );\n        }\n\n        if (exp.module && exp.node.module && !assertOrder('node', 'module', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'module' property`\n          );\n        }\n\n        /**\n         * If there's a `node.import` property but not a `node.require` we can assume `node.import`\n         * is wrapping `import` and `node.module` should be added for bundlers.\n         */\n        if (\n          exp.node.import &&\n          (!exp.node.require || exp.require === exp.node.require) &&\n          !exp.node.module\n        ) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.module' property should be added so bundlers don't unintentionally try to bundle 'node.import'. Its value should be '\"module\": \"${exp.import}\"'`\n          );\n        }\n\n        if (\n          exp.node.import &&\n          !exp.node.require &&\n          exp.node.module &&\n          exp.import &&\n          exp.node.module !== exp.import\n        ) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.module' property should match 'import'`\n          );\n        }\n\n        if (exp.require && exp.node.require && exp.require === exp.node.require) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.require' property isn't necessary as it's identical to 'require'`\n          );\n        } else if (exp.require && exp.node.require && !assertOrder('node', 'require', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'require' property`\n          );\n        }\n      } else {\n        if (!assertOrder('import', 'require', keys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'import' property should come before the 'require' property`\n          );\n        }\n\n        if (!assertOrder('module', 'import', keys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'module' property should come before 'import' property`\n          );\n        }\n      }\n      if (!assertLast('default', keys)) {\n        throw new Error(\n          `exports[\"${expPath}\"]: the 'default' property should be the last property`\n        );\n      }\n    }\n  } else if (!['main', 'module'].some((key) => Object.prototype.hasOwnProperty.call(pkg, key))) {\n    throw new Error(\"'package.json' must contain a 'main' and 'module' property\");\n  }\n\n  return pkg;\n};\n\n/** @internal */\nfunction assertFirst(key: string, arr: string[]) {\n  const aIdx = arr.indexOf(key);\n\n  // if not found, then we don't care\n  if (aIdx === -1) {\n    return true;\n  }\n\n  return aIdx === 0;\n}\n\n/** @internal */\nfunction assertLast(key: string, arr: string[]) {\n  const aIdx = arr.indexOf(key);\n\n  // if not found, then we don't care\n  if (aIdx === -1) {\n    return true;\n  }\n\n  return aIdx === arr.length - 1;\n}\n\n/** @internal */\nfunction assertOrder(keyA: string, keyB: string, arr: string[]) {\n  const aIdx = arr.indexOf(keyA);\n  const bIdx = arr.indexOf(keyB);\n\n  // if either is not found, then we don't care\n  if (aIdx === -1 || bIdx === -1) {\n    return true;\n  }\n\n  return aIdx < bIdx;\n}\n\ntype Extensions = 'cjs' | 'es';\n\ninterface ExtMap {\n  commonjs: Record<Extensions, string>;\n  module: Record<Extensions, string>;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_PKG_EXT_MAP = {\n  // pkg.type: \"commonjs\"\n  commonjs: {\n    cjs: '.js',\n    es: '.mjs',\n  },\n\n  // pkg.type: \"module\"\n  module: {\n    cjs: '.cjs',\n    es: '.js',\n  },\n} satisfies ExtMap;\n\n/**\n * We potentially might need to support legacy exports or as package\n * development continues we have space to tweak this.\n */\nconst getExportExtensionMap = (): ExtMap => {\n  return DEFAULT_PKG_EXT_MAP;\n};\n\n/**\n * @internal\n *\n * @description validate the `require` and `import` properties of a given exports maps from the package.json\n * returning if any errors are found.\n */\nconst validateExports = (\n  _exports: Array<Export & { _path: string }>,\n  options: { extMap: ExtMap; pkg: PackageJson }\n) => {\n  const { extMap, pkg } = options;\n  const ext = extMap[pkg.type || 'commonjs'];\n\n  const errors = [];\n\n  for (const exp of _exports) {\n    if (exp.require && !exp.require.endsWith(ext.cjs)) {\n      errors.push(\n        `package.json with 'type: \"${pkg.type}\"' - 'exports[\"${exp._path}\"].require' must end with \"${ext.cjs}\"`\n      );\n    }\n\n    if (exp.import && !exp.import.endsWith(ext.es)) {\n      errors.push(\n        `package.json with 'type: \"${pkg.type}\"' - 'exports[\"${exp._path}\"].import' must end with \"${ext.es}\"`\n      );\n    }\n  }\n\n  return errors;\n};\n\ninterface Export {\n  types?: string;\n  source: string;\n  browser?: {\n    source: string;\n    import?: string;\n    require?: string;\n  };\n  node?: {\n    source?: string;\n    module?: string;\n    import?: string;\n    require?: string;\n  };\n  module?: string;\n  import?: string;\n  require?: string;\n  default: string;\n}\n\n/**\n * @description parse the exports map from the package.json into a standardised\n * format that we can use to generate build tasks from.\n */\nconst parseExports = ({ extMap, pkg }: { extMap: ExtMap; pkg: PackageJson }) => {\n  const rootExport = {\n    _path: '.',\n    types: pkg.types,\n    source: pkg.source || '',\n    require: pkg.main,\n    import: pkg.module,\n    default: pkg.module || pkg.main || '',\n  } satisfies Export & { _path: string };\n\n  const extraExports: Export[] = [];\n\n  const errors: string[] = [];\n\n  if (pkg.exports) {\n    if (!pkg.exports['./package.json']) {\n      errors.push('package.json: `exports[\"./package.json\"] must be declared.');\n    }\n\n    Object.entries(pkg.exports).forEach(([path, entry]) => {\n      if (path.endsWith('.json')) {\n        if (path === './package.json' && entry !== './package.json') {\n          errors.push(\"package.json: 'exports[\\\"./package.json\\\"]' must be './package.json'.\");\n        }\n      } else if (Boolean(entry) && typeof entry === 'object' && !Array.isArray(entry)) {\n        if (path === '.') {\n          if (entry.require && rootExport.require && entry.require !== rootExport.require) {\n            errors.push(\n              \"package.json: mismatch between 'main' and 'exports.require'. These must be equal.\"\n            );\n          }\n\n          if (entry.import && rootExport.import && entry.import !== rootExport.import) {\n            errors.push(\n              \"package.json: mismatch between 'module' and 'exports.import' These must be equal.\"\n            );\n          }\n\n          if (entry.types && rootExport.types && entry.types !== rootExport.types) {\n            errors.push(\n              \"package.json: mismatch between 'types' and 'exports.types'. These must be equal.\"\n            );\n          }\n\n          if (entry.source && rootExport.source && entry.source !== rootExport.source) {\n            errors.push(\n              \"package.json: mismatch between 'source' and 'exports.source'. These must be equal.\"\n            );\n          }\n\n          Object.assign(rootExport, entry);\n        } else {\n          const extraExport = {\n            _exported: true,\n            _path: path,\n            ...entry,\n          };\n\n          extraExports.push(extraExport);\n        }\n      } else {\n        errors.push('package.json: exports must be an object');\n      }\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const _exports = [\n    /**\n     * In the case of strapi plugins, we don't have a root export because we\n     * ship a server side and client side package. So this can be completely omitted.\n     */\n    Object.values(rootExport).some((exp) => exp !== rootExport._path && Boolean(exp)) && rootExport,\n    ...extraExports,\n  ].filter((exp) => Boolean(exp)) as Array<Export & { _path: string }>;\n\n  errors.push(...validateExports(_exports, { extMap, pkg }));\n\n  if (errors.length) {\n    throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);\n  }\n\n  return _exports;\n};\n\nexport { validateExportsOrdering, getExportExtensionMap, parseExports };\nexport type { ExtMap, Export, Extensions };\n","import chalk from 'chalk';\n\ninterface LoggerOptions {\n  silent?: boolean;\n  debug?: boolean;\n}\n\nexport interface Logger {\n  warnings: number;\n  errors: number;\n  debug: (...args: any[]) => void;\n  info: (...args: any[]) => void;\n  warn: (...args: any[]) => void;\n  error: (...args: any[]) => void;\n  log: (...args: any[]) => void;\n  success: (...args: any[]) => void;\n}\n\nexport const createLogger = (options: LoggerOptions = {}): Logger => {\n  const { silent = false, debug = false } = options;\n\n  const state = { errors: 0, warning: 0 };\n\n  return {\n    get warnings() {\n      return state.warning;\n    },\n\n    get errors() {\n      return state.errors;\n    },\n\n    debug(...args) {\n      if (silent || !debug) {\n        return;\n      }\n\n      console.debug(chalk.cyan('[DEBUG] '), ...args);\n    },\n\n    info(...args) {\n      if (silent) {\n        return;\n      }\n\n      console.info(chalk.blue('[INFO] '), ...args);\n    },\n\n    log(...args) {\n      if (silent) {\n        return;\n      }\n\n      console.log(...args);\n    },\n\n    warn(...args) {\n      state.warning += 1;\n\n      if (silent) {\n        return;\n      }\n\n      console.warn(chalk.yellow('[WARN] '), ...args);\n    },\n\n    error(...args) {\n      state.errors += 1;\n\n      if (silent) {\n        return;\n      }\n\n      console.error(chalk.red('[ERROR] '), ...args);\n    },\n\n    success(...args) {\n      if (silent) {\n        return;\n      }\n\n      console.info(chalk.green('[SUCCESS] '), ...args);\n    },\n  };\n};\n","/**\n * Utility functions for loading and validating package.json\n * this includes the specific validation of specific parts of\n * the package.json.\n */\nimport chalk from 'chalk';\nimport fs from 'fs/promises';\nimport os from 'os';\nimport pkgUp from 'pkg-up';\nimport * as yup from 'yup';\n\nimport type { Export } from './exports';\nimport type { Logger } from './logger';\n\nconst record = (value: unknown) =>\n  yup\n    .object(\n      typeof value === 'object' && value\n        ? Object.entries(value).reduce<Record<string, yup.SchemaOf<string>>>((acc, [key]) => {\n            acc[key] = yup.string().required();\n\n            return acc;\n          }, {})\n        : {}\n    )\n    .optional();\n\n/**\n * The schema for the package.json that we expect,\n * currently pretty loose.\n */\nconst packageJsonSchema = yup.object({\n  name: yup.string().required(),\n  version: yup.string().required(),\n  description: yup.string().optional(),\n  author: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return yup\n        .object({\n          name: yup.string().required(),\n          email: yup.string().optional(),\n          url: yup.string().optional(),\n        })\n        .optional();\n    }\n\n    return yup.string().optional();\n  }),\n  keywords: yup.array(yup.string()).optional(),\n  type: yup.mixed().oneOf(['commonjs', 'module']).optional(),\n  license: yup.string().optional(),\n  repository: yup\n    .object({\n      type: yup.string().required(),\n      url: yup.string().required(),\n    })\n    .optional(),\n  bugs: yup\n    .object({\n      url: yup.string().required(),\n    })\n    .optional(),\n  homepage: yup.string().optional(),\n  // TODO: be nice just to make this either a string or a record of strings.\n  bin: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return record(value);\n    }\n\n    return yup.string().optional();\n  }),\n  // TODO: be nice just to make this either a string or a record of strings.\n  browser: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return record(value);\n    }\n\n    return yup.string().optional();\n  }),\n  main: yup.string().optional(),\n  module: yup.string().optional(),\n  source: yup.string().optional(),\n  types: yup.string().optional(),\n  exports: yup.lazy((value) =>\n    yup\n      .object(\n        typeof value === 'object'\n          ? Object.entries(value).reduce(\n              (acc, [key, v]) => {\n                if (typeof v === 'object') {\n                  // @ts-expect-error yup is not typed correctly\n                  acc[key] = yup\n                    .object({\n                      types: yup.string().optional(),\n                      source: yup.string().required(),\n                      browser: yup\n                        .object({\n                          source: yup.string().required(),\n                          import: yup.string().optional(),\n                          require: yup.string().optional(),\n                        })\n                        .optional(),\n                      node: yup\n                        .object({\n                          source: yup.string().optional(),\n                          module: yup.string().optional(),\n                          import: yup.string().optional(),\n                          require: yup.string().optional(),\n                        })\n                        .optional(),\n                      module: yup.string().optional(),\n                      import: yup.string().optional(),\n                      require: yup.string().optional(),\n                      default: yup.string().required(),\n                    })\n                    .noUnknown(true);\n                } else {\n                  acc[key] = yup\n                    .string()\n                    .matches(/^\\.\\/.*\\.json$/)\n                    .required();\n                }\n\n                return acc;\n              },\n              {} as Record<string, yup.SchemaOf<string> | yup.SchemaOf<Export>>\n            )\n          : undefined\n      )\n      .optional()\n  ),\n  files: yup.array(yup.string()).optional(),\n  scripts: yup.lazy(record),\n  dependencies: yup.lazy(record),\n  devDependencies: yup.lazy(record),\n  peerDependencies: yup.lazy(record),\n  engines: yup.lazy(record),\n  browserslist: yup.array(yup.string().required()).optional(),\n});\n\n/**\n * @description being a task to load the package.json starting from the current working directory\n * using a shallow find for the package.json  and `fs` to read the file. If no package.json is found,\n * the process will throw with an appropriate error message.\n */\nconst loadPkg = async ({ cwd, logger }: { cwd: string; logger: Logger }): Promise<object> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    throw new Error('Could not find a package.json in the current directory');\n  }\n\n  const buffer = await fs.readFile(pkgPath);\n\n  const pkg = JSON.parse(buffer.toString());\n\n  logger.debug('Loaded package.json:', os.EOL, pkg);\n\n  return pkg;\n};\n\ninterface PackageJson extends Omit<yup.Asserts<typeof packageJsonSchema>, 'type'> {\n  type?: 'commonjs' | 'module';\n}\n\n/**\n * @description validate the package.json against a standardised schema using `yup`.\n * If the validation fails, the process will throw with an appropriate error message.\n */\nconst validatePkg = async ({ pkg }: { pkg: object }): Promise<PackageJson> => {\n  try {\n    const validatedPkg = await packageJsonSchema.validate(pkg, {\n      strict: true,\n    });\n\n    return validatedPkg;\n  } catch (err) {\n    if (err instanceof yup.ValidationError) {\n      switch (err.type) {\n        case 'required':\n          if (err.path) {\n            throw new Error(\n              `'${err.path}' in 'package.json' is required as type '${chalk.magenta(\n                yup.reach(packageJsonSchema, err.path).type\n              )}'`\n            );\n          }\n          break;\n        case 'matches':\n          if (err.params && err.path && 'value' in err.params && 'regex' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.regex\n              )}' (recieved the value '${chalk.magenta(err.params.value)}')`\n            );\n          }\n          break;\n        /**\n         * This will only be thrown if there are keys in the export map\n         * that we don't expect so we can therefore make some assumptions\n         */\n        case 'noUnknown':\n          if (err.path && err.params && 'unknown' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' contains the unknown key ${chalk.magenta(\n                err.params.unknown\n              )}, for compatability only the following keys are allowed: ${chalk.magenta(\n                \"['types', 'source', 'import', 'require', 'default']\"\n              )}`\n            );\n          }\n          break;\n        default:\n          if (err.path && err.params && 'type' in err.params && 'value' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.type\n              )}' (recieved '${chalk.magenta(typeof err.params.value)}')`\n            );\n          }\n      }\n    }\n\n    throw err;\n  }\n};\n\nexport { loadPkg, validatePkg };\nexport type { PackageJson };\n","import os from 'os';\nimport nodePath from 'path';\nimport ts from 'typescript';\n\nimport type { Logger } from './logger';\n\n/**\n * @description Load a tsconfig.json file and return the parsed config\n * after injecting some required defaults for producing types.\n *\n * @internal\n */\nconst loadTsConfig = ({\n  cwd,\n  path,\n  logger,\n}: {\n  cwd: string;\n  path: string;\n  logger: Logger;\n}):\n  | {\n      config: ts.ParsedCommandLine;\n      path: string;\n    }\n  | undefined => {\n  const providedPath = path.split(nodePath.sep);\n  const [configFileName] = providedPath.slice(-1);\n  const pathToConfig = nodePath.join(cwd, providedPath.slice(0, -1).join(nodePath.sep));\n\n  const configPath = ts.findConfigFile(pathToConfig, ts.sys.fileExists, configFileName);\n\n  if (!configPath) {\n    return undefined;\n  }\n\n  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);\n\n  const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, pathToConfig);\n\n  logger.debug('Loaded user TS config:', os.EOL, parsedConfig);\n\n  const { outDir } = parsedConfig.raw.compilerOptions;\n\n  if (!outDir) {\n    throw new Error(\"tsconfig.json is missing 'compilerOptions.outDir'\");\n  }\n\n  parsedConfig.options = {\n    ...parsedConfig.options,\n    declaration: true,\n    declarationDir: outDir,\n    emitDeclarationOnly: true,\n    noEmit: false,\n    outDir,\n  };\n\n  logger.debug('Using TS config:', os.EOL, parsedConfig);\n\n  return {\n    config: parsedConfig,\n    path: configPath,\n  };\n};\n\nexport { loadTsConfig };\n","import browserslistToEsbuild from 'browserslist-to-esbuild';\nimport path from 'path';\n\nimport { resolveConfigProperty } from './core/config';\nimport { parseExports } from './core/exports';\nimport { loadTsConfig } from './core/tsconfig';\n\nimport type { Config } from './core/config';\nimport type { ExtMap, Export } from './core/exports';\nimport type { Logger } from './core/logger';\nimport type { PackageJson } from './core/pkg';\nimport type { ParsedCommandLine } from 'typescript';\n\ninterface BuildContextArgs {\n  config: Config;\n  cwd: string;\n  extMap: ExtMap;\n  logger: Logger;\n  pkg: PackageJson;\n}\n\ninterface Targets {\n  node: string[];\n  web: string[];\n  '*': string[];\n}\n\ntype Runtime = '*' | 'node' | 'web';\n\ninterface BuildContext {\n  config: Config;\n  cwd: string;\n  distPath: string;\n  exports: Record<string, Export>;\n  external: string[];\n  extMap: ExtMap;\n  logger: Logger;\n  pkg: PackageJson;\n  runtime?: Runtime;\n  targets: Targets;\n  ts?: {\n    config: ParsedCommandLine;\n    path: string;\n  };\n}\n\nconst DEFAULT_BROWSERS_LIST_CONFIG = [\n  'last 3 major versions',\n  'Firefox ESR',\n  'last 2 Opera  versions',\n  'not dead',\n  'node 18.0.0',\n];\n\n/**\n * @description Create a build context for the pipeline we're creating,\n * this is shared among tasks so they all use the same settings for core pieces\n * such as a target, distPath, externals etc.\n */\nconst createBuildContext = async ({\n  config,\n  cwd,\n  extMap,\n  logger,\n  pkg,\n}: BuildContextArgs): Promise<BuildContext> => {\n  const tsConfig = loadTsConfig({\n    cwd,\n    path: resolveConfigProperty(config.tsconfig, 'tsconfig.build.json'),\n    logger,\n  });\n\n  const targets = {\n    '*': browserslistToEsbuild(pkg.browserslist ?? DEFAULT_BROWSERS_LIST_CONFIG),\n    node: browserslistToEsbuild(['node 18.0.0']),\n    web: ['esnext'],\n  };\n\n  const parsedExports = parseExports({ extMap, pkg }).reduce(\n    (acc, x) => {\n      const { _path: exportPath, ...exportEntry } = x;\n\n      return { ...acc, [exportPath]: exportEntry };\n    },\n    {} as Record<string, Export>\n  );\n\n  const exports = resolveConfigProperty(config.exports, parsedExports);\n\n  const parsedExternals = [\n    ...(pkg.dependencies ? Object.keys(pkg.dependencies) : []),\n    ...(pkg.peerDependencies ? Object.keys(pkg.peerDependencies) : []),\n  ];\n\n  const external =\n    config && Array.isArray(config.externals)\n      ? [...parsedExternals, ...config.externals]\n      : parsedExternals;\n\n  const outputPaths = Object.values(exports)\n    .flatMap((exportEntry) => {\n      return [\n        exportEntry.import,\n        exportEntry.require,\n        exportEntry.browser?.import,\n        exportEntry.browser?.require,\n        exportEntry.node?.source && exportEntry.node.import,\n        exportEntry.node?.source && exportEntry.node.require,\n      ].filter(Boolean) as string[];\n    })\n    .map((p) => path.resolve(cwd, p));\n\n  const commonDistPath = findCommonDirPath(outputPaths);\n\n  if (commonDistPath === cwd) {\n    throw new Error(\n      'all output files must share a common parent directory which is not the root package directory'\n    );\n  }\n\n  if (commonDistPath && !pathContains(cwd, commonDistPath)) {\n    throw new Error('all output files must be located within the package');\n  }\n\n  const configDistPath = config?.dist ? path.resolve(cwd, config.dist) : undefined;\n\n  const distPath = configDistPath || commonDistPath;\n\n  if (!distPath) {\n    throw new Error(\"could not detect 'dist' path\");\n  }\n\n  return {\n    config,\n    cwd,\n    distPath,\n    exports,\n    external,\n    extMap,\n    logger,\n    pkg,\n    runtime: config?.runtime,\n    targets,\n    ts: tsConfig,\n  };\n};\n\n/**\n * @internal\n */\nconst pathContains = (containerPath: string, itemPath: string): boolean => {\n  return !path.relative(containerPath, itemPath).startsWith('..');\n};\n\n/**\n * @internal\n */\nconst findCommonDirPath = (filePaths: string[]): string | undefined => {\n  let commonPath: string | undefined;\n\n  for (const filePath of filePaths) {\n    let dirPath = path.dirname(filePath);\n\n    if (!commonPath) {\n      commonPath = dirPath;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    while (dirPath !== commonPath) {\n      dirPath = path.dirname(dirPath);\n\n      if (dirPath === commonPath) {\n        break;\n      }\n\n      if (pathContains(dirPath, commonPath)) {\n        commonPath = dirPath;\n        break;\n      }\n\n      if (dirPath === '.') {\n        return undefined;\n      }\n    }\n  }\n\n  return commonPath;\n};\n\nexport { createBuildContext };\nexport type { BuildContext, Targets, Runtime };\n","import path from 'path';\n\nimport type { Extensions } from './core/exports';\nimport type { BuildContext, Runtime } from './createBuildContext';\nimport type { DtsBuildTask } from './tasks/dts/build';\nimport type { DtsBaseTask } from './tasks/dts/types';\nimport type { DtsWatchTask } from './tasks/dts/watch';\nimport type { ViteBuildTask } from './tasks/vite/build';\nimport type { ViteBaseTask, ViteTaskEntry } from './tasks/vite/types';\nimport type { ViteWatchTask } from './tasks/vite/watch';\n\ntype BuildTask = DtsBuildTask | ViteBuildTask;\ntype WatchTask = ViteWatchTask | DtsWatchTask;\n\ntype BaseTask = ViteBaseTask | DtsBaseTask;\n\n/**\n * @description Create the build tasks for the pipeline, this\n * comes from the exports map we've created in the build context.\n * But handles each export line uniquely with space to add more\n * as the standard develops.\n */\nconst createTasks =\n  <TMode extends 'build' | 'watch'>(mode: TMode) =>\n  async (ctx: BuildContext): Promise<TMode extends 'build' ? BuildTask[] : WatchTask[]> => {\n    const tasks: Array<BaseTask> = [];\n\n    const dtsTask: DtsBaseTask = {\n      type: `${mode}:dts`,\n      entries: [],\n    };\n\n    const viteTasks: Record<string, ViteBaseTask> = {};\n\n    const createViteTask = (\n      format: Extensions,\n      runtime: Runtime,\n      { output, ...restEntry }: ViteTaskEntry & Pick<ViteWatchTask | ViteBuildTask, 'output'>\n    ) => {\n      const buildId = `${format}:${output}`;\n\n      if (viteTasks[buildId]) {\n        viteTasks[buildId]?.entries.push(restEntry);\n\n        if (output !== viteTasks[buildId]?.output) {\n          ctx.logger.warn(\n            'Multiple entries with different outputs for the same format are not supported. The first output will be used.'\n          );\n        }\n      } else {\n        viteTasks[buildId] = {\n          type: `${mode}:js`,\n          format,\n          output,\n          runtime,\n          entries: [restEntry],\n        };\n      }\n    };\n\n    const exps = Object.entries(ctx.exports).map(([exportPath, exportEntry]) => ({\n      ...exportEntry,\n      _path: exportPath,\n    }));\n\n    for (const exp of exps) {\n      if (exp.types) {\n        const importId = path.join(ctx.pkg.name, exp._path);\n\n        dtsTask.entries.push({\n          importId,\n          exportPath: exp._path,\n          sourcePath: exp.source,\n          targetPath: exp.types,\n        });\n      }\n\n      if (exp.require) {\n        /**\n         * register CJS task\n         */\n        createViteTask('cjs', ctx.runtime ?? '*', {\n          path: exp._path,\n          entry: exp.source,\n          output: exp.require,\n        });\n      }\n\n      if (exp.import) {\n        /**\n         * register ESM task\n         */\n        createViteTask('es', ctx.runtime ?? '*', {\n          path: exp._path,\n          entry: exp.source,\n          output: exp.import,\n        });\n      }\n\n      if (exp.browser?.require) {\n        createViteTask('cjs', 'web', {\n          path: exp._path,\n          entry: exp.browser?.source || exp.source,\n          output: exp.browser.require,\n        });\n      }\n\n      if (exp.browser?.import) {\n        createViteTask('cjs', 'web', {\n          path: exp._path,\n          entry: exp.browser?.source || exp.source,\n          output: exp.browser.import,\n        });\n      }\n    }\n\n    const bundles = ctx.config.bundles ?? [];\n\n    for (const bundle of bundles) {\n      const idx = bundles.indexOf(bundle);\n\n      if (bundle.require) {\n        createViteTask('cjs', (bundle.runtime || ctx.runtime) ?? '*', {\n          path: `bundle_cjs_${idx}`,\n          entry: bundle.source,\n          output: bundle.require,\n        });\n      }\n\n      if (bundle.import) {\n        createViteTask('es', (bundle.runtime || ctx.runtime) ?? '*', {\n          path: `bundle_esm_${idx}`,\n          entry: bundle.source,\n          output: bundle.import,\n        });\n      }\n\n      if (bundle.types) {\n        const importId = path.join(ctx.pkg.name, bundle.source);\n\n        dtsTask.entries.push({\n          importId,\n          exportPath: bundle.source,\n          sourcePath: bundle.source,\n          targetPath: bundle.types,\n          tsconfig: bundle.tsconfig,\n        });\n      }\n    }\n\n    if (dtsTask.entries.length) {\n      tasks.push(dtsTask);\n    }\n    if (Object.values(viteTasks).length) {\n      tasks.push(...Object.values(viteTasks));\n    }\n\n    return tasks as TMode extends 'build' ? BuildTask[] : WatchTask[];\n  };\n\nconst createBuildTasks = createTasks('build');\nconst createWatchTasks = createTasks('watch');\n\nexport { createBuildTasks, createWatchTasks };\nexport type { BuildTask, WatchTask, BaseTask };\n","import chalk from 'chalk';\nimport path from 'path';\nimport ts from 'typescript';\n\nimport type { Logger } from '../../core/logger';\n\nconst printDiagnostic = (\n  diagnostic: ts.Diagnostic,\n  { logger, cwd }: { logger: Logger; cwd: string }\n) => {\n  let output = ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine);\n\n  if (diagnostic.file && diagnostic.start) {\n    const { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);\n    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine);\n\n    const file = path.relative(cwd, diagnostic.file.fileName);\n\n    output = [\n      `${chalk.cyan(file)}:${chalk.cyan(line + 1)}:${chalk.cyan(character + 1)} - `,\n      `${chalk.gray(`TS${diagnostic.code}:`)} ${message}`,\n    ].join('');\n  }\n\n  switch (diagnostic.category) {\n    case ts.DiagnosticCategory.Error:\n      logger.error(output);\n      break;\n    case ts.DiagnosticCategory.Warning:\n      logger.warn(output);\n      break;\n    case ts.DiagnosticCategory.Message:\n      logger.info(output);\n      break;\n    case ts.DiagnosticCategory.Suggestion:\n      logger.info(output);\n      break;\n    default:\n      break;\n  }\n};\n\nexport { printDiagnostic };\n","import chalk from 'chalk';\nimport os from 'os';\nimport { Observable } from 'rxjs';\nimport ts from 'typescript';\n\nimport { isError } from '../../core/errors';\nimport { loadTsConfig } from '../../core/tsconfig';\n\nimport { printDiagnostic } from './diagnostic';\n\nimport type { DtsBaseTask } from './types';\nimport type { TaskHandler } from '../index';\n\ninterface DtsBuildTask extends DtsBaseTask {\n  type: 'build:dts';\n}\n\nconst dtsBuildTask: TaskHandler<DtsBuildTask> = {\n  print(ctx, task) {\n    const entries = [\n      '   entries:',\n      ...task.entries.map((entry) =>\n        [\n          '    – ',\n          chalk.green(`${entry.importId} `),\n          `${chalk.cyan(entry.sourcePath)} ${chalk.gray('->')} ${chalk.cyan(entry.targetPath)}`,\n        ].join('')\n      ),\n    ];\n\n    ctx.logger.log(['Building type files:', ...entries].join(os.EOL));\n  },\n  run$(ctx, task) {\n    return new Observable((subscriber) => {\n      Promise.all(\n        task.entries.map(async (entry) => {\n          /**\n           * Entry level tsconfig's take precedence\n           */\n          const tsconfig = entry.tsconfig\n            ? loadTsConfig({\n                cwd: ctx.cwd,\n                path: entry.tsconfig,\n                logger: ctx.logger,\n              })\n            : ctx.ts;\n\n          if (!tsconfig) {\n            ctx.logger.warn(\n              `You've added a types entry but no tsconfig.json was found for ${entry.targetPath}. Skipping...`\n            );\n\n            return;\n          }\n\n          const program = ts.createProgram(tsconfig.config.fileNames, tsconfig.config.options);\n\n          const emitResult = program.emit();\n\n          const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);\n\n          for (const diagnostic of allDiagnostics) {\n            printDiagnostic(diagnostic, { logger: ctx.logger, cwd: ctx.cwd });\n          }\n\n          const errors = allDiagnostics.filter(\n            (diag) => diag.category === ts.DiagnosticCategory.Error\n          );\n\n          if (errors.length) {\n            throw new Error('Failed to compile TypeScript definitions');\n          }\n        })\n      )\n        .then(() => {\n          subscriber.complete();\n        })\n        .catch((err) => {\n          subscriber.error(err);\n        });\n    });\n  },\n  async success(ctx, task) {\n    const msg = [\n      'Built types, entries:',\n      task.entries\n        .map(\n          (entry) =>\n            `    ${chalk.blue(`${entry.importId}`)}: ${entry.sourcePath} -> ${entry.targetPath}`\n        )\n        .join(os.EOL),\n    ];\n\n    ctx.logger.success(msg.join(os.EOL));\n  },\n  async fail(ctx, task, err) {\n    if (isError(err)) {\n      ctx.logger.error(err.message);\n    }\n  },\n};\n\nexport { dtsBuildTask };\n\nexport type { DtsBuildTask };\n","import chalk from 'chalk';\nimport os from 'os';\nimport { Observable } from 'rxjs';\nimport ts from 'typescript';\n\nimport { isError } from '../../core/errors';\nimport { loadTsConfig } from '../../core/tsconfig';\n\nimport { printDiagnostic } from './diagnostic';\n\nimport type { DtsBaseTask } from './types';\nimport type { TaskHandler } from '../index';\n\ninterface DtsWatchTask extends DtsBaseTask {\n  type: 'watch:dts';\n}\n\nconst dtsWatchTask: TaskHandler<DtsWatchTask, ts.Diagnostic> = {\n  print(ctx, task) {\n    const msg = [\n      'Building Types, entries:',\n      task.entries\n        .map(\n          (entry) =>\n            `    ${chalk.blue(`${entry.importId}`)}: ${entry.sourcePath} -> ${entry.targetPath}`\n        )\n        .join(os.EOL),\n    ];\n\n    ctx.logger.success(msg.join(os.EOL));\n  },\n  run$(ctx, task) {\n    let programs: Array<\n      ts.WatchOfConfigFile<ts.EmitAndSemanticDiagnosticsBuilderProgram> | undefined\n    > = [];\n\n    return new Observable((subscriber) => {\n      Promise.all(\n        task.entries.map(async (entry) => {\n          /**\n           * Entry level tsconfig's take precedence\n           */\n          const tsconfig = entry.tsconfig\n            ? loadTsConfig({\n                cwd: ctx.cwd,\n                path: entry.tsconfig,\n                logger: ctx.logger,\n              })\n            : ctx.ts;\n\n          if (!tsconfig) {\n            ctx.logger.warn(\n              `You've added a types entry but no tsconfig.json was found for ${entry.targetPath}. Skipping...`\n            );\n\n            return;\n          }\n\n          const compilerHost = ts.createWatchCompilerHost(\n            tsconfig.path,\n            tsconfig.config.options,\n            ts.sys,\n            ts.createEmitAndSemanticDiagnosticsBuilderProgram,\n            (diagnostic) => {\n              subscriber.next(diagnostic);\n            },\n            (diagnostic) => {\n              subscriber.next(diagnostic);\n            }\n          );\n\n          return ts.createWatchProgram(compilerHost);\n        })\n      )\n        .then((progs) => {\n          programs = progs;\n        })\n        .catch((err) => {\n          subscriber.error(err);\n        });\n\n      return () => {\n        programs.forEach((prog) => {\n          prog?.close();\n        });\n      };\n    });\n  },\n  async success(ctx, task, diagnostic) {\n    const { logger, cwd } = ctx;\n\n    /**\n     * This code is \"Found 0 errors. Watching for file changes.\"\n     * which is equivalent to \"BUNDLE_END\" code with rollup/vite.\n     *\n     * So we use this to say, hey we've built your types again!\n     */\n    if (diagnostic.code === 6194) {\n      this.print(ctx, task);\n    }\n\n    /**\n     * We don't want to print messages or suggestions.\n     * Only errors and warnings in watch mode.\n     */\n    if (\n      diagnostic.category === ts.DiagnosticCategory.Message ||\n      diagnostic.category === ts.DiagnosticCategory.Suggestion\n    ) {\n      return;\n    }\n\n    printDiagnostic(diagnostic, { logger, cwd });\n  },\n  async fail(ctx, task, err) {\n    if (isError(err)) {\n      ctx.logger.error(err);\n    }\n  },\n};\n\nexport { dtsWatchTask };\n\nexport type { DtsWatchTask };\n","/* eslint-disable no-nested-ternary */\nimport react from '@vitejs/plugin-react-swc';\nimport { builtinModules } from 'node:module';\nimport path from 'path';\n\nimport { resolveConfigProperty } from '../../core/config';\n\nimport type { ViteBaseTask } from './types';\nimport type { BuildContext } from '../../createBuildContext';\nimport type { InlineConfig } from 'vite';\n\n/**\n * @internal\n */\nconst resolveViteConfig = async (ctx: BuildContext, task: ViteBaseTask) => {\n  const { cwd, distPath, targets, external, extMap, pkg, exports: exportMap } = ctx;\n  const { entries, format, output, runtime } = task;\n  const outputExt = extMap[pkg.type || 'commonjs'][format];\n  const outDir = path.relative(cwd, distPath);\n\n  const { createLogger } = await import('vite');\n  const customLogger = createLogger();\n  customLogger.warn = (msg) => ctx.logger.warn(msg);\n  customLogger.warnOnce = (msg) => ctx.logger.warn(msg);\n  customLogger.error = (msg) => ctx.logger.error(msg);\n  customLogger.info = () => {};\n\n  const exportIds = Object.keys(exportMap).map((exportPath) => path.join(pkg.name, exportPath));\n  const sourcePaths = Object.values(exportMap).map((exp) => path.resolve(cwd, exp.source));\n\n  const basePlugins = runtime === 'node' ? [] : [react()];\n\n  const plugins = ctx.config.plugins\n    ? typeof ctx.config.plugins === 'function'\n      ? ctx.config.plugins({ runtime })\n      : ctx.config.plugins\n    : [];\n\n  const config = {\n    configFile: false,\n    root: cwd,\n    mode: 'production',\n    logLevel: 'warn',\n    clearScreen: false,\n    customLogger,\n    build: {\n      minify: resolveConfigProperty(ctx.config.minify, false),\n      sourcemap: resolveConfigProperty(ctx.config.sourcemap, true),\n      /**\n       * The task runner will clear this for us\n       */\n      emptyOutDir: false,\n      target: targets[runtime],\n      outDir,\n      lib: {\n        entry: entries.map((e) => e.entry),\n        formats: [format],\n        /**\n         * this enforces the file name to match what the output we've\n         * determined from the package.json exports. However, when preserving modules\n         * we want to let Rollup handle the file names.\n         */\n        fileName: resolveConfigProperty(ctx.config.preserveModules, false)\n          ? undefined\n          : () => {\n              return `${path.relative(outDir, output).replace(/\\.[^/.]+$/, '')}${outputExt}`;\n            },\n      },\n      rollupOptions: {\n        external(id, importer) {\n          // Check if the id is a self-referencing import\n          if (exportIds?.includes(id)) {\n            return true;\n          }\n\n          // Check if the id is a file path that points to an exported source file\n          if (importer && (id.startsWith('.') || id.startsWith('/'))) {\n            const idPath = path.resolve(path.dirname(importer), id);\n\n            if (sourcePaths?.includes(idPath)) {\n              ctx.logger.warn(\n                `detected self-referencing import – treating as external: ${path.relative(\n                  cwd,\n                  idPath\n                )}`\n              );\n\n              return true;\n            }\n          }\n\n          const idParts = id.split('/');\n\n          const name = idParts[0]?.startsWith('@') ? `${idParts[0]}/${idParts[1]}` : idParts[0];\n\n          const builtinModulesWithNodePrefix = [\n            ...builtinModules,\n            ...builtinModules.map((modName) => `node:${modName}`),\n          ];\n\n          if (\n            (name && external.includes(name)) ||\n            (name && builtinModulesWithNodePrefix.includes(name))\n          ) {\n            return true;\n          }\n\n          return false;\n        },\n        output: {\n          preserveModules: resolveConfigProperty(ctx.config.preserveModules, false),\n          /**\n           * Mimic TypeScript's behavior, by setting the value to \"auto\" to control\n           * how Rollup handles default, namespace and dynamic imports from external\n           * dependencies in formats like CommonJS that do not natively support\n           * these concepts. Mainly styled-components@5\n           *\n           * For more info see https://rollupjs.org/configuration-options/#output-interop\n           */\n          interop: 'auto',\n          chunkFileNames() {\n            const parts = outputExt.split('.');\n\n            if (parts.length === 3) {\n              return `_chunks/[name]-[hash].${parts[2]}`;\n            }\n\n            return `_chunks/[name]-[hash]${outputExt}`;\n          },\n        },\n      },\n    },\n    plugins: [...basePlugins, ...plugins],\n  } satisfies InlineConfig;\n\n  return import('vite').then(({ mergeConfig }) =>\n    mergeConfig(config, ctx.config.unstable_viteConfig ?? {})\n  );\n};\n\nexport { resolveViteConfig };\n","import chalk from 'chalk';\nimport os from 'os';\nimport path from 'path';\nimport { Observable } from 'rxjs';\n\nimport { isError } from '../../core/errors';\n\nimport { resolveViteConfig } from './config';\n\nimport type { ViteBaseTask } from './types';\nimport type { TaskHandler } from '../index';\n\ninterface ViteBuildTask extends ViteBaseTask {\n  type: 'build:js';\n}\n\nconst viteBuildTask: TaskHandler<ViteBuildTask> = {\n  print(ctx, task) {\n    const targetLines = [\n      '   target:',\n      ...ctx.targets[task.runtime].map((t) => chalk.cyan(`    - ${t}`)),\n    ];\n    const entries = [\n      '   entries:',\n      ...task.entries.map((entry) =>\n        [\n          '    – ',\n          chalk.green(`${path.join(ctx.pkg.name, entry.path)}: `),\n          `${chalk.cyan(entry.entry)} ${chalk.gray('→')} ${chalk.cyan(task.output)}`,\n        ].join('')\n      ),\n    ];\n\n    ctx.logger.log(\n      ['Building javascript files:', `  format: ${task.format}`, ...targetLines, ...entries].join(\n        os.EOL\n      )\n    );\n  },\n  run$(ctx, task) {\n    return new Observable((subscriber) => {\n      resolveViteConfig(ctx, task).then((config) => {\n        ctx.logger.debug('Vite config:', os.EOL, config);\n        import('vite').then(({ build }) => {\n          build(config)\n            .then(() => {\n              subscriber.complete();\n            })\n            .catch((err) => {\n              subscriber.error(err);\n            });\n        });\n      });\n    });\n  },\n  async success(ctx, task) {\n    const msg = [\n      `Built javascript (runtime: ${task.runtime} – target: ${task.format})`,\n      task.entries\n        .map(\n          (e) => `    ${chalk.blue(path.join(ctx.pkg.name, e.path))}: ${e.entry} -> ${task.output}`\n        )\n        .join(os.EOL),\n    ];\n\n    ctx.logger.success(msg.join(os.EOL));\n  },\n  async fail(ctx, task, err) {\n    if (isError(err)) {\n      ctx.logger.error(err.message);\n    }\n  },\n};\n\nexport { viteBuildTask };\nexport type { ViteBuildTask };\n","import chalk from 'chalk';\nimport os from 'os';\nimport path from 'path';\nimport { Observable } from 'rxjs';\n\nimport { isError } from '../../core/errors';\n\nimport { resolveViteConfig } from './config';\n\nimport type { ViteBaseTask } from './types';\nimport type { TaskHandler } from '../index';\n\nexport type InputOption = string | string[] | { [entryAlias: string]: string };\n\n/**\n * This is a copy because it can't be imported from `vite`.\n */\nexport type RollupWatcherEvent =\n  | { code: 'START' }\n  | { code: 'BUNDLE_START'; input?: InputOption; output: readonly string[] }\n  | {\n      code: 'BUNDLE_END';\n      duration: number;\n      input?: InputOption;\n      output: readonly string[];\n      result: object;\n    }\n  | { code: 'END' }\n  | { code: 'ERROR'; error: object; result: object | null };\n\ninterface ViteWatchTask extends ViteBaseTask {\n  type: 'watch:js';\n}\n\nconst viteWatchTask: TaskHandler<ViteWatchTask, RollupWatcherEvent> = {\n  print(ctx, task) {\n    const msg = [\n      `Building Javascript (runtime: ${task.runtime} – target: ${task.format})`,\n      task.entries\n        .map(\n          (e) => `    ${chalk.blue(path.join(ctx.pkg.name, e.path))}: ${e.entry} -> ${task.output}`\n        )\n        .join(os.EOL),\n    ];\n\n    ctx.logger.success(msg.join(os.EOL));\n  },\n  run$(ctx, task) {\n    /**\n     * We need to return an observable here, but vite build\n     * is an async function which the observable does not want,\n     * so we do some classic let definition with if to workaround.\n     */\n    return new Observable((subscriber) => {\n      let watcher: object | null = null;\n\n      resolveViteConfig(ctx, task).then((config) => {\n        ctx.logger.debug(`Vite config:${os.EOL}`, config);\n        import('vite').then(({ build }) => {\n          build({\n            ...config,\n            mode: 'development',\n            build: {\n              ...config.build,\n              watch: {},\n            },\n          }).then((rollupWatcher) => {\n            watcher = rollupWatcher;\n\n            if ('on' in watcher && typeof watcher.on === 'function') {\n              watcher.on('event', (ev: any) => {\n                subscriber.next(ev);\n              });\n            }\n          });\n        });\n      });\n\n      return () => {\n        if (watcher !== null && 'close' in watcher && typeof watcher.close === 'function') {\n          watcher.close();\n        }\n      };\n    });\n  },\n  success(ctx, task, result) {\n    switch (result.code) {\n      case 'BUNDLE_END':\n        this.print(ctx, task);\n        break;\n      case 'ERROR':\n        ctx.logger.error(result.error);\n        break;\n      default:\n        break;\n    }\n  },\n  fail(ctx, task, err) {\n    if (isError(err)) {\n      ctx.logger.error(err);\n    }\n  },\n};\n\nexport { viteWatchTask };\nexport type { ViteWatchTask };\n","import { dtsBuildTask } from './dts/build';\nimport { dtsWatchTask } from './dts/watch';\nimport { viteBuildTask } from './vite/build';\nimport { viteWatchTask } from './vite/watch';\n\nimport type { BuildContext } from '../createBuildContext';\nimport type { DtsBuildTask } from './dts/build';\nimport type { DtsWatchTask } from './dts/watch';\nimport type { ViteBuildTask } from './vite/build';\nimport type { RollupWatcherEvent, ViteWatchTask } from './vite/watch';\nimport type { Observable } from 'rxjs';\nimport type ts from 'typescript';\n\ninterface TaskHandler<Task, Result = void> {\n  print(ctx: BuildContext, task: Task): void;\n  run$(ctx: BuildContext, task: Task): Observable<Result>;\n  success(ctx: BuildContext, task: Task, result: Result): void;\n  fail(ctx: BuildContext, task: Task, err: unknown): void;\n}\n\ninterface TaskHandlers {\n  'build:js': TaskHandler<ViteBuildTask>;\n  'build:dts': TaskHandler<DtsBuildTask>;\n  'watch:js': TaskHandler<ViteWatchTask, RollupWatcherEvent>;\n  'watch:dts': TaskHandler<DtsWatchTask, ts.Diagnostic>;\n}\n\nconst taskHandlers: TaskHandlers = {\n  'build:js': viteBuildTask,\n  'build:dts': dtsBuildTask,\n  'watch:js': viteWatchTask,\n  'watch:dts': dtsWatchTask,\n};\n\nexport { taskHandlers };\nexport type { TaskHandler, TaskHandlers };\n","import fs from 'fs/promises';\nimport ora from 'ora';\nimport os from 'os';\n\nimport { loadConfig, type Config } from './core/config';\nimport { isError } from './core/errors';\nimport { getExportExtensionMap, validateExportsOrdering } from './core/exports';\nimport { createLogger } from './core/logger';\nimport { loadPkg, validatePkg } from './core/pkg';\nimport { createBuildContext } from './createBuildContext';\nimport { createBuildTasks } from './createTasks';\nimport { taskHandlers } from './tasks';\n\nimport type { BuildTask } from './createTasks';\nimport type { TaskHandler } from './tasks';\nimport type { CommonCLIOptions } from '../types';\n\ninterface BuildCLIOptions extends CommonCLIOptions {\n  minify?: boolean;\n  sourcemap?: boolean;\n}\n\ninterface BuildWithConfigFile extends BuildCLIOptions {\n  configFile?: true;\n  config?: never;\n  cwd?: string;\n}\n\ninterface BuildWithoutConfigFile extends BuildCLIOptions {\n  configFile: false;\n  config?: Config;\n  cwd?: string;\n}\n\ntype BuildOptions = BuildWithConfigFile | BuildWithoutConfigFile;\n\nconst build = async (opts: BuildOptions = {}) => {\n  /**\n   * We always want to run in production mode when building and some packages\n   * use NODE_ENV to determine which type of package to import (looking at your react).\n   * Therefore for building, unless it's specifically set by the user, we'll set it to production.\n   */\n  process.env.NODE_ENV = process.env.NODE_ENV || 'production';\n\n  const {\n    silent,\n    debug,\n    cwd = process.cwd(),\n    configFile = true,\n    config: providedConfig,\n    ...configOptions\n  } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  /**\n   * Load the closest package.json and then verify the structure against what we expect.\n   */\n  const packageJsonLoader = ora(`Verifying package.json ${os.EOL}`).start();\n\n  const rawPkg = await loadPkg({ cwd, logger }).catch((err) => {\n    packageJsonLoader.fail();\n\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n\n    logger.debug(`Path checked – ${cwd}`);\n    process.exit(1);\n  });\n\n  const validatedPkg = await validatePkg({\n    pkg: rawPkg,\n  }).catch((err) => {\n    packageJsonLoader.fail();\n\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n\n    process.exit(1);\n  });\n\n  /**\n   * Validate the exports of the package incl. the order of the\n   * exports within the exports map if applicable\n   */\n  const packageJson = await validateExportsOrdering({ pkg: validatedPkg, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n    process.exit(1);\n  });\n\n  packageJsonLoader.succeed('Verified package.json');\n\n  /**\n   * If configFile is true – which is the default, atempt to load the config\n   * otherwise if it's explicitly false then we suspect there might be a config passed\n   * in the options, so we'll use that instead.\n   */\n  const config = configFile ? await loadConfig({ cwd, logger }) : providedConfig;\n\n  /**\n   * We create tasks based on the exports of the package.json\n   * their handlers are then ran in the order of the exports map\n   * and results are logged to see gradual progress.\n   */\n  const buildContextLoader = ora(`Creating build context ${os.EOL}`).start();\n\n  const extMap = getExportExtensionMap();\n\n  const ctx = await createBuildContext({\n    config: { ...config, ...configOptions },\n    cwd,\n    extMap,\n    logger,\n    pkg: packageJson,\n  }).catch((err) => {\n    buildContextLoader.fail();\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n    process.exit(1);\n  });\n\n  logger.debug(`Build context: ${os.EOL}`, ctx);\n\n  const buildTasks = await createBuildTasks(ctx);\n\n  buildContextLoader.succeed('Created build context');\n\n  /**\n   * If the distPath already exists, clean it\n   */\n  try {\n    logger.debug(`Cleaning dist folder: ${ctx.distPath}`);\n    await fs.rm(ctx.distPath, { recursive: true, force: true });\n    logger.debug('Cleaned dist folder');\n  } catch {\n    // do nothing, it will fail if the folder does not exist\n    logger.debug('There was no dist folder to clean');\n  }\n\n  for (const task of buildTasks) {\n    const handler = taskHandlers[task.type] as TaskHandler<BuildTask>;\n\n    handler.print(ctx, task);\n\n    try {\n      const result = await handler.run$(ctx, task).toPromise();\n\n      handler.success(ctx, task, result);\n    } catch (err) {\n      handler.fail(ctx, task, err);\n      // exit as soon as one task fails\n      throw err;\n    }\n  }\n};\n\nexport { build };\nexport type { BuildOptions, BuildCLIOptions, BuildWithConfigFile, BuildWithoutConfigFile };\n","import chokidar from 'chokidar';\nimport path from 'path';\nimport { Observable, distinctUntilChanged, scan, startWith, switchMap } from 'rxjs';\n\nimport { CONFIG_FILE_NAMES, loadConfig } from './core/config';\nimport { getExportExtensionMap, validateExportsOrdering } from './core/exports';\nimport { createLogger } from './core/logger';\nimport { loadPkg, validatePkg } from './core/pkg';\nimport { createBuildContext } from './createBuildContext';\nimport { createWatchTasks } from './createTasks';\nimport { taskHandlers } from './tasks';\n\nimport type { Config } from './core/config';\nimport type { WatchTask } from './createTasks';\nimport type { TaskHandler } from './tasks';\nimport type { CommonCLIOptions } from '../types';\n\ntype WatchCLIOptions = CommonCLIOptions;\n\ninterface WatchOptionsWithoutConfig extends WatchCLIOptions {\n  configFile?: true;\n  config?: never;\n  cwd?: string;\n}\n\ninterface WatchOptionsWithConfig extends WatchCLIOptions {\n  configFile: false;\n  config?: Config;\n  cwd?: string;\n}\n\ntype WatchOptions = WatchOptionsWithConfig | WatchOptionsWithoutConfig;\n\nconst watch = async (opts: WatchOptions) => {\n  const { silent, debug, cwd = process.cwd(), configFile = true, config: providedConfig } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  logger.debug('watching config files');\n\n  const configFilePaths = ['package.json', ...CONFIG_FILE_NAMES].map((fileName) =>\n    path.resolve(cwd, fileName).split(path.sep).join(path.posix.sep)\n  );\n\n  interface FileEvent {\n    event: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir';\n    path: string;\n  }\n\n  const watcher$ = new Observable<FileEvent>((subscriber) => {\n    const watcher = chokidar.watch(configFilePaths, {\n      ignoreInitial: true,\n    });\n\n    const handleEvent = (event: FileEvent['event'], filePath: FileEvent['path']) => {\n      subscriber.next({\n        event,\n        path: filePath,\n      });\n    };\n\n    watcher.on('all', handleEvent);\n\n    return () => {\n      watcher.off('all', handleEvent);\n      watcher.close();\n    };\n  });\n\n  const configFiles$ = watcher$.pipe(\n    scan((files, { event, path: filePath }) => {\n      if (event === 'add') {\n        logger.debug('config file added', filePath);\n\n        return [...files, filePath];\n      }\n\n      if (event === 'unlink') {\n        logger.debug('config file removed', filePath);\n\n        return files.filter((fPath) => fPath !== filePath);\n      }\n\n      if (event === 'change') {\n        logger.log(\n          '--------------------------------------------------------------------------------'\n        );\n        logger.info(path.relative(cwd, filePath), 'changed');\n\n        return files.slice(0);\n      }\n\n      return files;\n    }, configFilePaths),\n    startWith(configFilePaths),\n    distinctUntilChanged()\n  );\n\n  const ctx$ = configFiles$.pipe(\n    switchMap(async (configFiles) => {\n      const files = configFiles.map((f) => path.relative(cwd, f));\n\n      const packageJsonPath = files.find((f) => f === 'package.json');\n\n      if (!packageJsonPath) {\n        throw new Error('missing package.json');\n      }\n\n      const rawPkg = await loadPkg({ cwd, logger });\n\n      const validatedPkg = await validatePkg({\n        pkg: rawPkg,\n      }).catch((err) => {\n        logger.error(err.message);\n        process.exit(1);\n      });\n\n      /**\n       * Validate the exports of the package incl. the order of the\n       * exports within the exports map if applicable\n       */\n      const packageJson = await validateExportsOrdering({ pkg: validatedPkg, logger }).catch(\n        (err) => {\n          logger.error(err.message);\n          process.exit(1);\n        }\n      );\n\n      /**\n       * If configFile is true – which is the default, atempt to load the config\n       * otherwise if it's explicitly false then we suspect there might be a config passed\n       * in the options, so we'll use that instead.\n       */\n      const config = configFile ? await loadConfig({ cwd, logger }) : providedConfig;\n      /**\n       * We create tasks based on the exports of the package.json\n       * their handlers are then ran in the order of the exports map\n       * and results are logged to see gradual progress.\n       */\n\n      const extMap = getExportExtensionMap();\n\n      return createBuildContext({\n        config: { ...config },\n        cwd,\n        extMap,\n        logger,\n        pkg: packageJson,\n      }).catch((err) => {\n        logger.error(err.message);\n        process.exit(1);\n      });\n    })\n  );\n\n  ctx$.subscribe(async (ctx) => {\n    const watchTasks = await createWatchTasks(ctx);\n\n    for (const task of watchTasks) {\n      const handler = taskHandlers[task.type] as TaskHandler<WatchTask, unknown>;\n\n      const result$ = handler.run$(ctx, task);\n\n      result$.subscribe({\n        error(err) {\n          handler.fail(ctx, task, err);\n\n          process.exit(1);\n        },\n        next(result) {\n          handler.success(ctx, task, result);\n        },\n      });\n    }\n  });\n};\n\nexport { watch };\nexport type { WatchOptions, WatchOptionsWithConfig, WatchOptionsWithoutConfig, WatchCLIOptions };\n","import { readdir, lstat, access, mkdir } from 'fs/promises';\n\n/**\n * @internal\n */\nconst isEmptyDirectory = async (dir: string) => {\n  const files = await readdir(dir);\n\n  return files.length === 0;\n};\n\n/**\n * @internal\n */\nconst isDirectory = async (dir: string) => {\n  const stats = await lstat(dir);\n\n  return stats.isDirectory();\n};\n\n/**\n * @internal\n */\nconst pathExists = async (path: string) => {\n  try {\n    await access(path);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * @internal\n *\n * @description Ensures that the path is viable for a package to be created at\n * by checking if it exists, if not creating it and if it does exist ensuring it's\n * an empty directory. It will fail if any of these conditions are not met.\n */\nconst ensurePackagePathIsViable = async (path: string) => {\n  const exists = await pathExists(path);\n\n  if (!exists) {\n    await mkdir(path, { recursive: true });\n  }\n\n  const isEmpty = await isEmptyDirectory(path);\n\n  if (!isEmpty) {\n    throw new Error(`${path} is not empty`);\n  }\n\n  const isDir = await isDirectory(path);\n\n  if (!isDir) {\n    throw new Error(`${path} is not a directory`);\n  }\n};\n\nexport { ensurePackagePathIsViable, pathExists };\n","import chalk from 'chalk';\nimport esbuild from 'esbuild';\nimport ora from 'ora';\nimport os from 'os';\nimport { resolve } from 'path';\n\nimport { loadConfig } from './core/config';\nimport { isError } from './core/errors';\nimport { getExportExtensionMap, validateExportsOrdering } from './core/exports';\nimport { pathExists } from './core/files';\nimport { createLogger } from './core/logger';\nimport { loadPkg, validatePkg } from './core/pkg';\nimport { createBuildContext } from './createBuildContext';\n\nimport type { CommonCLIOptions } from '../types';\nimport type { Logger } from './core/logger';\nimport type { BuildFailure, Format, Message } from 'esbuild';\n\nexport interface CheckOptions extends CommonCLIOptions {\n  cwd?: string;\n}\n\nexport const check = async (opts: CheckOptions = {}) => {\n  const { silent, debug, cwd = process.cwd() } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  /**\n   * Load the closest package.json and then verify the structure against what we expect.\n   */\n  const packageJsonLoader = ora(`Verifying package.json ${os.EOL}`).start();\n\n  const rawPkg = await loadPkg({ cwd, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    logger.debug(`Path checked – ${cwd}`);\n    process.exit(1);\n  });\n\n  const validatedPkg = await validatePkg({\n    pkg: rawPkg,\n  }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  /**\n   * Validate the exports of the package incl. the order of the\n   * exports within the exports map if applicable\n   */\n  const packageJson = await validateExportsOrdering({ pkg: validatedPkg, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  packageJsonLoader.succeed('Verified package.json');\n\n  /**\n   * We create tasks based on the exports of the package.json\n   * their handlers are then ran in the order of the exports map\n   * and results are logged to see gradual progress.\n   */\n  const config = await loadConfig({ cwd, logger });\n\n  const extMap = getExportExtensionMap();\n\n  const ctx = await createBuildContext({\n    config: { ...config },\n    cwd,\n    extMap,\n    logger,\n    pkg: packageJson,\n  }).catch((err) => {\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  logger.debug(`Build context: ${os.EOL}`, ctx);\n\n  const missingExports: string[] = [];\n\n  const checkingFilePathsLoader = ora('Checking files for exports').start();\n\n  /**\n   * This is arguably verbose but realistically it's clearer what we're checking here\n   * which is _every_ export option you've declared in your package.json is a real file.\n   */\n  for (const exp of Object.values(ctx.exports)) {\n    if (exp.source && !(await pathExists(resolve(ctx.cwd, exp.source)))) {\n      missingExports.push(exp.source);\n    }\n\n    if (exp.types && !(await pathExists(resolve(ctx.cwd, exp.types)))) {\n      missingExports.push(exp.types);\n    }\n\n    if (exp.require && !(await pathExists(resolve(ctx.cwd, exp.require)))) {\n      missingExports.push(exp.require);\n    }\n\n    if (exp.import && !(await pathExists(resolve(ctx.cwd, exp.import)))) {\n      missingExports.push(exp.import);\n    }\n\n    if (exp.module && !(await pathExists(resolve(ctx.cwd, exp.module)))) {\n      missingExports.push(exp.module);\n    }\n\n    if (exp.default && !(await pathExists(resolve(ctx.cwd, exp.default)))) {\n      missingExports.push(exp.default);\n    }\n\n    if (exp.browser) {\n      if (exp.browser.source && !(await pathExists(resolve(ctx.cwd, exp.browser.source)))) {\n        missingExports.push(exp.browser.source);\n      }\n\n      if (exp.browser.import && !(await pathExists(resolve(ctx.cwd, exp.browser.import)))) {\n        missingExports.push(exp.browser.import);\n      }\n\n      if (exp.browser.require && !(await pathExists(resolve(ctx.cwd, exp.browser.require)))) {\n        missingExports.push(exp.browser.require);\n      }\n    }\n\n    if (exp.node) {\n      if (exp.node.source && !(await pathExists(resolve(ctx.cwd, exp.node.source)))) {\n        missingExports.push(exp.node.source);\n      }\n\n      if (exp.node.import && !(await pathExists(resolve(ctx.cwd, exp.node.import)))) {\n        missingExports.push(exp.node.import);\n      }\n\n      if (exp.node.require && !(await pathExists(resolve(ctx.cwd, exp.node.require)))) {\n        missingExports.push(exp.node.require);\n      }\n\n      if (exp.node.module && !(await pathExists(resolve(ctx.cwd, exp.node.module)))) {\n        missingExports.push(exp.node.module);\n      }\n    }\n  }\n\n  if (missingExports.length) {\n    checkingFilePathsLoader.fail('');\n    logger.error(\n      [\n        'Missing files for exports:',\n        ...missingExports.map((str) => `    ${chalk.blue(str)} -> ${resolve(ctx.cwd, str)}`),\n      ].join(os.EOL)\n    );\n    process.exit(1);\n  }\n\n  checkingFilePathsLoader.succeed('');\n\n  /**\n   * Now we know the files exist, we want to double check that they can be accurately resolved.\n   */\n  const exportPaths = Object.values(ctx.exports).reduce<{ require: string[]; import: string[] }>(\n    (acc, exp) => {\n      if (exp.require) {\n        acc.require.push(exp.require);\n      }\n      if (exp.import) {\n        acc.import.push(exp.import);\n      }\n\n      return acc;\n    },\n    {\n      require: [],\n      import: [],\n    }\n  );\n\n  if (exportPaths.import.length > 0) {\n    await resolveExports(exportPaths.import, {\n      cwd: ctx.cwd,\n      external: ctx.external,\n      format: 'esm',\n      logger,\n    });\n  }\n  if (exportPaths.require.length > 0) {\n    await resolveExports(exportPaths.require, {\n      cwd: ctx.cwd,\n      external: ctx.external,\n      format: 'cjs',\n      logger,\n    });\n  }\n};\n\ninterface ResolveExportsOptions {\n  cwd: string;\n  external: string[];\n  format: Format;\n  logger: Logger;\n}\n\nconst resolveExports = async (\n  paths: string[],\n  { cwd, format, external, logger }: ResolveExportsOptions\n) => {\n  const esbuildLoader = ora(`Resolving ${format} exports`).start();\n\n  const code = paths\n    .map((id) => (format === 'esm' ? `import('${id}');` : `require('${id}');`))\n    .join(os.EOL);\n\n  try {\n    const esbuildResult = await esbuild.build({\n      bundle: true,\n      external,\n      format,\n      logLevel: 'silent',\n      // otherwise output maps to stdout as we're using stdin\n      outfile: '/dev/null',\n      platform: 'node',\n      stdin: {\n        contents: code,\n        loader: 'js',\n        resolveDir: cwd,\n      },\n    });\n\n    if (esbuildResult.errors.length > 0) {\n      for (const msg of esbuildResult.errors) {\n        printESBuildMessage(msg, logger.error);\n      }\n\n      esbuildLoader.fail();\n      process.exit(1);\n    }\n\n    const esbuildWarnings = esbuildResult.warnings.filter(\n      (msg) => !(msg.detail || msg.text).includes(\"does not affect esbuild's own target setting\")\n    );\n\n    for (const msg of esbuildWarnings) {\n      printESBuildMessage(msg, logger.warn);\n    }\n\n    esbuildLoader.succeed();\n  } catch (err) {\n    if (isESBuildError(err)) {\n      for (const msg of err.errors) {\n        printESBuildMessage(msg, logger.error);\n      }\n    }\n\n    esbuildLoader.fail();\n    process.exit(1);\n  }\n};\n\nconst isESBuildError = (err: unknown): err is BuildFailure => {\n  return isError(err) && 'errors' in err && 'warnings' in err;\n};\n\nconst printESBuildMessage = (msg: Message, log: Logger['error']) => {\n  if (msg.location) {\n    log(\n      [\n        `${msg.detail || msg.text}`,\n        `${msg.location.line} | ${msg.location.lineText}`,\n        `in ./${msg.location.file}:${msg.location.line}:${msg.location.column}`,\n      ].join(os.EOL)\n    );\n  } else {\n    log(msg.detail || msg.text);\n  }\n};\n","/**\n * Extracted & reduced from https://github.com/jonschlinkert/parse-git-config/blob/master/index.js\n */\nimport fs from 'fs/promises';\nimport ini from 'ini';\nimport os from 'os';\nimport path from 'path';\n\nconst resolveConfigPath = async ({ cwd }: { cwd: string }) => {\n  const configPath = path.join(os.homedir(), '.gitconfig');\n\n  try {\n    await fs.access(configPath);\n    return path.resolve(cwd, configPath);\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * This is the type for a parsed git config file.\n *\n * There's another object attached but for ease of\n * readability we're only interested in user information.\n */\ninterface GitConfig {\n  user: {\n    name?: string;\n    email?: string;\n  };\n}\n\nconst parseIni = (str: string): GitConfig => {\n  const normalisedString = str.replace(/\\[(\\S+) \"(.*)\"\\]/g, (m, $1, $2) => {\n    return $1 && $2 ? `[${$1} \"${$2.split('.').join('\\\\.')}\"]` : m;\n  });\n\n  return ini.parse(normalisedString) as GitConfig;\n};\n\n/**\n * @internal\n *\n * @description Parses the global git config file.\n */\nconst parseGlobalGitConfig = async (): Promise<GitConfig | null> => {\n  const cwd = process.cwd();\n\n  const filepath = await resolveConfigPath({ cwd });\n\n  if (!filepath) {\n    return null;\n  }\n\n  const file = await fs.stat(filepath).then(() => fs.readFile(filepath, 'utf8'));\n\n  return parseIni(file);\n};\n\nexport { parseGlobalGitConfig };\nexport type { GitConfig };\n","import { mkdir, writeFile } from 'fs/promises';\nimport os from 'os';\nimport { relative, resolve, dirname } from 'path';\nimport prompts from 'prompts';\n\nimport { isError } from '../core/errors';\nimport { parseGlobalGitConfig } from '../core/git';\n\nimport type {\n  Template,\n  TemplateFeature,\n  TemplateOption,\n  TemplateOrTemplateResolver,\n} from './types';\nimport type { Logger } from '../core/logger';\nimport type { Config as PrettierConfig } from 'prettier';\n\ninterface CreatePackageFromTemplateOpts {\n  logger: Logger;\n  cwd: string;\n  template: TemplateOrTemplateResolver;\n}\n\n/**\n * @internal\n *\n * @description Resolves a template if it's a function and runs\n * through the template to create a new package.\n */\nconst createPackageFromTemplate = async (\n  packagePath: string,\n  opts: CreatePackageFromTemplateOpts\n) => {\n  const { cwd, logger, template: templateOrResolver } = opts;\n\n  const prettier = await import('prettier'); // ESM-only\n\n  const gitConfig = await parseGlobalGitConfig();\n\n  const template =\n    typeof templateOrResolver === 'function'\n      ? await templateOrResolver({ cwd, logger, packagePath, gitConfig })\n      : templateOrResolver;\n\n  logger.info('Creating a new package at: ', relative(cwd, packagePath));\n\n  logger.debug('Loaded template:', os.EOL, template);\n\n  const answers: Parameters<Template['getFiles']>[0] = [];\n\n  if (Array.isArray(template.prompts)) {\n    for (const prompt of template.prompts) {\n      /**\n       * We know it's a TemplateOption if it has a type property.\n       */\n      if ('type' in prompt) {\n        const res = await prompts(prompt, {\n          onCancel() {\n            process.exit(0);\n          },\n        });\n\n        answers.push({ name: prompt.name, answer: res[prompt.name] });\n      } else {\n        const res = prompt.optional\n          ? await prompts({\n              type: 'confirm',\n              name: 'confirm',\n              message: `use ${prompt.name}?`,\n              initial: prompt.initial,\n            })\n          : null;\n\n        answers.push({\n          name: prompt.name,\n          answer: res?.confirm ?? !prompt.optional,\n        });\n      }\n    }\n\n    logger.debug(\n      [\n        'User answers: ',\n        ...answers.map((ans) => `    ${ans.name}: ${JSON.stringify(ans.answer)}`),\n      ].join(os.EOL)\n    );\n  }\n\n  const files = await template.getFiles(answers);\n\n  logger.debug(\n    ['Files to write: ', ...files.map((f) => `    ${f.name}: ${f.contents}`)].join(os.EOL)\n  );\n\n  /**\n   * Sort files alphabetically, just cause it's nice.\n   */\n  files.sort((a, b) => {\n    return a.name.localeCompare(b.name);\n  });\n\n  for (const file of files) {\n    const filePath = resolve(packagePath, file.name);\n\n    await mkdir(dirname(filePath), { recursive: true });\n\n    const defaultPrettierConfig: PrettierConfig = {\n      endOfLine: 'lf',\n      tabWidth: 2,\n      printWidth: 100,\n      singleQuote: true,\n      trailingComma: 'es5',\n    };\n    try {\n      const formattedContents = await prettier.format(file.contents, {\n        ...defaultPrettierConfig,\n        filepath: filePath,\n      });\n\n      await writeFile(filePath, `${formattedContents.trim()}${os.EOL}`);\n    } catch (err) {\n      if (isError(err)) {\n        logger.debug(err.message);\n      }\n\n      await writeFile(filePath, `${file.contents.trim()}${os.EOL}`);\n    }\n\n    logger.success(`Wrote ${relative(cwd, filePath)}`);\n  }\n};\n\n/**\n * @public\n *\n * @description a helper function to define your package template in a typesafe manner.\n */\nconst defineTemplate = (template: TemplateOrTemplateResolver): TemplateOrTemplateResolver =>\n  template;\n\n/**\n * @public\n *\n * @description Create a prompt for your users to input data for your package template.\n * e.g. \"what is the name of your package?\"\n */\nconst definePackageOption = <T extends string>(option: TemplateOption<T>): TemplateOption<T> =>\n  option;\n\n/**\n * @public\n *\n * @description Create a feature option for your package e.g. \"do you want typescript?\" – yes/no.\n */\nconst definePackageFeature = (feature: TemplateFeature): TemplateFeature => feature;\n\nexport { createPackageFromTemplate, definePackageFeature, definePackageOption, defineTemplate };\n","import { outdent } from 'outdent';\n\nimport type { TemplateFile } from '../../types';\n\nconst editorConfigFile: TemplateFile = {\n  name: '.editorconfig',\n  contents: outdent`\n    root = true\n\n    [*]\n    indent_style = space\n    indent_size = 2\n    end_of_line = lf\n    charset = utf-8\n    trim_trailing_whitespace = true\n    insert_final_newline = true\n    \n    [{package.json,*.yml}]\n    indent_style = space\n    indent_size = 2\n    \n    [*.md]\n    trim_trailing_whitespace = false\n    `,\n};\n\nexport { editorConfigFile };\n","import { outdent } from 'outdent';\n\nimport type { TemplateFile } from '../../types';\n\nconst gitIgnoreFile: TemplateFile = {\n  name: '.gitignore',\n  contents: outdent`\n    # See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n    # dependencies\n    node_modules\n    .pnp\n    .pnp.js\n    \n    # testing\n    coverage\n    \n    # production\n    dist\n    \n    # misc\n    .DS_Store\n    *.pem\n    \n    # debug\n    npm-debug.log*\n    yarn-debug.log*\n    yarn-error.log*\n    \n    # local env files\n    .env\n    .env.local\n    .env.development.local\n    .env.test.local\n    .env.production.local        \n    `,\n};\n\nexport { gitIgnoreFile };\n","import { outdent } from 'outdent';\n\nimport type { TemplateFile } from '../../types';\n\nconst prettierFile: TemplateFile = {\n  name: '.prettierrc',\n  contents: outdent`\n      {\n        \"endOfLine\": 'lf',\n        \"tabWidth\": 2,\n        \"printWidth\": 100,\n        \"singleQuote\": true,\n        \"trailingComma\": 'es5',\n      }\n    `,\n};\n\nconst prettierIgnoreFile: TemplateFile = {\n  name: '.prettierignore',\n  contents: outdent`\n      dist\n      coverage\n    `,\n};\n\nexport { prettierFile, prettierIgnoreFile };\n","import getLatestVersion from 'get-latest-version';\nimport gitUrlParse from 'git-url-parse';\nimport { outdent } from 'outdent';\n\nimport { isError } from '../../core/errors';\nimport { definePackageFeature, definePackageOption, defineTemplate } from '../create';\n\nimport { editorConfigFile } from './files/editorConfig';\nimport { gitIgnoreFile } from './files/gitIgnore';\nimport { prettierFile, prettierIgnoreFile } from './files/prettier';\n\nimport type { PackageJson } from '../../core/pkg';\nimport type { TemplateFile } from '../types';\n\nconst PACKAGE_NAME_REGEXP = /^(?:@(?:[a-z0-9-*~][a-z0-9-*._~]*)\\/)?[a-z0-9-~][a-z0-9-._~]*$/i;\n\nconst defaultTemplate = defineTemplate(async ({ logger, gitConfig }) => {\n  let repo: {\n    source?: string;\n    owner?: string;\n    name?: string;\n  };\n\n  return {\n    prompts: [\n      definePackageOption({\n        name: 'repo',\n        type: 'text',\n        message: 'git url',\n        validate(v) {\n          if (!v) {\n            return true;\n          }\n\n          try {\n            const result = gitUrlParse(v);\n\n            repo = { source: result.source, owner: result.owner, name: result.name };\n\n            return true;\n          } catch (err) {\n            return 'invalid git url';\n          }\n        },\n      }),\n      definePackageOption({\n        name: 'pkgName',\n        type: 'text',\n        message: 'package name',\n        initial: () => repo?.name ?? '',\n        validate(v) {\n          if (!v) {\n            return 'package name is required';\n          }\n\n          const match = PACKAGE_NAME_REGEXP.exec(v);\n\n          if (!match) {\n            return 'invalid package name';\n          }\n\n          return true;\n        },\n      }),\n      definePackageOption({\n        name: 'description',\n        type: 'text',\n        message: 'package description',\n      }),\n      definePackageOption({\n        name: 'authorName',\n        type: 'text',\n        message: 'package author name',\n        initial: gitConfig?.user?.name,\n      }),\n      definePackageOption({\n        name: 'authorEmail',\n        type: 'text',\n        message: 'package author email',\n        initial: gitConfig?.user?.email,\n      }),\n      definePackageOption({\n        name: 'license',\n        type: 'text',\n        message: 'package license',\n        initial: 'MIT',\n        validate(v) {\n          if (!v) {\n            return 'license is required';\n          }\n\n          return true;\n        },\n      }),\n      definePackageFeature({\n        name: 'typescript',\n        initial: true,\n        optional: true,\n      }),\n      definePackageFeature({\n        name: 'eslint',\n        initial: true,\n        optional: true,\n      }),\n    ],\n    async getFiles(answers) {\n      const devDepsToInstall: string[] = [];\n      const author: string[] = [];\n      let isTypescript = false;\n\n      const files: TemplateFile[] = [];\n\n      // package.json\n      const pkgJson: PackageJson = {\n        version: '0.0.0',\n        keywords: [],\n        type: 'commonjs',\n        exports: {\n          // @ts-expect-error yup typings are a bit weak.\n          '.': {\n            require: './dist/index.js',\n            import: './dist/index.mjs',\n            source: '',\n            default: './dist/index.js',\n          },\n          './package.json': './package.json',\n        },\n        main: './dist/index.js',\n        module: './dist/index.mjs',\n        files: ['dist'],\n        scripts: {\n          check: 'pack-up check',\n          build: 'pack-up build',\n          watch: 'pack-up watch',\n        },\n        dependencies: {},\n        devDependencies: {\n          /**\n           * We set * as a default version, but further down\n           * we try to resolve each package to their latest\n           * version, failing that we leave the fallback of *.\n           */\n          '@strapi/pack-up': '*',\n          prettier: '*',\n        },\n      };\n\n      if (Array.isArray(answers)) {\n        for (const ans of answers) {\n          const { name, answer } = ans;\n\n          switch (name) {\n            case 'pkgName': {\n              pkgJson.name = String(answer);\n              break;\n            }\n            case 'description': {\n              pkgJson.description = String(answer) ?? undefined;\n              break;\n            }\n            case 'authorName': {\n              author.push(String(answer));\n              break;\n            }\n            case 'authorEmail': {\n              if (answer) {\n                author.push(`<${answer}>`);\n              }\n              break;\n            }\n            case 'license': {\n              pkgJson.license = String(answer);\n              break;\n            }\n            case 'typescript': {\n              isTypescript = Boolean(answer);\n\n              pkgJson.source = isTypescript ? './src/index.ts' : './src/index.js';\n\n              if (isRecord(pkgJson.exports['.'])) {\n                pkgJson.exports['.'].source = isTypescript ? './src/index.ts' : './src/index.js';\n              }\n\n              if (isTypescript) {\n                pkgJson.types = './dist/index.d.ts';\n\n                if (isRecord(pkgJson.exports['.'])) {\n                  pkgJson.exports['.'] = {\n                    // @ts-expect-error it won't be overwritten.\n                    types: './dist/index.d.ts',\n                    ...pkgJson.exports['.'],\n                  };\n                }\n\n                pkgJson.scripts = {\n                  ...pkgJson.scripts,\n                  'test:ts': 'tsc --build',\n                };\n\n                devDepsToInstall.push('typescript');\n\n                const { tsconfigBuildFile, tsconfigFile } = await import('./files/typescript');\n\n                files.push(tsconfigFile, tsconfigBuildFile);\n              }\n\n              // source\n              files.push({\n                name: isTypescript ? 'src/index.ts' : 'src/index.js',\n                contents: outdent`\n                  /**\n                   * @public\n                   */\n                  const main = () => {\n                    // silence is golden\n                  }\n\n                  export { main }\n                `,\n              });\n\n              break;\n            }\n            case 'eslint': {\n              if (answer) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const eslintConfig: any = {\n                  root: true,\n                  env: {\n                    browser: true,\n                    es6: true,\n                    node: true,\n                  },\n                  extends: ['eslint:recommended', 'plugin:prettier/recommended'],\n                  parserOptions: {\n                    ecmaVersion: 'latest',\n                    sourceType: 'module',\n                  },\n                  plugins: ['prettier'],\n                };\n\n                if (isTypescript) {\n                  eslintConfig.overrides = [\n                    {\n                      files: ['**/*.ts', '**/*.tsx'],\n                      parser: '@typescript-eslint/parser',\n                      parserOptions: {\n                        project: ['./tsconfig.eslint.json'],\n                      },\n                      extends: [\n                        'eslint:recommended',\n                        'plugin:prettier/recommended',\n                        'plugin:@typescript-eslint/eslint-recommended',\n                        'plugin:@typescript-eslint/recommended',\n                      ],\n                      plugins: ['@typescript-eslint', 'prettier'],\n                    },\n                  ];\n\n                  const { tsconfigEslintFile } = await import('./files/typescript');\n\n                  // tsconfig.eslint.json\n                  files.push(tsconfigEslintFile);\n                }\n\n                pkgJson.scripts = {\n                  ...pkgJson.scripts,\n                  lint: isTypescript\n                    ? 'eslint . --ext .cjs,.js,.ts,.tsx'\n                    : 'eslint . --ext .cjs,.js',\n                };\n\n                devDepsToInstall.push('eslint', 'eslint-config-prettier', 'eslint-plugin-prettier');\n\n                if (isTypescript) {\n                  devDepsToInstall.push(\n                    '@typescript-eslint/eslint-plugin',\n                    '@typescript-eslint/parser'\n                  );\n                }\n\n                const { eslintIgnoreFile } = await import('./files/eslint');\n\n                files.push(\n                  {\n                    name: '.eslintrc',\n                    contents: outdent`\n                    ${JSON.stringify(eslintConfig, null, 2)}\n                  `,\n                  },\n                  eslintIgnoreFile\n                );\n              }\n\n              break;\n            }\n            default:\n              break;\n          }\n        }\n      }\n\n      if (repo) {\n        pkgJson.repository = {\n          type: 'git',\n          url: `git+ssh://git@${repo.source}/${repo.owner}/${repo.name}.git`,\n        };\n        pkgJson.bugs = {\n          url: `https://${repo.source}/${repo.owner}/${repo.name}/issues`,\n        };\n        pkgJson.homepage = `https://${repo.source}/${repo.owner}/${repo.name}#readme`;\n      }\n\n      pkgJson.author = author.filter(Boolean).join(' ') ?? undefined;\n\n      try {\n        pkgJson.devDependencies = await resolveLatestVerisonOfDeps([\n          ...devDepsToInstall,\n          ...Object.keys(pkgJson.devDependencies),\n        ]);\n      } catch (err) {\n        if (isError(err)) {\n          logger.error(err.message);\n        } else {\n          logger.error(err);\n        }\n      }\n\n      files.push({\n        name: 'package.json',\n        contents: outdent`\n          ${JSON.stringify(pkgJson, null, 2)}\n        `,\n      });\n\n      /**\n       * PRETTIER IS INSTALLED BY DEFAULT.\n       */\n      files.push(prettierFile, prettierIgnoreFile, editorConfigFile, gitIgnoreFile);\n\n      return files;\n    },\n  };\n});\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  Boolean(value) && !Array.isArray(value) && typeof value === 'object';\n\nconst resolveLatestVerisonOfDeps = async (deps: string[]): Promise<Record<string, string>> => {\n  const latestDeps: Record<string, string> = {};\n\n  for (const name of deps) {\n    try {\n      const latestVersion = await getLatestVersion(name, '*');\n      latestDeps[name] = latestVersion ? `^${latestVersion}` : '*';\n    } catch (err) {\n      latestDeps[name] = '*';\n    }\n  }\n\n  return latestDeps;\n};\n\nexport { defaultTemplate };\n","import { register } from 'esbuild-register/dist/node';\nimport { existsSync } from 'fs';\nimport { resolve } from 'path';\n\nimport type { TemplateOrTemplateResolver } from './types';\nimport type { Logger } from '../core/logger';\n\n/**\n * @internal\n *\n * @description Resolve a template from a path and return it.\n */\nconst loadTemplate = (\n  path: string,\n  { logger }: { logger: Logger }\n): TemplateOrTemplateResolver | undefined => {\n  const configPath = resolve(path);\n\n  const exists = existsSync(configPath);\n\n  if (exists) {\n    const esbuildOptions = { extensions: ['.js', '.mjs', '.ts'] };\n\n    const { unregister } = register(esbuildOptions);\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const mod = require(configPath);\n\n    unregister();\n\n    if (!mod) {\n      logger.warn(`Could not find template at: ${path}. Are you sure it exists?`);\n      return undefined;\n    }\n\n    logger.debug('Loaded user provided template from: ', path);\n\n    /**\n     * handles esm or cjs exporting.\n     */\n    return mod?.default || mod;\n  }\n\n  logger.warn(`Could not find template at: ${path}. Are you sure it exists?`);\n\n  return undefined;\n};\n\nexport { loadTemplate };\n","import { resolve } from 'path';\n\nimport { isError } from './core/errors';\nimport { ensurePackagePathIsViable } from './core/files';\nimport { createLogger } from './core/logger';\nimport { createPackageFromTemplate } from './templates/create';\nimport { defaultTemplate } from './templates/internal/default';\nimport { loadTemplate } from './templates/load';\n\nimport type { CommonCLIOptions } from '../types';\nimport type { TemplateOrTemplateResolver } from './templates/types';\n\nexport interface InitOptions extends CommonCLIOptions {\n  cwd?: string;\n  path: string;\n  template?: TemplateOrTemplateResolver | string;\n}\n\nexport const init = async (opts: InitOptions) => {\n  const { silent, debug, cwd = process.cwd(), path } = opts;\n  let { template = defaultTemplate } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  if (!path) {\n    logger.error('Path is a required option');\n    process.exit(1);\n  }\n\n  const packageRoot = resolve(cwd, path);\n\n  logger.debug('Package is: ', packageRoot);\n\n  if (typeof template === 'string') {\n    const templatePath = resolve(cwd, template);\n    const userTemplate = loadTemplate(templatePath, { logger });\n\n    if (userTemplate) {\n      template = userTemplate;\n    } else {\n      /**\n       * the loadTemplate function would have already warned the user\n       * we can't find their template, we just now ensure we don't\n       * pass the string.\n       */\n      template = defaultTemplate;\n    }\n  }\n\n  await ensurePackagePathIsViable(packageRoot).catch((err) => {\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n\n    process.exit(1);\n  });\n\n  logger.debug('Package path is viable');\n\n  await createPackageFromTemplate(packageRoot, {\n    logger,\n    cwd,\n    template,\n  });\n};\n"],"names":["pkgUp","path","fs","register","os","exports","chalk","yup","nodePath","ts","browserslistToEsbuild","Observable","createLogger","react","builtinModules","build","ora","chokidar","scan","startWith","distinctUntilChanged","switchMap","readdir","lstat","access","mkdir","resolve","esbuild","ini","relative","prompts","dirname","writeFile","outdent","gitUrlParse","getLatestVersion","existsSync"],"mappings":"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"}