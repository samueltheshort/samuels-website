{"version":3,"file":"createBuildContext-CXgI6_LS.js","sources":["../../src/node/core/config.ts","../../src/node/core/exports.ts","../../src/node/core/pkg.ts","../../src/node/core/tsconfig.ts","../../src/node/createBuildContext.ts"],"sourcesContent":["import { register } from 'esbuild-register/dist/node';\nimport * as fs from 'fs';\nimport os from 'os';\nimport * as path from 'path';\nimport pkgUp from 'pkg-up';\n\nimport type { Export } from './exports';\nimport type { Logger } from './logger';\nimport type { Runtime } from '../createBuildContext';\nimport type { InlineConfig, PluginOption } from 'vite';\n\ninterface LoadConfigOptions {\n  cwd: string;\n  logger: Logger;\n}\n\nconst CONFIG_FILE_NAMES = [\n  'packup.config.ts',\n  'packup.config.js',\n  'packup.config.cjs',\n  'packup.config.mjs',\n];\n\nconst loadConfig = async ({ cwd, logger }: LoadConfigOptions): Promise<Config | undefined> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    logger.debug(\n      'Could not find a package.json in the current directory, therefore no config was loaded'\n    );\n\n    return undefined;\n  }\n\n  const root = path.dirname(pkgPath);\n\n  for (const fileName of CONFIG_FILE_NAMES) {\n    const configPath = path.resolve(root, fileName);\n\n    const exists = fs.existsSync(configPath);\n\n    if (exists) {\n      const esbuildOptions = { extensions: ['.js', '.mjs', '.ts'] };\n\n      const { unregister } = register(esbuildOptions);\n\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const mod = require(configPath);\n\n      unregister();\n\n      /**\n       * handles esm or cjs exporting.\n       */\n      const config = mod?.default || mod || undefined;\n\n      if (config) {\n        logger.debug('Loaded configuration:', os.EOL, config);\n      }\n\n      return config;\n    }\n  }\n\n  return undefined;\n};\n\ninterface ConfigBundle {\n  source: string;\n  import?: string;\n  require?: string;\n  runtime?: Runtime;\n  tsconfig?: string;\n  types?: string;\n}\n\ninterface ConfigOptions {\n  bundles?: ConfigBundle[];\n  /**\n   * @description the directory to output the bundle to.\n   */\n  dist?: string;\n  /**\n   * @description Overwrite the default exports.\n   */\n  exports?: ConfigProperty<Record<string, Export>>;\n  /**\n   * @description a list of external dependencies to exclude from the bundle.\n   * We already collect the dependencies & peerDeps from the package.json.\n   */\n  externals?: string[];\n  minify?: boolean;\n  plugins?: PluginOption[] | (({ runtime }: { runtime: Runtime }) => PluginOption[]);\n  /**\n   * @alpha\n   *\n   * @description Instead of creating as few chunks as possible, this mode\n   * will create separate chunks for all modules using the original module\n   * names as file names\n   */\n  preserveModules?: boolean;\n  sourcemap?: boolean;\n  runtime?: Runtime;\n  /**\n   * @description path to the tsconfig file to use for the bundle.\n   *\n   * @default tsconfig.build.json\n   */\n  tsconfig?: string;\n\n  /**\n   * @experimental\n   * @description option to overwrite vite's config\n   */\n  unstable_viteConfig?: InlineConfig;\n}\n\n/**\n * @public\n *\n * @description a helper function to define your config in a typesafe manner.\n */\nconst defineConfig = (configOptions: ConfigOptions): ConfigOptions => configOptions;\n\ntype Config = ConfigOptions;\n\ntype ConfigPropertyResolver<T> = (currentValue: T) => T;\n\ntype ConfigProperty<T> = T | ConfigPropertyResolver<T>;\n\n/** @internal */\nexport function resolveConfigProperty<T>(prop: ConfigProperty<T> | undefined, initialValue: T): T {\n  if (prop === undefined || prop === null) {\n    return initialValue;\n  }\n\n  if (typeof prop === 'function') {\n    return (prop as ConfigPropertyResolver<T>)(initialValue);\n  }\n\n  return prop;\n}\n\nexport { loadConfig, defineConfig, CONFIG_FILE_NAMES };\nexport type {\n  Config,\n  ConfigOptions,\n  ConfigBundle,\n  ConfigPropertyResolver,\n  ConfigProperty,\n  PluginOption,\n  Runtime,\n};\n","import os from 'os';\n\nimport type { Logger } from './logger';\nimport type { PackageJson } from './pkg';\n\n/**\n * @description validate the `exports` property of the package.json against a set of rules.\n * If the validation fails, the process will throw with an appropriate error message. If\n * there is no `exports` property we check the standard export-like properties on the root\n * of the package.json.\n */\nconst validateExportsOrdering = async ({\n  pkg,\n  logger,\n}: {\n  pkg: PackageJson;\n  logger: Logger;\n}): Promise<PackageJson> => {\n  if (pkg.exports) {\n    const exports = Object.entries(pkg.exports);\n\n    for (const [expPath, exp] of exports) {\n      if (typeof exp === 'string') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const keys = Object.keys(exp);\n\n      if (!assertFirst('types', keys)) {\n        throw new Error(`exports[\"${expPath}\"]: the 'types' property should be the first property`);\n      }\n\n      if (exp.node) {\n        const nodeKeys = Object.keys(exp.node);\n\n        if (!assertOrder('module', 'import', nodeKeys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.module' property should come before the 'node.import' property`\n          );\n        }\n\n        if (!assertOrder('import', 'require', nodeKeys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.import' property should come before the 'node.require' property`\n          );\n        }\n\n        if (!assertOrder('module', 'require', nodeKeys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.module' property should come before 'node.require' property`\n          );\n        }\n\n        if (exp.import && exp.node.import && !assertOrder('node', 'import', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'import' property`\n          );\n        }\n\n        if (exp.module && exp.node.module && !assertOrder('node', 'module', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'module' property`\n          );\n        }\n\n        /**\n         * If there's a `node.import` property but not a `node.require` we can assume `node.import`\n         * is wrapping `import` and `node.module` should be added for bundlers.\n         */\n        if (\n          exp.node.import &&\n          (!exp.node.require || exp.require === exp.node.require) &&\n          !exp.node.module\n        ) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'node.module' property should be added so bundlers don't unintentionally try to bundle 'node.import'. Its value should be '\"module\": \"${exp.import}\"'`\n          );\n        }\n\n        if (\n          exp.node.import &&\n          !exp.node.require &&\n          exp.node.module &&\n          exp.import &&\n          exp.node.module !== exp.import\n        ) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.module' property should match 'import'`\n          );\n        }\n\n        if (exp.require && exp.node.require && exp.require === exp.node.require) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node.require' property isn't necessary as it's identical to 'require'`\n          );\n        } else if (exp.require && exp.node.require && !assertOrder('node', 'require', keys)) {\n          throw new Error(\n            `exports[\"${expPath}\"]: the 'node' property should come before the 'require' property`\n          );\n        }\n      } else {\n        if (!assertOrder('import', 'require', keys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'import' property should come before the 'require' property`\n          );\n        }\n\n        if (!assertOrder('module', 'import', keys)) {\n          logger.warn(\n            `exports[\"${expPath}\"]: the 'module' property should come before 'import' property`\n          );\n        }\n      }\n      if (!assertLast('default', keys)) {\n        throw new Error(\n          `exports[\"${expPath}\"]: the 'default' property should be the last property`\n        );\n      }\n    }\n  } else if (!['main', 'module'].some((key) => Object.prototype.hasOwnProperty.call(pkg, key))) {\n    throw new Error(\"'package.json' must contain a 'main' and 'module' property\");\n  }\n\n  return pkg;\n};\n\n/** @internal */\nfunction assertFirst(key: string, arr: string[]) {\n  const aIdx = arr.indexOf(key);\n\n  // if not found, then we don't care\n  if (aIdx === -1) {\n    return true;\n  }\n\n  return aIdx === 0;\n}\n\n/** @internal */\nfunction assertLast(key: string, arr: string[]) {\n  const aIdx = arr.indexOf(key);\n\n  // if not found, then we don't care\n  if (aIdx === -1) {\n    return true;\n  }\n\n  return aIdx === arr.length - 1;\n}\n\n/** @internal */\nfunction assertOrder(keyA: string, keyB: string, arr: string[]) {\n  const aIdx = arr.indexOf(keyA);\n  const bIdx = arr.indexOf(keyB);\n\n  // if either is not found, then we don't care\n  if (aIdx === -1 || bIdx === -1) {\n    return true;\n  }\n\n  return aIdx < bIdx;\n}\n\ntype Extensions = 'cjs' | 'es';\n\ninterface ExtMap {\n  commonjs: Record<Extensions, string>;\n  module: Record<Extensions, string>;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_PKG_EXT_MAP = {\n  // pkg.type: \"commonjs\"\n  commonjs: {\n    cjs: '.js',\n    es: '.mjs',\n  },\n\n  // pkg.type: \"module\"\n  module: {\n    cjs: '.cjs',\n    es: '.js',\n  },\n} satisfies ExtMap;\n\n/**\n * We potentially might need to support legacy exports or as package\n * development continues we have space to tweak this.\n */\nconst getExportExtensionMap = (): ExtMap => {\n  return DEFAULT_PKG_EXT_MAP;\n};\n\n/**\n * @internal\n *\n * @description validate the `require` and `import` properties of a given exports maps from the package.json\n * returning if any errors are found.\n */\nconst validateExports = (\n  _exports: Array<Export & { _path: string }>,\n  options: { extMap: ExtMap; pkg: PackageJson }\n) => {\n  const { extMap, pkg } = options;\n  const ext = extMap[pkg.type || 'commonjs'];\n\n  const errors = [];\n\n  for (const exp of _exports) {\n    if (exp.require && !exp.require.endsWith(ext.cjs)) {\n      errors.push(\n        `package.json with 'type: \"${pkg.type}\"' - 'exports[\"${exp._path}\"].require' must end with \"${ext.cjs}\"`\n      );\n    }\n\n    if (exp.import && !exp.import.endsWith(ext.es)) {\n      errors.push(\n        `package.json with 'type: \"${pkg.type}\"' - 'exports[\"${exp._path}\"].import' must end with \"${ext.es}\"`\n      );\n    }\n  }\n\n  return errors;\n};\n\ninterface Export {\n  types?: string;\n  source: string;\n  browser?: {\n    source: string;\n    import?: string;\n    require?: string;\n  };\n  node?: {\n    source?: string;\n    module?: string;\n    import?: string;\n    require?: string;\n  };\n  module?: string;\n  import?: string;\n  require?: string;\n  default: string;\n}\n\n/**\n * @description parse the exports map from the package.json into a standardised\n * format that we can use to generate build tasks from.\n */\nconst parseExports = ({ extMap, pkg }: { extMap: ExtMap; pkg: PackageJson }) => {\n  const rootExport = {\n    _path: '.',\n    types: pkg.types,\n    source: pkg.source || '',\n    require: pkg.main,\n    import: pkg.module,\n    default: pkg.module || pkg.main || '',\n  } satisfies Export & { _path: string };\n\n  const extraExports: Export[] = [];\n\n  const errors: string[] = [];\n\n  if (pkg.exports) {\n    if (!pkg.exports['./package.json']) {\n      errors.push('package.json: `exports[\"./package.json\"] must be declared.');\n    }\n\n    Object.entries(pkg.exports).forEach(([path, entry]) => {\n      if (path.endsWith('.json')) {\n        if (path === './package.json' && entry !== './package.json') {\n          errors.push(\"package.json: 'exports[\\\"./package.json\\\"]' must be './package.json'.\");\n        }\n      } else if (Boolean(entry) && typeof entry === 'object' && !Array.isArray(entry)) {\n        if (path === '.') {\n          if (entry.require && rootExport.require && entry.require !== rootExport.require) {\n            errors.push(\n              \"package.json: mismatch between 'main' and 'exports.require'. These must be equal.\"\n            );\n          }\n\n          if (entry.import && rootExport.import && entry.import !== rootExport.import) {\n            errors.push(\n              \"package.json: mismatch between 'module' and 'exports.import' These must be equal.\"\n            );\n          }\n\n          if (entry.types && rootExport.types && entry.types !== rootExport.types) {\n            errors.push(\n              \"package.json: mismatch between 'types' and 'exports.types'. These must be equal.\"\n            );\n          }\n\n          if (entry.source && rootExport.source && entry.source !== rootExport.source) {\n            errors.push(\n              \"package.json: mismatch between 'source' and 'exports.source'. These must be equal.\"\n            );\n          }\n\n          Object.assign(rootExport, entry);\n        } else {\n          const extraExport = {\n            _exported: true,\n            _path: path,\n            ...entry,\n          };\n\n          extraExports.push(extraExport);\n        }\n      } else {\n        errors.push('package.json: exports must be an object');\n      }\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const _exports = [\n    /**\n     * In the case of strapi plugins, we don't have a root export because we\n     * ship a server side and client side package. So this can be completely omitted.\n     */\n    Object.values(rootExport).some((exp) => exp !== rootExport._path && Boolean(exp)) && rootExport,\n    ...extraExports,\n  ].filter((exp) => Boolean(exp)) as Array<Export & { _path: string }>;\n\n  errors.push(...validateExports(_exports, { extMap, pkg }));\n\n  if (errors.length) {\n    throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);\n  }\n\n  return _exports;\n};\n\nexport { validateExportsOrdering, getExportExtensionMap, parseExports };\nexport type { ExtMap, Export, Extensions };\n","/**\n * Utility functions for loading and validating package.json\n * this includes the specific validation of specific parts of\n * the package.json.\n */\nimport chalk from 'chalk';\nimport fs from 'fs/promises';\nimport os from 'os';\nimport pkgUp from 'pkg-up';\nimport * as yup from 'yup';\n\nimport type { Export } from './exports';\nimport type { Logger } from './logger';\n\nconst record = (value: unknown) =>\n  yup\n    .object(\n      typeof value === 'object' && value\n        ? Object.entries(value).reduce<Record<string, yup.SchemaOf<string>>>((acc, [key]) => {\n            acc[key] = yup.string().required();\n\n            return acc;\n          }, {})\n        : {}\n    )\n    .optional();\n\n/**\n * The schema for the package.json that we expect,\n * currently pretty loose.\n */\nconst packageJsonSchema = yup.object({\n  name: yup.string().required(),\n  version: yup.string().required(),\n  description: yup.string().optional(),\n  author: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return yup\n        .object({\n          name: yup.string().required(),\n          email: yup.string().optional(),\n          url: yup.string().optional(),\n        })\n        .optional();\n    }\n\n    return yup.string().optional();\n  }),\n  keywords: yup.array(yup.string()).optional(),\n  type: yup.mixed().oneOf(['commonjs', 'module']).optional(),\n  license: yup.string().optional(),\n  repository: yup\n    .object({\n      type: yup.string().required(),\n      url: yup.string().required(),\n    })\n    .optional(),\n  bugs: yup\n    .object({\n      url: yup.string().required(),\n    })\n    .optional(),\n  homepage: yup.string().optional(),\n  // TODO: be nice just to make this either a string or a record of strings.\n  bin: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return record(value);\n    }\n\n    return yup.string().optional();\n  }),\n  // TODO: be nice just to make this either a string or a record of strings.\n  browser: yup.lazy((value) => {\n    if (typeof value === 'object') {\n      return record(value);\n    }\n\n    return yup.string().optional();\n  }),\n  main: yup.string().optional(),\n  module: yup.string().optional(),\n  source: yup.string().optional(),\n  types: yup.string().optional(),\n  exports: yup.lazy((value) =>\n    yup\n      .object(\n        typeof value === 'object'\n          ? Object.entries(value).reduce(\n              (acc, [key, v]) => {\n                if (typeof v === 'object') {\n                  // @ts-expect-error yup is not typed correctly\n                  acc[key] = yup\n                    .object({\n                      types: yup.string().optional(),\n                      source: yup.string().required(),\n                      browser: yup\n                        .object({\n                          source: yup.string().required(),\n                          import: yup.string().optional(),\n                          require: yup.string().optional(),\n                        })\n                        .optional(),\n                      node: yup\n                        .object({\n                          source: yup.string().optional(),\n                          module: yup.string().optional(),\n                          import: yup.string().optional(),\n                          require: yup.string().optional(),\n                        })\n                        .optional(),\n                      module: yup.string().optional(),\n                      import: yup.string().optional(),\n                      require: yup.string().optional(),\n                      default: yup.string().required(),\n                    })\n                    .noUnknown(true);\n                } else {\n                  acc[key] = yup\n                    .string()\n                    .matches(/^\\.\\/.*\\.json$/)\n                    .required();\n                }\n\n                return acc;\n              },\n              {} as Record<string, yup.SchemaOf<string> | yup.SchemaOf<Export>>\n            )\n          : undefined\n      )\n      .optional()\n  ),\n  files: yup.array(yup.string()).optional(),\n  scripts: yup.lazy(record),\n  dependencies: yup.lazy(record),\n  devDependencies: yup.lazy(record),\n  peerDependencies: yup.lazy(record),\n  engines: yup.lazy(record),\n  browserslist: yup.array(yup.string().required()).optional(),\n});\n\n/**\n * @description being a task to load the package.json starting from the current working directory\n * using a shallow find for the package.json  and `fs` to read the file. If no package.json is found,\n * the process will throw with an appropriate error message.\n */\nconst loadPkg = async ({ cwd, logger }: { cwd: string; logger: Logger }): Promise<object> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    throw new Error('Could not find a package.json in the current directory');\n  }\n\n  const buffer = await fs.readFile(pkgPath);\n\n  const pkg = JSON.parse(buffer.toString());\n\n  logger.debug('Loaded package.json:', os.EOL, pkg);\n\n  return pkg;\n};\n\ninterface PackageJson extends Omit<yup.Asserts<typeof packageJsonSchema>, 'type'> {\n  type?: 'commonjs' | 'module';\n}\n\n/**\n * @description validate the package.json against a standardised schema using `yup`.\n * If the validation fails, the process will throw with an appropriate error message.\n */\nconst validatePkg = async ({ pkg }: { pkg: object }): Promise<PackageJson> => {\n  try {\n    const validatedPkg = await packageJsonSchema.validate(pkg, {\n      strict: true,\n    });\n\n    return validatedPkg;\n  } catch (err) {\n    if (err instanceof yup.ValidationError) {\n      switch (err.type) {\n        case 'required':\n          if (err.path) {\n            throw new Error(\n              `'${err.path}' in 'package.json' is required as type '${chalk.magenta(\n                yup.reach(packageJsonSchema, err.path).type\n              )}'`\n            );\n          }\n          break;\n        case 'matches':\n          if (err.params && err.path && 'value' in err.params && 'regex' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.regex\n              )}' (recieved the value '${chalk.magenta(err.params.value)}')`\n            );\n          }\n          break;\n        /**\n         * This will only be thrown if there are keys in the export map\n         * that we don't expect so we can therefore make some assumptions\n         */\n        case 'noUnknown':\n          if (err.path && err.params && 'unknown' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' contains the unknown key ${chalk.magenta(\n                err.params.unknown\n              )}, for compatability only the following keys are allowed: ${chalk.magenta(\n                \"['types', 'source', 'import', 'require', 'default']\"\n              )}`\n            );\n          }\n          break;\n        default:\n          if (err.path && err.params && 'type' in err.params && 'value' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.type\n              )}' (recieved '${chalk.magenta(typeof err.params.value)}')`\n            );\n          }\n      }\n    }\n\n    throw err;\n  }\n};\n\nexport { loadPkg, validatePkg };\nexport type { PackageJson };\n","import os from 'os';\nimport nodePath from 'path';\nimport ts from 'typescript';\n\nimport type { Logger } from './logger';\n\n/**\n * @description Load a tsconfig.json file and return the parsed config\n * after injecting some required defaults for producing types.\n *\n * @internal\n */\nconst loadTsConfig = ({\n  cwd,\n  path,\n  logger,\n}: {\n  cwd: string;\n  path: string;\n  logger: Logger;\n}):\n  | {\n      config: ts.ParsedCommandLine;\n      path: string;\n    }\n  | undefined => {\n  const providedPath = path.split(nodePath.sep);\n  const [configFileName] = providedPath.slice(-1);\n  const pathToConfig = nodePath.join(cwd, providedPath.slice(0, -1).join(nodePath.sep));\n\n  const configPath = ts.findConfigFile(pathToConfig, ts.sys.fileExists, configFileName);\n\n  if (!configPath) {\n    return undefined;\n  }\n\n  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);\n\n  const parsedConfig = ts.parseJsonConfigFileContent(configFile.config, ts.sys, pathToConfig);\n\n  logger.debug('Loaded user TS config:', os.EOL, parsedConfig);\n\n  const { outDir } = parsedConfig.raw.compilerOptions;\n\n  if (!outDir) {\n    throw new Error(\"tsconfig.json is missing 'compilerOptions.outDir'\");\n  }\n\n  parsedConfig.options = {\n    ...parsedConfig.options,\n    declaration: true,\n    declarationDir: outDir,\n    emitDeclarationOnly: true,\n    noEmit: false,\n    outDir,\n  };\n\n  logger.debug('Using TS config:', os.EOL, parsedConfig);\n\n  return {\n    config: parsedConfig,\n    path: configPath,\n  };\n};\n\nexport { loadTsConfig };\n","import browserslistToEsbuild from 'browserslist-to-esbuild';\nimport path from 'path';\n\nimport { resolveConfigProperty } from './core/config';\nimport { parseExports } from './core/exports';\nimport { loadTsConfig } from './core/tsconfig';\n\nimport type { Config } from './core/config';\nimport type { ExtMap, Export } from './core/exports';\nimport type { Logger } from './core/logger';\nimport type { PackageJson } from './core/pkg';\nimport type { ParsedCommandLine } from 'typescript';\n\ninterface BuildContextArgs {\n  config: Config;\n  cwd: string;\n  extMap: ExtMap;\n  logger: Logger;\n  pkg: PackageJson;\n}\n\ninterface Targets {\n  node: string[];\n  web: string[];\n  '*': string[];\n}\n\ntype Runtime = '*' | 'node' | 'web';\n\ninterface BuildContext {\n  config: Config;\n  cwd: string;\n  distPath: string;\n  exports: Record<string, Export>;\n  external: string[];\n  extMap: ExtMap;\n  logger: Logger;\n  pkg: PackageJson;\n  runtime?: Runtime;\n  targets: Targets;\n  ts?: {\n    config: ParsedCommandLine;\n    path: string;\n  };\n}\n\nconst DEFAULT_BROWSERS_LIST_CONFIG = [\n  'last 3 major versions',\n  'Firefox ESR',\n  'last 2 Opera  versions',\n  'not dead',\n  'node 18.0.0',\n];\n\n/**\n * @description Create a build context for the pipeline we're creating,\n * this is shared among tasks so they all use the same settings for core pieces\n * such as a target, distPath, externals etc.\n */\nconst createBuildContext = async ({\n  config,\n  cwd,\n  extMap,\n  logger,\n  pkg,\n}: BuildContextArgs): Promise<BuildContext> => {\n  const tsConfig = loadTsConfig({\n    cwd,\n    path: resolveConfigProperty(config.tsconfig, 'tsconfig.build.json'),\n    logger,\n  });\n\n  const targets = {\n    '*': browserslistToEsbuild(pkg.browserslist ?? DEFAULT_BROWSERS_LIST_CONFIG),\n    node: browserslistToEsbuild(['node 18.0.0']),\n    web: ['esnext'],\n  };\n\n  const parsedExports = parseExports({ extMap, pkg }).reduce(\n    (acc, x) => {\n      const { _path: exportPath, ...exportEntry } = x;\n\n      return { ...acc, [exportPath]: exportEntry };\n    },\n    {} as Record<string, Export>\n  );\n\n  const exports = resolveConfigProperty(config.exports, parsedExports);\n\n  const parsedExternals = [\n    ...(pkg.dependencies ? Object.keys(pkg.dependencies) : []),\n    ...(pkg.peerDependencies ? Object.keys(pkg.peerDependencies) : []),\n  ];\n\n  const external =\n    config && Array.isArray(config.externals)\n      ? [...parsedExternals, ...config.externals]\n      : parsedExternals;\n\n  const outputPaths = Object.values(exports)\n    .flatMap((exportEntry) => {\n      return [\n        exportEntry.import,\n        exportEntry.require,\n        exportEntry.browser?.import,\n        exportEntry.browser?.require,\n        exportEntry.node?.source && exportEntry.node.import,\n        exportEntry.node?.source && exportEntry.node.require,\n      ].filter(Boolean) as string[];\n    })\n    .map((p) => path.resolve(cwd, p));\n\n  const commonDistPath = findCommonDirPath(outputPaths);\n\n  if (commonDistPath === cwd) {\n    throw new Error(\n      'all output files must share a common parent directory which is not the root package directory'\n    );\n  }\n\n  if (commonDistPath && !pathContains(cwd, commonDistPath)) {\n    throw new Error('all output files must be located within the package');\n  }\n\n  const configDistPath = config?.dist ? path.resolve(cwd, config.dist) : undefined;\n\n  const distPath = configDistPath || commonDistPath;\n\n  if (!distPath) {\n    throw new Error(\"could not detect 'dist' path\");\n  }\n\n  return {\n    config,\n    cwd,\n    distPath,\n    exports,\n    external,\n    extMap,\n    logger,\n    pkg,\n    runtime: config?.runtime,\n    targets,\n    ts: tsConfig,\n  };\n};\n\n/**\n * @internal\n */\nconst pathContains = (containerPath: string, itemPath: string): boolean => {\n  return !path.relative(containerPath, itemPath).startsWith('..');\n};\n\n/**\n * @internal\n */\nconst findCommonDirPath = (filePaths: string[]): string | undefined => {\n  let commonPath: string | undefined;\n\n  for (const filePath of filePaths) {\n    let dirPath = path.dirname(filePath);\n\n    if (!commonPath) {\n      commonPath = dirPath;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    while (dirPath !== commonPath) {\n      dirPath = path.dirname(dirPath);\n\n      if (dirPath === commonPath) {\n        break;\n      }\n\n      if (pathContains(dirPath, commonPath)) {\n        commonPath = dirPath;\n        break;\n      }\n\n      if (dirPath === '.') {\n        return undefined;\n      }\n    }\n  }\n\n  return commonPath;\n};\n\nexport { createBuildContext };\nexport type { BuildContext, Targets, Runtime };\n"],"names":["pkgUp","path","fs","register","os","exports","yup","chalk","nodePath","ts","browserslistToEsbuild"],"mappings":"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"}