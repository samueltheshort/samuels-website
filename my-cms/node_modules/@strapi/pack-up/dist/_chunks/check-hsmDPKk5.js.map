{"version":3,"file":"check-hsmDPKk5.js","sources":["../../src/node/check.ts","../../src/cli/commands/check.ts"],"sourcesContent":["import chalk from 'chalk';\nimport esbuild from 'esbuild';\nimport ora from 'ora';\nimport os from 'os';\nimport { resolve } from 'path';\n\nimport { loadConfig } from './core/config';\nimport { isError } from './core/errors';\nimport { getExportExtensionMap, validateExportsOrdering } from './core/exports';\nimport { pathExists } from './core/files';\nimport { createLogger } from './core/logger';\nimport { loadPkg, validatePkg } from './core/pkg';\nimport { createBuildContext } from './createBuildContext';\n\nimport type { CommonCLIOptions } from '../types';\nimport type { Logger } from './core/logger';\nimport type { BuildFailure, Format, Message } from 'esbuild';\n\nexport interface CheckOptions extends CommonCLIOptions {\n  cwd?: string;\n}\n\nexport const check = async (opts: CheckOptions = {}) => {\n  const { silent, debug, cwd = process.cwd() } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  /**\n   * Load the closest package.json and then verify the structure against what we expect.\n   */\n  const packageJsonLoader = ora(`Verifying package.json ${os.EOL}`).start();\n\n  const rawPkg = await loadPkg({ cwd, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    logger.debug(`Path checked â€“ ${cwd}`);\n    process.exit(1);\n  });\n\n  const validatedPkg = await validatePkg({\n    pkg: rawPkg,\n  }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  /**\n   * Validate the exports of the package incl. the order of the\n   * exports within the exports map if applicable\n   */\n  const packageJson = await validateExportsOrdering({ pkg: validatedPkg, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  packageJsonLoader.succeed('Verified package.json');\n\n  /**\n   * We create tasks based on the exports of the package.json\n   * their handlers are then ran in the order of the exports map\n   * and results are logged to see gradual progress.\n   */\n  const config = await loadConfig({ cwd, logger });\n\n  const extMap = getExportExtensionMap();\n\n  const ctx = await createBuildContext({\n    config: { ...config },\n    cwd,\n    extMap,\n    logger,\n    pkg: packageJson,\n  }).catch((err) => {\n    logger.error(err.message);\n    process.exit(1);\n  });\n\n  logger.debug(`Build context: ${os.EOL}`, ctx);\n\n  const missingExports: string[] = [];\n\n  const checkingFilePathsLoader = ora('Checking files for exports').start();\n\n  /**\n   * This is arguably verbose but realistically it's clearer what we're checking here\n   * which is _every_ export option you've declared in your package.json is a real file.\n   */\n  for (const exp of Object.values(ctx.exports)) {\n    if (exp.source && !(await pathExists(resolve(ctx.cwd, exp.source)))) {\n      missingExports.push(exp.source);\n    }\n\n    if (exp.types && !(await pathExists(resolve(ctx.cwd, exp.types)))) {\n      missingExports.push(exp.types);\n    }\n\n    if (exp.require && !(await pathExists(resolve(ctx.cwd, exp.require)))) {\n      missingExports.push(exp.require);\n    }\n\n    if (exp.import && !(await pathExists(resolve(ctx.cwd, exp.import)))) {\n      missingExports.push(exp.import);\n    }\n\n    if (exp.module && !(await pathExists(resolve(ctx.cwd, exp.module)))) {\n      missingExports.push(exp.module);\n    }\n\n    if (exp.default && !(await pathExists(resolve(ctx.cwd, exp.default)))) {\n      missingExports.push(exp.default);\n    }\n\n    if (exp.browser) {\n      if (exp.browser.source && !(await pathExists(resolve(ctx.cwd, exp.browser.source)))) {\n        missingExports.push(exp.browser.source);\n      }\n\n      if (exp.browser.import && !(await pathExists(resolve(ctx.cwd, exp.browser.import)))) {\n        missingExports.push(exp.browser.import);\n      }\n\n      if (exp.browser.require && !(await pathExists(resolve(ctx.cwd, exp.browser.require)))) {\n        missingExports.push(exp.browser.require);\n      }\n    }\n\n    if (exp.node) {\n      if (exp.node.source && !(await pathExists(resolve(ctx.cwd, exp.node.source)))) {\n        missingExports.push(exp.node.source);\n      }\n\n      if (exp.node.import && !(await pathExists(resolve(ctx.cwd, exp.node.import)))) {\n        missingExports.push(exp.node.import);\n      }\n\n      if (exp.node.require && !(await pathExists(resolve(ctx.cwd, exp.node.require)))) {\n        missingExports.push(exp.node.require);\n      }\n\n      if (exp.node.module && !(await pathExists(resolve(ctx.cwd, exp.node.module)))) {\n        missingExports.push(exp.node.module);\n      }\n    }\n  }\n\n  if (missingExports.length) {\n    checkingFilePathsLoader.fail('');\n    logger.error(\n      [\n        'Missing files for exports:',\n        ...missingExports.map((str) => `    ${chalk.blue(str)} -> ${resolve(ctx.cwd, str)}`),\n      ].join(os.EOL)\n    );\n    process.exit(1);\n  }\n\n  checkingFilePathsLoader.succeed('');\n\n  /**\n   * Now we know the files exist, we want to double check that they can be accurately resolved.\n   */\n  const exportPaths = Object.values(ctx.exports).reduce<{ require: string[]; import: string[] }>(\n    (acc, exp) => {\n      if (exp.require) {\n        acc.require.push(exp.require);\n      }\n      if (exp.import) {\n        acc.import.push(exp.import);\n      }\n\n      return acc;\n    },\n    {\n      require: [],\n      import: [],\n    }\n  );\n\n  if (exportPaths.import.length > 0) {\n    await resolveExports(exportPaths.import, {\n      cwd: ctx.cwd,\n      external: ctx.external,\n      format: 'esm',\n      logger,\n    });\n  }\n  if (exportPaths.require.length > 0) {\n    await resolveExports(exportPaths.require, {\n      cwd: ctx.cwd,\n      external: ctx.external,\n      format: 'cjs',\n      logger,\n    });\n  }\n};\n\ninterface ResolveExportsOptions {\n  cwd: string;\n  external: string[];\n  format: Format;\n  logger: Logger;\n}\n\nconst resolveExports = async (\n  paths: string[],\n  { cwd, format, external, logger }: ResolveExportsOptions\n) => {\n  const esbuildLoader = ora(`Resolving ${format} exports`).start();\n\n  const code = paths\n    .map((id) => (format === 'esm' ? `import('${id}');` : `require('${id}');`))\n    .join(os.EOL);\n\n  try {\n    const esbuildResult = await esbuild.build({\n      bundle: true,\n      external,\n      format,\n      logLevel: 'silent',\n      // otherwise output maps to stdout as we're using stdin\n      outfile: '/dev/null',\n      platform: 'node',\n      stdin: {\n        contents: code,\n        loader: 'js',\n        resolveDir: cwd,\n      },\n    });\n\n    if (esbuildResult.errors.length > 0) {\n      for (const msg of esbuildResult.errors) {\n        printESBuildMessage(msg, logger.error);\n      }\n\n      esbuildLoader.fail();\n      process.exit(1);\n    }\n\n    const esbuildWarnings = esbuildResult.warnings.filter(\n      (msg) => !(msg.detail || msg.text).includes(\"does not affect esbuild's own target setting\")\n    );\n\n    for (const msg of esbuildWarnings) {\n      printESBuildMessage(msg, logger.warn);\n    }\n\n    esbuildLoader.succeed();\n  } catch (err) {\n    if (isESBuildError(err)) {\n      for (const msg of err.errors) {\n        printESBuildMessage(msg, logger.error);\n      }\n    }\n\n    esbuildLoader.fail();\n    process.exit(1);\n  }\n};\n\nconst isESBuildError = (err: unknown): err is BuildFailure => {\n  return isError(err) && 'errors' in err && 'warnings' in err;\n};\n\nconst printESBuildMessage = (msg: Message, log: Logger['error']) => {\n  if (msg.location) {\n    log(\n      [\n        `${msg.detail || msg.text}`,\n        `${msg.location.line} | ${msg.location.lineText}`,\n        `in ./${msg.location.file}:${msg.location.line}:${msg.location.column}`,\n      ].join(os.EOL)\n    );\n  } else {\n    log(msg.detail || msg.text);\n  }\n};\n","import { check as nodeCheck } from '../../node/check';\nimport { handleError } from '../errors';\n\nimport type { CheckOptions } from '../../node/check';\n\nexport const check = async (options: CheckOptions) => {\n  try {\n    await nodeCheck(options);\n  } catch (err) {\n    handleError(err);\n  }\n};\n"],"names":["check","createLogger","ora","os","loadPkg","validatePkg","validateExportsOrdering","loadConfig","getExportExtensionMap","createBuildContext","pathExists","resolve","chalk","esbuild","isError","nodeCheck","handleError"],"mappings":"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"}