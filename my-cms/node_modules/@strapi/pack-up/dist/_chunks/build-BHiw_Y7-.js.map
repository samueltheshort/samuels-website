{"version":3,"file":"build-BHiw_Y7-.js","sources":["../../src/node/build.ts","../../src/cli/commands/build.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport ora from 'ora';\nimport os from 'os';\n\nimport { loadConfig, type Config } from './core/config';\nimport { isError } from './core/errors';\nimport { getExportExtensionMap, validateExportsOrdering } from './core/exports';\nimport { createLogger } from './core/logger';\nimport { loadPkg, validatePkg } from './core/pkg';\nimport { createBuildContext } from './createBuildContext';\nimport { createBuildTasks } from './createTasks';\nimport { taskHandlers } from './tasks';\n\nimport type { BuildTask } from './createTasks';\nimport type { TaskHandler } from './tasks';\nimport type { CommonCLIOptions } from '../types';\n\ninterface BuildCLIOptions extends CommonCLIOptions {\n  minify?: boolean;\n  sourcemap?: boolean;\n}\n\ninterface BuildWithConfigFile extends BuildCLIOptions {\n  configFile?: true;\n  config?: never;\n  cwd?: string;\n}\n\ninterface BuildWithoutConfigFile extends BuildCLIOptions {\n  configFile: false;\n  config?: Config;\n  cwd?: string;\n}\n\ntype BuildOptions = BuildWithConfigFile | BuildWithoutConfigFile;\n\nconst build = async (opts: BuildOptions = {}) => {\n  /**\n   * We always want to run in production mode when building and some packages\n   * use NODE_ENV to determine which type of package to import (looking at your react).\n   * Therefore for building, unless it's specifically set by the user, we'll set it to production.\n   */\n  process.env.NODE_ENV = process.env.NODE_ENV || 'production';\n\n  const {\n    silent,\n    debug,\n    cwd = process.cwd(),\n    configFile = true,\n    config: providedConfig,\n    ...configOptions\n  } = opts;\n\n  const logger = createLogger({ silent, debug });\n\n  /**\n   * Load the closest package.json and then verify the structure against what we expect.\n   */\n  const packageJsonLoader = ora(`Verifying package.json ${os.EOL}`).start();\n\n  const rawPkg = await loadPkg({ cwd, logger }).catch((err) => {\n    packageJsonLoader.fail();\n\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n\n    logger.debug(`Path checked – ${cwd}`);\n    process.exit(1);\n  });\n\n  const validatedPkg = await validatePkg({\n    pkg: rawPkg,\n  }).catch((err) => {\n    packageJsonLoader.fail();\n\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n\n    process.exit(1);\n  });\n\n  /**\n   * Validate the exports of the package incl. the order of the\n   * exports within the exports map if applicable\n   */\n  const packageJson = await validateExportsOrdering({ pkg: validatedPkg, logger }).catch((err) => {\n    packageJsonLoader.fail();\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n    process.exit(1);\n  });\n\n  packageJsonLoader.succeed('Verified package.json');\n\n  /**\n   * If configFile is true – which is the default, atempt to load the config\n   * otherwise if it's explicitly false then we suspect there might be a config passed\n   * in the options, so we'll use that instead.\n   */\n  const config = configFile ? await loadConfig({ cwd, logger }) : providedConfig;\n\n  /**\n   * We create tasks based on the exports of the package.json\n   * their handlers are then ran in the order of the exports map\n   * and results are logged to see gradual progress.\n   */\n  const buildContextLoader = ora(`Creating build context ${os.EOL}`).start();\n\n  const extMap = getExportExtensionMap();\n\n  const ctx = await createBuildContext({\n    config: { ...config, ...configOptions },\n    cwd,\n    extMap,\n    logger,\n    pkg: packageJson,\n  }).catch((err) => {\n    buildContextLoader.fail();\n    if (isError(err)) {\n      logger.error(err.message);\n    }\n    process.exit(1);\n  });\n\n  logger.debug(`Build context: ${os.EOL}`, ctx);\n\n  const buildTasks = await createBuildTasks(ctx);\n\n  buildContextLoader.succeed('Created build context');\n\n  /**\n   * If the distPath already exists, clean it\n   */\n  try {\n    logger.debug(`Cleaning dist folder: ${ctx.distPath}`);\n    await fs.rm(ctx.distPath, { recursive: true, force: true });\n    logger.debug('Cleaned dist folder');\n  } catch {\n    // do nothing, it will fail if the folder does not exist\n    logger.debug('There was no dist folder to clean');\n  }\n\n  for (const task of buildTasks) {\n    const handler = taskHandlers[task.type] as TaskHandler<BuildTask>;\n\n    handler.print(ctx, task);\n\n    try {\n      const result = await handler.run$(ctx, task).toPromise();\n\n      handler.success(ctx, task, result);\n    } catch (err) {\n      handler.fail(ctx, task, err);\n      // exit as soon as one task fails\n      throw err;\n    }\n  }\n};\n\nexport { build };\nexport type { BuildOptions, BuildCLIOptions, BuildWithConfigFile, BuildWithoutConfigFile };\n","import { build as nodeBuild } from '../../node/build';\nimport { handleError } from '../errors';\n\nimport type { BuildCLIOptions } from '../../node/build';\n\nexport const build = async (options: BuildCLIOptions) => {\n  try {\n    await nodeBuild(options);\n  } catch (err) {\n    handleError(err);\n  }\n};\n"],"names":["build","createLogger","ora","os","loadPkg","isError","validatePkg","validateExportsOrdering","loadConfig","getExportExtensionMap","createBuildContext","createBuildTasks","fs","taskHandlers","nodeBuild","handleError"],"mappings":"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"}