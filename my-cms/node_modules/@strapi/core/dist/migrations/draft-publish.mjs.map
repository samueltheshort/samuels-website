{"version":3,"file":"draft-publish.mjs","sources":["../../src/migrations/draft-publish.ts"],"sourcesContent":["import { contentTypes as contentTypesUtils, async } from '@strapi/utils';\nimport { Schema } from '@strapi/types';\n\nimport { getBatchToDiscard } from './database/5.0.0-discard-drafts';\n\nexport interface Input {\n  oldContentTypes: Record<string, Schema.ContentType>;\n  contentTypes: Record<string, Schema.ContentType>;\n}\n\n/**\n * Enable draft and publish for content types.\n *\n * Draft and publish disabled content types will have their entries published,\n * this migration clones those entries as drafts.\n *\n * TODO: Clone components, dynamic zones and relations\n */\nconst enableDraftAndPublish = async ({ oldContentTypes, contentTypes }: Input) => {\n  if (!oldContentTypes) {\n    return;\n  }\n\n  // run the after content types migrations\n  return strapi.db.transaction(async (trx) => {\n    for (const uid in contentTypes) {\n      if (!oldContentTypes[uid]) {\n        continue;\n      }\n\n      const oldContentType = oldContentTypes[uid];\n      const contentType = contentTypes[uid];\n\n      // if d&p was enabled set publishedAt to eq createdAt\n      if (\n        !contentTypesUtils.hasDraftAndPublish(oldContentType) &&\n        contentTypesUtils.hasDraftAndPublish(contentType)\n      ) {\n        const discardDraft = async (entry: { documentId: string; locale: string }) =>\n          strapi\n            .documents(uid as any)\n            // Discard draft by referencing the documentId and locale\n            .discardDraft({ documentId: entry.documentId, locale: entry.locale });\n\n        /**\n         * Load a batch of entries (batched to prevent loading millions of rows at once ),\n         * and discard them using the document service.\n         */\n        for await (const batch of getBatchToDiscard({ db: strapi.db, trx, uid })) {\n          await async.map(batch, discardDraft, { concurrency: 10 });\n        }\n      }\n    }\n  });\n};\n\nconst disableDraftAndPublish = async ({ oldContentTypes, contentTypes }: Input) => {\n  if (!oldContentTypes) {\n    return;\n  }\n\n  for (const uid in contentTypes) {\n    if (!oldContentTypes[uid]) {\n      continue;\n    }\n\n    const oldContentType = oldContentTypes[uid];\n    const contentType = contentTypes[uid];\n\n    // if d&p was disabled remove unpublish content before sync\n    if (\n      contentTypesUtils.hasDraftAndPublish(oldContentType) &&\n      !contentTypesUtils.hasDraftAndPublish(contentType)\n    ) {\n      await strapi.db?.queryBuilder(uid).delete().where({ published_at: null }).execute();\n    }\n  }\n};\n\nexport { enableDraftAndPublish as enable, disableDraftAndPublish as disable };\n"],"names":["contentTypes","contentTypesUtils"],"mappings":";;AAkBA,MAAM,wBAAwB,OAAO,EAAE,iBAAiBA,cAAAA,qBAA0B;AAChF,MAAI,CAAC,iBAAiB;AACpB;AAAA,EAAA;AAIF,SAAO,OAAO,GAAG,YAAY,OAAO,QAAQ;AAC1C,eAAW,OAAOA,gBAAc;AAC1B,UAAA,CAAC,gBAAgB,GAAG,GAAG;AACzB;AAAA,MAAA;AAGI,YAAA,iBAAiB,gBAAgB,GAAG;AACpC,YAAA,cAAcA,eAAa,GAAG;AAIlC,UAAA,CAACC,aAAkB,mBAAmB,cAAc,KACpDA,aAAkB,mBAAmB,WAAW,GAChD;AACA,cAAM,eAAe,OAAO,UAC1B,OACG,UAAU,GAAU,EAEpB,aAAa,EAAE,YAAY,MAAM,YAAY,QAAQ,MAAM,QAAQ;AAMvD,yBAAA,SAAS,kBAAkB,EAAE,IAAI,OAAO,IAAI,KAAK,IAAI,CAAC,GAAG;AACxE,gBAAM,MAAM,IAAI,OAAO,cAAc,EAAE,aAAa,IAAI;AAAA,QAAA;AAAA,MAC1D;AAAA,IACF;AAAA,EACF,CACD;AACH;AAEA,MAAM,yBAAyB,OAAO,EAAE,iBAAiBD,cAAAA,qBAA0B;AACjF,MAAI,CAAC,iBAAiB;AACpB;AAAA,EAAA;AAGF,aAAW,OAAOA,gBAAc;AAC1B,QAAA,CAAC,gBAAgB,GAAG,GAAG;AACzB;AAAA,IAAA;AAGI,UAAA,iBAAiB,gBAAgB,GAAG;AACpC,UAAA,cAAcA,eAAa,GAAG;AAIlC,QAAAC,aAAkB,mBAAmB,cAAc,KACnD,CAACA,aAAkB,mBAAmB,WAAW,GACjD;AACA,YAAM,OAAO,IAAI,aAAa,GAAG,EAAE,SAAS,MAAM,EAAE,cAAc,KAAM,CAAA,EAAE,QAAQ;AAAA,IAAA;AAAA,EACpF;AAEJ;"}