{"version":3,"file":"components.mjs","sources":["../../../src/services/document-service/components.ts"],"sourcesContent":["import _ from 'lodash';\nimport { has, omit, pipe, assign, curry } from 'lodash/fp';\nimport type { Utils, UID, Schema, Data, Modules } from '@strapi/types';\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\n\n// type aliases for readability\ntype Input<T extends UID.Schema> = Modules.Documents.Params.Data.Input<T>;\n\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\n  TUID,\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\n>;\n\ntype SingleComponentValue = Schema.Attribute.ComponentValue<UID.Component, false>;\ntype RepeatableComponentValue = Schema.Attribute.ComponentValue<UID.Component, true>;\n\ntype ComponentValue = SingleComponentValue | RepeatableComponentValue;\n\ntype DynamicZoneValue = Schema.Attribute.DynamicZoneValue<UID.Component[]>;\n\ntype ComponentBody = {\n  [key: string]: ComponentValue | DynamicZoneValue;\n};\n\nconst omitComponentData = curry(\n  (schema: Schema.Schema, data: Input<UID.Schema>): Partial<Input<UID.Schema>> => {\n    const { attributes } = schema;\n    const componentAttributes = Object.keys(attributes).filter((attributeName) =>\n      contentTypesUtils.isComponentAttribute(attributes[attributeName])\n    );\n\n    return omit(componentAttributes, data);\n  }\n);\n\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\nconst createComponents = async <TUID extends UID.Schema, TData extends Input<TUID>>(\n  uid: TUID,\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData];\n\n      if (componentValue === null) {\n        continue;\n      }\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\n          createComponent(componentUID, value)\n        );\n\n        componentBody[attributeName] = components.map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await createComponent(\n          componentUID,\n          componentValue as Input<UID.Component>\n        );\n\n        componentBody[attributeName] = {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      const createDynamicZoneComponents = async (\n        value: Utils.Array.Values<typeof dynamiczoneValues>\n      ) => {\n        const { id } = await createComponent(value.__component, value);\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      };\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        createDynamicZoneComponents\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst getComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\n): Promise<LoadedComponents<TUID>> => {\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\n\n  if (_.isEmpty(componentAttributes)) {\n    return {} as LoadedComponents<TUID>;\n  }\n\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\n};\n\n/*\n  delete old components\n  create or update\n*/\nconst updateComponents = async <TUID extends UID.Schema, TData extends Partial<Input<TUID>>>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData] as ComponentValue;\n\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\n          updateOrCreateComponent(componentUID, value)\n        );\n\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await updateOrCreateComponent(componentUID, componentValue);\n        componentBody[attributeName] = component && {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n    } else if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[attributeName as keyof TData] as DynamicZoneValue;\n\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(dynamiczoneValues, async (value: any) => {\n        const { id } = await updateOrCreateComponent(value.__component, value);\n\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      });\n    }\n  }\n\n  return componentBody;\n};\n\nconst pickStringifiedId = ({\n  id,\n}: {\n  id: Modules.EntityService.Params.Attribute.ID;\n}): Modules.EntityService.Params.Attribute.ID & string => {\n  if (typeof id === 'string') {\n    return id;\n  }\n\n  return `${id}`;\n};\n\nconst deleteOldComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  componentUID: UID.Component,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  componentValue: ComponentValue\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as ComponentValue;\n\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\n\n  idsToKeep.forEach((id) => {\n    if (!allIds.includes(id)) {\n      throw new errors.ApplicationError(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n    }\n  });\n\n  const idsToDelete = _.difference(allIds, idsToKeep);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      await deleteComponent(componentUID, { id: idToDelete });\n    }\n  }\n};\n\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  dynamiczoneValues: DynamicZoneValue\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as DynamicZoneValue;\n\n  const idsToKeep = _.castArray(dynamiczoneValues)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  const allIds = _.castArray(previousValue)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  idsToKeep.forEach(({ id, __component }) => {\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\n      const err = new Error(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n\n      Object.assign(err, { status: 400 });\n      throw err;\n    }\n  });\n\n  type IdsToDelete = DynamicZoneValue;\n\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\n      acc.push({ id, __component });\n    }\n\n    return acc;\n  }, [] as IdsToDelete);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      const { id, __component } = idToDelete;\n      await deleteComponent(__component, { id });\n    }\n  }\n};\n\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\n  uid: TUID,\n  entityToDelete: TEntity,\n  { loadComponents = true } = {}\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n      let value;\n\n      if (loadComponents) {\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\n      } else {\n        value = entityToDelete[attributeName as keyof TEntity];\n      }\n\n      if (!value) {\n        continue;\n      }\n\n      if (attribute.type === 'component') {\n        const { component: componentUID } = attribute;\n        await async.map(_.castArray(value), (subValue: any) =>\n          deleteComponent(componentUID, subValue)\n        );\n      } else {\n        await async.map(_.castArray(value), (subValue: any) =>\n          deleteComponent(subValue.__component, subValue)\n        );\n      }\n\n      continue;\n    }\n  }\n};\n\n/** *************************\n    Component queries\n************************** */\n\n// components can have nested compos so this must be recursive\nconst createComponent = async <TUID extends UID.Component>(uid: TUID, data: Input<TUID>) => {\n  const schema = strapi.getModel(uid);\n\n  const componentData = await createComponents(uid, data);\n\n  const transform = pipe(\n    // Make sure we don't save the component with a pre-defined ID\n    omit('id'),\n    assignComponentData(schema, componentData)\n  );\n\n  return strapi.db.query(uid).create({ data: transform(data) });\n};\n\n// components can have nested compos so this must be recursive\nconst updateComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: Input<TUID>\n) => {\n  const schema = strapi.getModel(uid);\n\n  const componentData = await updateComponents(uid, componentToUpdate, data);\n\n  return strapi.db.query(uid).update({\n    where: {\n      id: componentToUpdate.id,\n    },\n    data: assignComponentData(schema, componentData, data),\n  });\n};\n\nconst updateOrCreateComponent = <TUID extends UID.Component>(\n  componentUID: TUID,\n  value: Input<TUID>\n) => {\n  if (value === null) {\n    return null;\n  }\n\n  // update\n  if ('id' in value && typeof value.id !== 'undefined') {\n    // TODO: verify the compo is associated with the entity\n    return updateComponent(componentUID, { id: value.id }, value);\n  }\n\n  // create\n  return createComponent(componentUID, value);\n};\n\nconst deleteComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToDelete: Data.Component<TUID>\n) => {\n  await deleteComponents(uid, componentToDelete);\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\n};\n\nconst assignComponentData = curry(\n  (schema: Schema.Schema, componentData: ComponentBody, data: Input<UID.Schema>) => {\n    return pipe(omitComponentData(schema), assign(componentData))(data);\n  }\n);\n\nexport {\n  omitComponentData,\n  assignComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  deleteComponent,\n};\n"],"names":["contentTypesUtils"],"mappings":"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"}