{"version":3,"file":"id-map.js","sources":["../../../../src/services/document-service/transform/id-map.ts"],"sourcesContent":["import { Core, Data, UID } from '@strapi/types';\nimport { async, contentTypes } from '@strapi/utils';\n\nconst hasDraftAndPublish = (uid: UID.CollectionType) => {\n  const model = strapi.getModel(uid);\n  return contentTypes.hasDraftAndPublish(model);\n};\n\n/**\n * TODO: Find a better way to encode keys than this\n * This converts an object into a string by joining its keys and values,\n * so it can be used as a key in a Map.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * const key = encodeKey(obj);\n *      ^ \"a:::1&&b:::2\"\n */\nconst encodeKey = (obj: any) => {\n  // Ignore status field for models without draft and publish\n  if (!hasDraftAndPublish(obj.uid)) {\n    delete obj.status;\n  }\n\n  // Sort keys to always keep the same order when encoding\n  const keys = Object.keys(obj).sort();\n  return keys.map((key) => `${key}:::${obj[key]}`).join('&&');\n};\n\ninterface KeyFields {\n  uid: string;\n  documentId: Data.ID;\n  locale?: string | null;\n  status?: 'draft' | 'published';\n}\n\nexport interface IdMap {\n  loadedIds: Map<string, string>;\n  toLoadIds: Map<string, KeyFields>;\n  // Make the Keys type to be the params of add\n  add(keys: KeyFields): void;\n  load(): Promise<void>;\n  get(keys: KeyFields): string | undefined;\n  clear(): void;\n}\n\n/**\n * Holds a registry of document ids and their corresponding entity ids.\n */\nconst createIdMap = ({ strapi }: { strapi: Core.Strapi }): IdMap => {\n  const loadedIds = new Map();\n  const toLoadIds = new Map();\n\n  return {\n    loadedIds,\n    toLoadIds,\n    /**\n     * Register a new document id and its corresponding entity id.\n     */\n    add(keyFields: KeyFields) {\n      const key = encodeKey({ status: 'published', locale: null, ...keyFields });\n\n      // If the id is already loaded, do nothing\n      if (loadedIds.has(key)) return;\n      // If the id is already in the toLoadIds, do nothing\n      if (toLoadIds.has(key)) return;\n\n      // Add the id to the toLoadIds\n      toLoadIds.set(key, keyFields);\n    },\n\n    /**\n     * Load all ids from the registry.\n     */\n    async load() {\n      // Document Id to Entry Id queries are batched by its uid and locale\n      // TODO: Add publication state too\n      const loadIdValues = Array.from(toLoadIds.values());\n\n      // 1. Group ids to query together\n      const idsByUidAndLocale = loadIdValues.reduce((acc, { documentId, ...rest }) => {\n        const key = encodeKey(rest);\n        const ids = acc[key] || { ...rest, documentIds: [] };\n        ids.documentIds.push(documentId);\n        return { ...acc, [key]: ids };\n      }, {});\n\n      // 2. Query ids\n      await async.map(\n        Object.values(idsByUidAndLocale),\n        async ({ uid, locale, documentIds, status }: any) => {\n          const findParams = {\n            select: ['id', 'documentId', 'locale', 'publishedAt'],\n            where: {\n              documentId: { $in: documentIds },\n              locale: locale || null,\n            },\n          } as any;\n\n          if (hasDraftAndPublish(uid)) {\n            findParams.where.publishedAt = status === 'draft' ? null : { $ne: null };\n          }\n\n          const result = await strapi?.db?.query(uid).findMany(findParams);\n\n          // 3. Store result in loadedIds\n          result?.forEach(({ documentId, id, locale, publishedAt }: any) => {\n            const key = encodeKey({\n              documentId,\n              uid,\n              locale,\n              status: publishedAt ? 'published' : 'draft',\n            });\n            loadedIds.set(key, id);\n          });\n        }\n      );\n\n      // 4. Clear toLoadIds\n      toLoadIds.clear();\n    },\n\n    /**\n     * Get the entity id for a given document id.\n     */\n    get(keys: KeyFields) {\n      const key = encodeKey({ status: 'published', locale: null, ...keys });\n      return loadedIds.get(key);\n    },\n\n    /**\n     * Clear the registry.\n     */\n    clear() {\n      loadedIds.clear();\n      toLoadIds.clear();\n    },\n  };\n};\n\nexport { createIdMap };\n"],"names":["contentTypes","strapi","async","locale"],"mappings":";;;AAGA,MAAM,qBAAqB,CAAC,QAA4B;AAChD,QAAA,QAAQ,OAAO,SAAS,GAAG;AAC1B,SAAAA,YAAA,aAAa,mBAAmB,KAAK;AAC9C;AAYA,MAAM,YAAY,CAAC,QAAa;AAE9B,MAAI,CAAC,mBAAmB,IAAI,GAAG,GAAG;AAChC,WAAO,IAAI;AAAA,EAAA;AAIb,QAAM,OAAO,OAAO,KAAK,GAAG,EAAE,KAAK;AACnC,SAAO,KAAK,IAAI,CAAC,QAAQ,GAAG,GAAG,MAAM,IAAI,GAAG,CAAC,EAAE,EAAE,KAAK,IAAI;AAC5D;AAsBA,MAAM,cAAc,CAAC,EAAE,QAAAC,cAA6C;AAC5D,QAAA,gCAAgB,IAAI;AACpB,QAAA,gCAAgB,IAAI;AAEnB,SAAA;AAAA,IACL;AAAA,IACA;AAAA;AAAA;AAAA;AAAA,IAIA,IAAI,WAAsB;AAClB,YAAA,MAAM,UAAU,EAAE,QAAQ,aAAa,QAAQ,MAAM,GAAG,WAAW;AAGrE,UAAA,UAAU,IAAI,GAAG,EAAG;AAEpB,UAAA,UAAU,IAAI,GAAG,EAAG;AAGd,gBAAA,IAAI,KAAK,SAAS;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,OAAO;AAGX,YAAM,eAAe,MAAM,KAAK,UAAU,QAAQ;AAG5C,YAAA,oBAAoB,aAAa,OAAO,CAAC,KAAK,EAAE,YAAY,GAAG,WAAW;AACxE,cAAA,MAAM,UAAU,IAAI;AACpB,cAAA,MAAM,IAAI,GAAG,KAAK,EAAE,GAAG,MAAM,aAAa,GAAG;AAC/C,YAAA,YAAY,KAAK,UAAU;AAC/B,eAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,IAAI;AAAA,MAC9B,GAAG,EAAE;AAGL,YAAMC,YAAM,MAAA;AAAA,QACV,OAAO,OAAO,iBAAiB;AAAA,QAC/B,OAAO,EAAE,KAAK,QAAQ,aAAa,aAAkB;AACnD,gBAAM,aAAa;AAAA,YACjB,QAAQ,CAAC,MAAM,cAAc,UAAU,aAAa;AAAA,YACpD,OAAO;AAAA,cACL,YAAY,EAAE,KAAK,YAAY;AAAA,cAC/B,QAAQ,UAAU;AAAA,YAAA;AAAA,UAEtB;AAEI,cAAA,mBAAmB,GAAG,GAAG;AAC3B,uBAAW,MAAM,cAAc,WAAW,UAAU,OAAO,EAAE,KAAK,KAAK;AAAA,UAAA;AAGnE,gBAAA,SAAS,MAAMD,SAAQ,IAAI,MAAM,GAAG,EAAE,SAAS,UAAU;AAGvD,kBAAA,QAAQ,CAAC,EAAE,YAAY,IAAI,QAAAE,SAAQ,kBAAuB;AAChE,kBAAM,MAAM,UAAU;AAAA,cACpB;AAAA,cACA;AAAA,cACA,QAAAA;AAAAA,cACA,QAAQ,cAAc,cAAc;AAAA,YAAA,CACrC;AACS,sBAAA,IAAI,KAAK,EAAE;AAAA,UAAA,CACtB;AAAA,QAAA;AAAA,MAEL;AAGA,gBAAU,MAAM;AAAA,IAClB;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,MAAiB;AACb,YAAA,MAAM,UAAU,EAAE,QAAQ,aAAa,QAAQ,MAAM,GAAG,MAAM;AAC7D,aAAA,UAAU,IAAI,GAAG;AAAA,IAC1B;AAAA;AAAA;AAAA;AAAA,IAKA,QAAQ;AACN,gBAAU,MAAM;AAChB,gBAAU,MAAM;AAAA,IAAA;AAAA,EAEpB;AACF;;"}