{"version":3,"file":"unidirectional-relations.js","sources":["../../../../src/services/document-service/utils/unidirectional-relations.ts"],"sourcesContent":["/* eslint-disable no-continue */\nimport { keyBy, omit } from 'lodash/fp';\n\nimport { UID, Schema } from '@strapi/types';\n\ninterface LoadContext {\n  oldVersions: { id: string; locale: string }[];\n  newVersions: { id: string; locale: string }[];\n}\n\n/**\n * Loads lingering relations that need to be updated when overriding a published or draft entry.\n * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.\n * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.\n */\nconst load = async (uid: UID.ContentType, { oldVersions, newVersions }: LoadContext) => {\n  const updates = [] as any;\n\n  // Iterate all components and content types to find relations that need to be updated\n  await strapi.db.transaction(async ({ trx }) => {\n    const contentTypes = Object.values(strapi.contentTypes) as Schema.ContentType[];\n    const components = Object.values(strapi.components) as Schema.Component[];\n\n    for (const model of [...contentTypes, ...components]) {\n      const dbModel = strapi.db.metadata.get(model.uid);\n\n      for (const attribute of Object.values(dbModel.attributes) as any) {\n        /**\n         * Only consider unidirectional relations\n         */\n        if (\n          attribute.type !== 'relation' ||\n          attribute.target !== uid ||\n          attribute.inversedBy ||\n          attribute.mappedBy\n        ) {\n          continue;\n        }\n\n        // TODO: joinColumn relations\n        const joinTable = attribute.joinTable;\n        if (!joinTable) {\n          continue;\n        }\n\n        const { name: sourceColumnName } = joinTable.joinColumn;\n        const { name: targetColumnName } = joinTable.inverseJoinColumn;\n\n        /**\n         * Load all relations that need to be updated\n         */\n        // NOTE: when the model has draft and publish, we can assume relation are only draft to draft & published to published\n        const ids = oldVersions.map((entry) => entry.id);\n\n        const oldVersionsRelations = await strapi.db\n          .getConnection()\n          .select('*')\n          .from(joinTable.name)\n          .whereIn(targetColumnName, ids)\n          .transacting(trx);\n\n        if (oldVersionsRelations.length > 0) {\n          updates.push({ joinTable, relations: oldVersionsRelations });\n        }\n\n        /**\n         * if publishing\n         *  if published version exists\n         *    updated published versions links\n         *  else\n         *    create link to newly published version\n         *\n         * if discarding\n         *    if published version link exists & not draft version link\n         *       create link to new draft version\n         */\n\n        if (!model.options?.draftAndPublish) {\n          const ids = newVersions.map((entry) => entry.id);\n\n          const newVersionsRelations = await strapi.db\n            .getConnection()\n            .select('*')\n            .from(joinTable.name)\n            .whereIn(targetColumnName, ids)\n            .transacting(trx);\n\n          if (newVersionsRelations.length > 0) {\n            // when publishing a draft that doesn't have a published version yet,\n            // copy the links to the draft over to the published version\n            // when discarding a published version, if no drafts exists\n            const discardToAdd = newVersionsRelations\n              .filter((relation) => {\n                const matchingOldVerion = oldVersionsRelations.find((oldRelation) => {\n                  return oldRelation[sourceColumnName] === relation[sourceColumnName];\n                });\n\n                return !matchingOldVerion;\n              })\n              .map(omit('id'));\n\n            updates.push({ joinTable, relations: discardToAdd });\n          }\n        }\n      }\n    }\n  });\n\n  return updates;\n};\n\n/**\n * Updates uni directional relations to target the right entries when overriding published or draft entries.\n *\n * @param oldEntries The old entries that are being overridden\n * @param newEntries The new entries that are overriding the old ones\n * @param oldRelations The relations that were previously loaded with `load` @see load\n */\nconst sync = async (\n  oldEntries: { id: string; locale: string }[],\n  newEntries: { id: string; locale: string }[],\n  oldRelations: { joinTable: any; relations: any[] }[]\n) => {\n  /**\n   * Create a map of old entry ids to new entry ids\n   *\n   * Will be used to update the relation target ids\n   */\n  const newEntryByLocale = keyBy('locale', newEntries);\n  const oldEntriesMap = oldEntries.reduce(\n    (acc, entry) => {\n      const newEntry = newEntryByLocale[entry.locale];\n      if (!newEntry) return acc;\n      acc[entry.id] = newEntry.id;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  await strapi.db.transaction(async ({ trx }) => {\n    // Iterate old relations that are deleted and insert the new ones\n    for (const { joinTable, relations } of oldRelations) {\n      // Update old ids with the new ones\n      const column = joinTable.inverseJoinColumn.name;\n\n      const newRelations = relations.map((relation) => {\n        const newId = oldEntriesMap[relation[column]];\n        return { ...relation, [column]: newId };\n      });\n\n      // Insert those relations into the join table\n      await trx.batchInsert(joinTable.name, newRelations, 1000);\n    }\n  });\n};\n\nexport { load, sync };\n"],"names":["ids","omit","keyBy"],"mappings":";;;AAeA,MAAM,OAAO,OAAO,KAAsB,EAAE,aAAa,kBAA+B;AACtF,QAAM,UAAU,CAAC;AAGjB,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AAC7C,UAAM,eAAe,OAAO,OAAO,OAAO,YAAY;AACtD,UAAM,aAAa,OAAO,OAAO,OAAO,UAAU;AAElD,eAAW,SAAS,CAAC,GAAG,cAAc,GAAG,UAAU,GAAG;AACpD,YAAM,UAAU,OAAO,GAAG,SAAS,IAAI,MAAM,GAAG;AAEhD,iBAAW,aAAa,OAAO,OAAO,QAAQ,UAAU,GAAU;AAK9D,YAAA,UAAU,SAAS,cACnB,UAAU,WAAW,OACrB,UAAU,cACV,UAAU,UACV;AACA;AAAA,QAAA;AAIF,cAAM,YAAY,UAAU;AAC5B,YAAI,CAAC,WAAW;AACd;AAAA,QAAA;AAGF,cAAM,EAAE,MAAM,iBAAiB,IAAI,UAAU;AAC7C,cAAM,EAAE,MAAM,iBAAiB,IAAI,UAAU;AAM7C,cAAM,MAAM,YAAY,IAAI,CAAC,UAAU,MAAM,EAAE;AAE/C,cAAM,uBAAuB,MAAM,OAAO,GACvC,cAAc,EACd,OAAO,GAAG,EACV,KAAK,UAAU,IAAI,EACnB,QAAQ,kBAAkB,GAAG,EAC7B,YAAY,GAAG;AAEd,YAAA,qBAAqB,SAAS,GAAG;AACnC,kBAAQ,KAAK,EAAE,WAAW,WAAW,sBAAsB;AAAA,QAAA;AAezD,YAAA,CAAC,MAAM,SAAS,iBAAiB;AACnC,gBAAMA,OAAM,YAAY,IAAI,CAAC,UAAU,MAAM,EAAE;AAE/C,gBAAM,uBAAuB,MAAM,OAAO,GACvC,cAAc,EACd,OAAO,GAAG,EACV,KAAK,UAAU,IAAI,EACnB,QAAQ,kBAAkBA,IAAG,EAC7B,YAAY,GAAG;AAEd,cAAA,qBAAqB,SAAS,GAAG;AAInC,kBAAM,eAAe,qBAClB,OAAO,CAAC,aAAa;AACpB,oBAAM,oBAAoB,qBAAqB,KAAK,CAAC,gBAAgB;AACnE,uBAAO,YAAY,gBAAgB,MAAM,SAAS,gBAAgB;AAAA,cAAA,CACnE;AAED,qBAAO,CAAC;AAAA,YACT,CAAA,EACA,IAAIC,QAAK,IAAI,CAAC;AAEjB,oBAAQ,KAAK,EAAE,WAAW,WAAW,cAAc;AAAA,UAAA;AAAA,QACrD;AAAA,MACF;AAAA,IACF;AAAA,EACF,CACD;AAEM,SAAA;AACT;AASA,MAAM,OAAO,OACX,YACA,YACA,iBACG;AAMG,QAAA,mBAAmBC,GAAAA,MAAM,UAAU,UAAU;AACnD,QAAM,gBAAgB,WAAW;AAAA,IAC/B,CAAC,KAAK,UAAU;AACR,YAAA,WAAW,iBAAiB,MAAM,MAAM;AAC1C,UAAA,CAAC,SAAiB,QAAA;AAClB,UAAA,MAAM,EAAE,IAAI,SAAS;AAClB,aAAA;AAAA,IACT;AAAA,IACA,CAAA;AAAA,EACF;AAEA,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AAE7C,eAAW,EAAE,WAAW,UAAU,KAAK,cAAc;AAE7C,YAAA,SAAS,UAAU,kBAAkB;AAE3C,YAAM,eAAe,UAAU,IAAI,CAAC,aAAa;AAC/C,cAAM,QAAQ,cAAc,SAAS,MAAM,CAAC;AAC5C,eAAO,EAAE,GAAG,UAAU,CAAC,MAAM,GAAG,MAAM;AAAA,MAAA,CACvC;AAGD,YAAM,IAAI,YAAY,UAAU,MAAM,cAAc,GAAI;AAAA,IAAA;AAAA,EAC1D,CACD;AACH;;;"}