{"version":3,"file":"populate.js","sources":["../../../../src/services/document-service/utils/populate.ts"],"sourcesContent":["import { UID } from '@strapi/types';\nimport { contentTypes } from '@strapi/utils';\n\ninterface Options {\n  /**\n   * Fields to select when populating relations\n   */\n  relationalFields?: string[];\n}\n\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;\n\n// We want to build a populate object based on the schema\nexport const getDeepPopulate = (uid: UID.Schema, opts: Options = {}) => {\n  const model = strapi.getModel(uid);\n  const attributes = Object.entries(model.attributes);\n\n  return attributes.reduce((acc: any, [attributeName, attribute]) => {\n    switch (attribute.type) {\n      case 'relation': {\n        // TODO: Support polymorphic relations\n        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n        if (isMorphRelation) {\n          break;\n        }\n\n        // Ignore not visible fields other than createdBy and updatedBy\n        const isVisible = contentTypes.isVisibleAttribute(model, attributeName);\n        const isCreatorField = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(attributeName);\n\n        if (isVisible || isCreatorField) {\n          acc[attributeName] = { select: opts.relationalFields };\n        }\n\n        break;\n      }\n\n      case 'media': {\n        // We populate all media fields for completeness of webhook responses\n        // see https://github.com/strapi/strapi/issues/21546\n        acc[attributeName] = { select: ['*'] };\n        break;\n      }\n\n      case 'component': {\n        const populate = getDeepPopulate(attribute.component, opts);\n        acc[attributeName] = { populate };\n        break;\n      }\n\n      case 'dynamiczone': {\n        // Use fragments to populate the dynamic zone components\n        const populatedComponents = (attribute.components || []).reduce(\n          (acc: any, componentUID: UID.Component) => {\n            acc[componentUID] = { populate: getDeepPopulate(componentUID, opts) };\n            return acc;\n          },\n          {}\n        );\n\n        acc[attributeName] = { on: populatedComponents };\n        break;\n      }\n      default:\n        break;\n    }\n\n    return acc;\n  }, {});\n};\n"],"names":["contentTypes","acc"],"mappings":";;;AAUA,MAAM,EAAE,sBAAsB,yBAAyBA,YAAAA,aAAa;AAG7D,MAAM,kBAAkB,CAAC,KAAiB,OAAgB,OAAO;AAChE,QAAA,QAAQ,OAAO,SAAS,GAAG;AACjC,QAAM,aAAa,OAAO,QAAQ,MAAM,UAAU;AAElD,SAAO,WAAW,OAAO,CAAC,KAAU,CAAC,eAAe,SAAS,MAAM;AACjE,YAAQ,UAAU,MAAM;AAAA,MACtB,KAAK,YAAY;AAEf,cAAM,kBAAkB,UAAU,SAAS,YAAY,EAAE,WAAW,OAAO;AAC3E,YAAI,iBAAiB;AACnB;AAAA,QAAA;AAIF,cAAM,YAAYA,YAAA,aAAa,mBAAmB,OAAO,aAAa;AACtE,cAAM,iBAAiB,CAAC,sBAAsB,oBAAoB,EAAE,SAAS,aAAa;AAE1F,YAAI,aAAa,gBAAgB;AAC/B,cAAI,aAAa,IAAI,EAAE,QAAQ,KAAK,iBAAiB;AAAA,QAAA;AAGvD;AAAA,MAAA;AAAA,MAGF,KAAK,SAAS;AAGZ,YAAI,aAAa,IAAI,EAAE,QAAQ,CAAC,GAAG,EAAE;AACrC;AAAA,MAAA;AAAA,MAGF,KAAK,aAAa;AAChB,cAAM,WAAW,gBAAgB,UAAU,WAAW,IAAI;AACtD,YAAA,aAAa,IAAI,EAAE,SAAS;AAChC;AAAA,MAAA;AAAA,MAGF,KAAK,eAAe;AAElB,cAAM,uBAAuB,UAAU,cAAc,CAAI,GAAA;AAAA,UACvD,CAACC,MAAU,iBAAgC;AACzCA,iBAAI,YAAY,IAAI,EAAE,UAAU,gBAAgB,cAAc,IAAI,EAAE;AAC7DA,mBAAAA;AAAAA,UACT;AAAA,UACA,CAAA;AAAA,QACF;AAEA,YAAI,aAAa,IAAI,EAAE,IAAI,oBAAoB;AAC/C;AAAA,MAAA;AAAA,IAGA;AAGG,WAAA;AAAA,EACT,GAAG,EAAE;AACP;;"}