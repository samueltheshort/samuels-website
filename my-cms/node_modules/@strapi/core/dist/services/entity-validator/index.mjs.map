{"version":3,"file":"index.mjs","sources":["../../../src/services/entity-validator/index.ts"],"sourcesContent":["/**\n * Entity validator\n * Module that will validate input data for entity creation or edition\n */\n\nimport { uniqBy, castArray, isNil, isArray, mergeWith } from 'lodash';\nimport { has, prop, isObject, isEmpty } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport { Modules, UID, Struct, Schema } from '@strapi/types';\nimport { Validators, ValidatorMetas } from './validators';\n\ntype CreateOrUpdate = 'creation' | 'update';\n\nconst { yup, validateYupSchema } = strapiUtils;\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\nconst { ValidationError } = strapiUtils.errors;\n\ntype ID = { id: string | number };\n\ntype RelationSource = string | number | ID;\n\nexport type ComponentContext = {\n  parentContent: {\n    // The model of the parent content type that contains the current component.\n    model: Struct.Schema;\n    // The numeric id of the parent entity that contains the component.\n    id?: number;\n    // The options passed to the entity validator. From which we can extract\n    // entity dimensions such as locale and publication state.\n    options?: ValidatorContext;\n  };\n  // The path to the component within the parent content type schema.\n  pathToComponent: string[];\n  // If working with a repeatable component this contains the\n  // full data of the repeatable component in the current entity.\n  repeatableData: Modules.EntityValidator.Entity[];\n  fullDynamicZoneContent?: Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n};\n\ninterface WithComponentContext {\n  componentContext?: ComponentContext;\n}\n\ninterface ValidatorMeta<TAttribute = Schema.Attribute.AnyAttribute> extends WithComponentContext {\n  attr: TAttribute;\n  updatedAttribute: { name: string; value: any };\n}\n\ninterface ValidatorContext {\n  isDraft?: boolean;\n  locale?: string | null;\n}\n\ninterface ModelValidatorMetas extends WithComponentContext {\n  model: Struct.Schema;\n  data: Record<string, unknown>;\n  entity?: Modules.EntityValidator.Entity;\n}\n\nconst isInteger = (value: unknown): value is number => Number.isInteger(value);\n\nconst addMinMax = <\n  T extends {\n    min(value: number): T;\n    max(value: number): T;\n  },\n>(\n  validator: T,\n  {\n    attr,\n    updatedAttribute,\n  }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.MinMaxOption<string | number>>\n): T => {\n  let nextValidator: T = validator;\n\n  if (\n    isInteger(attr.min) &&\n    (('required' in attr && attr.required) ||\n      (Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0))\n  ) {\n    nextValidator = nextValidator.min(attr.min);\n  }\n  if (isInteger(attr.max)) {\n    nextValidator = nextValidator.max(attr.max);\n  }\n  return nextValidator;\n};\n\nconst addRequiredValidation = (createOrUpdate: CreateOrUpdate) => {\n  return <T extends strapiUtils.yup.AnySchema>(\n    validator: T,\n    {\n      attr: { required },\n    }: ValidatorMeta<Partial<Schema.Attribute.AnyAttribute & Schema.Attribute.RequiredOption>>\n  ): T => {\n    let nextValidator = validator;\n\n    if (required) {\n      if (createOrUpdate === 'creation') {\n        nextValidator = nextValidator.notNil();\n      } else if (createOrUpdate === 'update') {\n        nextValidator = nextValidator.notNull();\n      }\n    } else {\n      nextValidator = nextValidator.nullable();\n    }\n    return nextValidator;\n  };\n};\n\nconst addDefault = (createOrUpdate: CreateOrUpdate) => {\n  return (\n    validator: strapiUtils.yup.BaseSchema,\n    { attr }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown>>\n  ) => {\n    let nextValidator = validator;\n\n    if (createOrUpdate === 'creation') {\n      if (\n        ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\n        !attr.required\n      ) {\n        nextValidator = nextValidator.default([]);\n      } else {\n        nextValidator = nextValidator.default(attr.default);\n      }\n    } else {\n      nextValidator = nextValidator.default(undefined);\n    }\n\n    return nextValidator;\n  };\n};\n\nconst preventCast = (validator: strapiUtils.yup.AnySchema) =>\n  validator.transform((val, originalVal) => originalVal);\n\nconst createComponentValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  (\n    {\n      attr,\n      updatedAttribute,\n      componentContext,\n    }: ValidatorMeta<Schema.Attribute.Component<UID.Component, boolean>>,\n    { isDraft }: ValidatorContext\n  ) => {\n    const model = strapi.getModel(attr.component);\n    if (!model) {\n      throw new Error('Validation failed: Model not found');\n    }\n\n    if (attr?.repeatable) {\n      // FIXME: yup v1\n\n      let validator = yup\n        .array()\n        .of(\n          yup.lazy((item) =>\n            createModelValidator(createOrUpdate)(\n              { componentContext, model, data: item },\n              { isDraft }\n            ).notNull()\n          ) as any\n        );\n\n      validator = addRequiredValidation(createOrUpdate)(validator, {\n        attr: { required: true },\n        updatedAttribute,\n      });\n\n      if (!isDraft) {\n        validator = addMinMax(validator, { attr, updatedAttribute });\n      }\n\n      return validator;\n    }\n\n    let validator = createModelValidator(createOrUpdate)(\n      {\n        model,\n        data: updatedAttribute.value,\n        componentContext,\n      },\n      { isDraft }\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !isDraft && attr.required },\n      updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createDzValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ attr, updatedAttribute, componentContext }: ValidatorMeta, { isDraft }: ValidatorContext) => {\n    let validator;\n\n    validator = yup.array().of(\n      yup.lazy((item) => {\n        const model = strapi.getModel(prop('__component', item));\n        const schema = yup\n          .object()\n          .shape({\n            __component: yup.string().required().oneOf(Object.keys(strapi.components)),\n          })\n          .notNull();\n\n        return model\n          ? schema.concat(\n              createModelValidator(createOrUpdate)(\n                { model, data: item, componentContext },\n                { isDraft }\n              )\n            )\n          : schema;\n      }) as any // FIXME: yup v1\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: true },\n      updatedAttribute,\n    });\n\n    if (!isDraft) {\n      validator = addMinMax(validator, { attr, updatedAttribute });\n    }\n\n    return validator;\n  };\n\nconst createRelationValidator = ({\n  updatedAttribute,\n}: ValidatorMeta<Schema.Attribute.Relation>) => {\n  let validator;\n\n  if (Array.isArray(updatedAttribute.value)) {\n    validator = yup.array().of(yup.mixed());\n  } else {\n    validator = yup.mixed();\n  }\n\n  return validator;\n};\n\nconst createScalarAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMeta, options: ValidatorContext) => {\n    let validator;\n\n    if (has(metas.attr.type, Validators)) {\n      validator = (Validators as any)[metas.attr.type](metas, options);\n    } else {\n      // No validators specified - fall back to mixed\n      validator = yup.mixed();\n    }\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !options.isDraft && metas.attr.required },\n      updatedAttribute: metas.updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMetas, options: ValidatorContext) => {\n    let validator = yup.mixed();\n\n    if (isMediaAttribute(metas.attr)) {\n      validator = yup.mixed();\n    } else if (isScalarAttribute(metas.attr)) {\n      validator = createScalarAttributeValidator(createOrUpdate)(metas, options);\n    } else {\n      if (metas.attr.type === 'component' && metas.componentContext) {\n        // Build the path to the component within the parent content type schema.\n        const pathToComponent = [\n          ...(metas?.componentContext?.pathToComponent ?? []),\n          metas.updatedAttribute.name,\n        ];\n\n        // If working with a repeatable component, determine the repeatable data\n        // based on the component's path.\n\n        // In order to validate the repeatable within this entity we need\n        // access to the full repeatable data. In case we are validating a\n        // nested component within a repeatable.\n        // Hence why we set this up when the path to the component is only one level deep.\n        const repeatableData = (\n          metas.attr.repeatable && pathToComponent.length === 1\n            ? metas.updatedAttribute.value\n            : metas.componentContext?.repeatableData\n        ) as Modules.EntityValidator.Entity[];\n\n        const newComponentContext: ComponentContext = {\n          ...metas.componentContext,\n          pathToComponent,\n          repeatableData,\n        };\n\n        validator = createComponentValidator(createOrUpdate)(\n          {\n            componentContext: newComponentContext,\n            attr: metas.attr,\n            updatedAttribute: metas.updatedAttribute,\n          },\n          options\n        );\n      } else if (metas.attr.type === 'dynamiczone' && metas.componentContext) {\n        const newComponentContext: ComponentContext = {\n          ...metas.componentContext,\n          fullDynamicZoneContent: metas.updatedAttribute.value,\n          pathToComponent: [...metas.componentContext.pathToComponent, metas.updatedAttribute.name],\n        };\n\n        Object.assign(metas, { componentContext: newComponentContext });\n\n        validator = createDzValidator(createOrUpdate)(metas, options);\n      } else if (metas.attr.type === 'relation') {\n        validator = createRelationValidator({\n          attr: metas.attr,\n          updatedAttribute: metas.updatedAttribute,\n        });\n      }\n\n      validator = preventCast(validator);\n    }\n\n    validator = addDefault(createOrUpdate)(validator, metas);\n\n    return validator;\n  };\n\nconst createModelValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ componentContext, model, data, entity }: ModelValidatorMetas, options: ValidatorContext) => {\n    const writableAttributes = model ? getWritableAttributes(model as any) : [];\n\n    const schema = writableAttributes.reduce(\n      (validators, attributeName) => {\n        const metas = {\n          attr: model.attributes[attributeName],\n          updatedAttribute: { name: attributeName, value: prop(attributeName, data) },\n          model,\n          entity,\n          componentContext,\n        };\n\n        const validator = createAttributeValidator(createOrUpdate)(metas, options);\n\n        validators[attributeName] = validator;\n\n        return validators;\n      },\n      {} as Record<string, strapiUtils.yup.BaseSchema>\n    );\n\n    return yup.object().shape(schema);\n  };\n\nconst createValidateEntity = (createOrUpdate: CreateOrUpdate) => {\n  return async <\n    TUID extends UID.ContentType,\n    TData extends Modules.EntityService.Params.Data.Input<TUID>,\n  >(\n    model: Schema.ContentType<TUID>,\n    data: TData | Partial<TData> | undefined,\n    options?: ValidatorContext,\n    entity?: Modules.EntityValidator.Entity\n  ): Promise<TData> => {\n    if (!isObject(data)) {\n      const { displayName } = model.info;\n\n      throw new ValidationError(\n        `Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`\n      );\n    }\n\n    const validator = createModelValidator(createOrUpdate)(\n      {\n        model,\n        data,\n        entity,\n        componentContext: {\n          // Set up the initial component context.\n          // Keeping track of parent content type context in which a component will be used.\n          // This is necessary to validate component field constraints such as uniqueness.\n          parentContent: {\n            id: entity?.id,\n            model,\n            options,\n          },\n          pathToComponent: [],\n          repeatableData: [],\n        },\n      },\n      {\n        isDraft: options?.isDraft ?? false,\n        locale: options?.locale ?? null,\n      }\n    )\n      .test(\n        'relations-test',\n        'check that all relations exist',\n        async function relationsValidation(data) {\n          try {\n            await checkRelationsExist(buildRelationsStore({ uid: model.uid, data }));\n          } catch (e) {\n            return this.createError({\n              path: this.path,\n              message: (e instanceof ValidationError && e.message) || 'Invalid relations',\n            });\n          }\n          return true;\n        }\n      )\n      .required();\n\n    return validateYupSchema(validator, {\n      strict: false,\n      abortEarly: false,\n    })(data);\n  };\n};\n\n/**\n * Builds an object containing all the media and relations being associated with an entity\n */\nconst buildRelationsStore = <TUID extends UID.Schema>({\n  uid,\n  data,\n}: {\n  uid: TUID;\n  data: Record<string, unknown> | null;\n}): Record<string, ID[]> => {\n  if (!uid) {\n    throw new ValidationError(`Cannot build relations store: \"uid\" is undefined`);\n  }\n\n  if (isEmpty(data)) {\n    return {};\n  }\n\n  const currentModel = strapi.getModel(uid);\n\n  return Object.keys(currentModel.attributes).reduce(\n    (result, attributeName: string) => {\n      const attribute = currentModel.attributes[attributeName];\n      const value = data[attributeName];\n\n      if (isNil(value)) {\n        return result;\n      }\n\n      switch (attribute.type) {\n        case 'relation':\n        case 'media': {\n          if (\n            attribute.type === 'relation' &&\n            (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')\n          ) {\n            // TODO: handle polymorphic relations\n            break;\n          }\n\n          const target =\n            // eslint-disable-next-line no-nested-ternary\n            attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;\n          // As there are multiple formats supported for associating relations\n          // with an entity, the value here can be an: array, object or number.\n          let source: RelationSource[];\n          if (Array.isArray(value)) {\n            source = value;\n          } else if (isObject(value)) {\n            if ('connect' in value && !isNil(value.connect)) {\n              source = value.connect as RelationSource[];\n            } else if ('set' in value && !isNil(value.set)) {\n              source = value.set as RelationSource[];\n            } else {\n              source = [];\n            }\n          } else {\n            source = castArray(value as RelationSource);\n          }\n          const idArray = source.map((v) => ({\n            id: typeof v === 'object' ? v.id : v,\n          }));\n\n          // Update the relationStore to keep track of all associations being made\n          // with relations and media.\n          result[target] = result[target] || [];\n          result[target].push(...idArray);\n          break;\n        }\n        case 'component': {\n          return castArray(value).reduce((relationsStore, componentValue) => {\n            if (!attribute.component) {\n              throw new ValidationError(\n                `Cannot build relations store from component, component identifier is undefined`\n              );\n            }\n\n            return mergeWith(\n              relationsStore,\n              buildRelationsStore({\n                uid: attribute.component,\n                data: componentValue as Record<string, unknown>,\n              }),\n              (objValue, srcValue) => {\n                if (isArray(objValue)) {\n                  return objValue.concat(srcValue);\n                }\n              }\n            );\n          }, result) as Record<string, ID[]>;\n        }\n        case 'dynamiczone': {\n          return castArray(value).reduce((relationsStore, dzValue) => {\n            const value = dzValue as Record<string, unknown>;\n            if (!value.__component) {\n              throw new ValidationError(\n                `Cannot build relations store from dynamiczone, component identifier is undefined`\n              );\n            }\n\n            return mergeWith(\n              relationsStore,\n              buildRelationsStore({\n                uid: value.__component as UID.Component,\n                data: value,\n              }),\n              (objValue, srcValue) => {\n                if (isArray(objValue)) {\n                  return objValue.concat(srcValue);\n                }\n              }\n            );\n          }, result) as Record<string, ID[]>;\n        }\n        default:\n          break;\n      }\n\n      return result;\n    },\n    {} as Record<string, ID[]>\n  );\n};\n\n/**\n * Iterate through the relations store and validates that every relation or media\n * mentioned exists\n */\nconst checkRelationsExist = async (relationsStore: Record<string, ID[]> = {}) => {\n  const promises: Promise<void>[] = [];\n\n  for (const [key, value] of Object.entries(relationsStore)) {\n    const evaluate = async () => {\n      const uniqueValues = uniqBy(value, `id`);\n      const count = await strapi.db.query(key as UID.Schema).count({\n        where: {\n          id: {\n            $in: uniqueValues.map((v) => v.id),\n          },\n        },\n      });\n\n      if (count !== uniqueValues.length) {\n        throw new ValidationError(\n          `${\n            uniqueValues.length - count\n          } relation(s) of type ${key} associated with this entity do not exist`\n        );\n      }\n    };\n    promises.push(evaluate());\n  }\n\n  return Promise.all(promises);\n};\n\nconst entityValidator: Modules.EntityValidator.EntityValidator = {\n  validateEntityCreation: createValidateEntity('creation'),\n  validateEntityUpdate: createValidateEntity('update'),\n};\n\nexport default entityValidator;\n"],"names":["validator","data","value"],"mappings":"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"}