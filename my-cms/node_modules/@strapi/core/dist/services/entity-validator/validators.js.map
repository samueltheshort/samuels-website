{"version":3,"file":"validators.js","sources":["../../../src/services/entity-validator/validators.ts"],"sourcesContent":["/**\n * Validators check if the entry data meets specific criteria before saving or publishing.\n * (e.g., length, range, format).\n *\n * Drafts have limited validations (mainly max constraints),\n * while published content undergoes full validation.\n *\n * The system also takes locales into account when validating data.\n * E.g, unique fields must be unique within the same locale.\n */\nimport _ from 'lodash';\nimport { yup } from '@strapi/utils';\nimport type { Schema, Struct, Modules } from '@strapi/types';\nimport { blocksValidator } from './blocks-validator';\n\nimport type { ComponentContext } from '.';\n\nexport interface ValidatorMetas<\n  TAttribute extends Schema.Attribute.AnyAttribute = Schema.Attribute.AnyAttribute,\n  TValue extends Schema.Attribute.Value<TAttribute> = Schema.Attribute.Value<TAttribute>,\n> {\n  attr: TAttribute;\n  model: Struct.Schema;\n  updatedAttribute: {\n    name: string;\n    value: TValue;\n  };\n  componentContext?: ComponentContext;\n  entity?: Modules.EntityValidator.Entity;\n}\n\ninterface ValidatorOptions {\n  isDraft: boolean;\n  locale?: string;\n}\n\n/* Validator utils */\n\n/**\n * Adds minLength validator\n */\nconst addMinLengthValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  },\n  { isDraft }: ValidatorOptions\n) => {\n  return attr.minLength && _.isInteger(attr.minLength) && !isDraft\n    ? validator.min(attr.minLength)\n    : validator;\n};\n\n/**\n * Adds maxLength validator\n * @returns {StringSchema}\n */\nconst addMaxLengthValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  }\n) => {\n  return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;\n};\n\n/**\n * Adds min integer validator\n * @returns {NumberSchema}\n */\nconst addMinIntegerValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\n  },\n  { isDraft }: ValidatorOptions\n) => (_.isNumber(attr.min) && !isDraft ? validator.min(_.toInteger(attr.min)) : validator);\n\n/**\n * Adds max integer validator\n */\nconst addMaxIntegerValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\n  }\n) => (_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator);\n\n/**\n * Adds min float/decimal validator\n */\nconst addMinFloatValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\n  },\n  { isDraft }: ValidatorOptions\n) => (_.isNumber(attr.min) && !isDraft ? validator.min(attr.min) : validator);\n\n/**\n * Adds max float/decimal validator\n */\nconst addMaxFloatValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\n  }\n) => (_.isNumber(attr.max) ? validator.max(attr.max) : validator);\n\n/**\n * Adds regex validator\n */\nconst addStringRegexValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  },\n  { isDraft }: ValidatorOptions\n) => {\n  return 'regex' in attr && !_.isUndefined(attr.regex) && !isDraft\n    ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })\n    : validator;\n};\n\nconst addUniqueValidator = <T extends yup.AnySchema>(\n  validator: T,\n  {\n    attr,\n    model,\n    updatedAttribute,\n    entity,\n    componentContext,\n  }: ValidatorMetas<Schema.Attribute.AnyAttribute & Schema.Attribute.UniqueOption>,\n  options: ValidatorOptions\n): T => {\n  if (attr.type !== 'uid' && !attr.unique) {\n    return validator;\n  }\n\n  const validateUniqueFieldWithinComponent = async (value: any): Promise<boolean> => {\n    if (!componentContext) {\n      return false;\n    }\n\n    // If we are validating a unique field within a repeatable component,\n    // we first need to ensure that the repeatable in the current entity is\n    // valid against itself.\n    const hasRepeatableData = componentContext.repeatableData.length > 0;\n    if (hasRepeatableData) {\n      const { name: updatedName, value: updatedValue } = updatedAttribute;\n      // Construct the full path to the unique field within the component.\n      const pathToCheck = [...componentContext.pathToComponent.slice(1), updatedName].join('.');\n\n      // Extract the values from the repeatable data using the constructed path\n      const values = componentContext.repeatableData.map((item) => {\n        return pathToCheck.split('.').reduce((acc, key) => acc[key], item as any);\n      });\n\n      // Check if the value is repeated in the current entity\n      const isUpdatedAttributeRepeatedInThisEntity =\n        values.filter((value) => value === updatedValue).length > 1;\n\n      if (isUpdatedAttributeRepeatedInThisEntity) {\n        return false;\n      }\n    }\n\n    /**\n     * When `componentContext` is present it means we are dealing with a unique\n     * field within a component.\n     *\n     * The unique validation must consider the specific context of the\n     * component, which will always be contained within a parent content type\n     * and may also be nested within another component.\n     *\n     * We construct a query that takes into account the parent's model UID,\n     * dimensions (such as draft and publish state/locale) and excludes the current\n     * content type entity by its ID if provided.\n     */\n    const {\n      model: parentModel,\n      options: parentOptions,\n      id: excludeId,\n    } = componentContext.parentContent;\n\n    const whereConditions: Record<string, any> = {};\n    const isParentDraft = parentOptions && parentOptions.isDraft;\n\n    whereConditions.publishedAt = isParentDraft ? null : { $notNull: true };\n\n    if (parentOptions?.locale) {\n      whereConditions.locale = parentOptions.locale;\n    }\n\n    if (excludeId && !Number.isNaN(excludeId)) {\n      whereConditions.id = { $ne: excludeId };\n    }\n\n    const queryUid = parentModel.uid;\n    const queryWhere = {\n      ...componentContext.pathToComponent.reduceRight((acc, key) => ({ [key]: acc }), {\n        [updatedAttribute.name]: value,\n      }),\n\n      ...whereConditions,\n    };\n\n    // The validation should pass if there is no other record found from the query\n    return !(await strapi.db.query(queryUid).findOne({ where: queryWhere }));\n  };\n\n  const validateUniqueFieldWithinDynamicZoneComponent = async (\n    startOfPath: string\n  ): Promise<boolean> => {\n    if (!componentContext) {\n      return false;\n    }\n\n    const targetComponentUID = model.uid;\n    // Ensure that the value is unique within the dynamic zone in this entity.\n    const countOfValueInThisEntity = (componentContext?.fullDynamicZoneContent ?? []).reduce(\n      (acc, component) => {\n        if (component.__component !== targetComponentUID) {\n          return acc;\n        }\n\n        const updatedValue = component[updatedAttribute.name];\n        return updatedValue === updatedAttribute.value ? acc + 1 : acc;\n      },\n      0\n    );\n\n    if (countOfValueInThisEntity > 1) {\n      // If the value is repeated in the current entity, the validation fails.\n      return false;\n    }\n\n    // Build a query for the parent content type to find all entities in the\n    // same locale and publication state\n    type QueryType = {\n      select: string[];\n      where: {\n        published_at?: { $eq: null } | { $ne: null };\n        id?: { $ne: number };\n        locale?: string;\n      };\n      populate: {\n        [key: string]: {\n          on: {\n            [key: string]: {\n              select: string[];\n              where: { [key: string]: string | number | boolean };\n            };\n          };\n        };\n      };\n    };\n\n    // Populate the dynamic zone for any components that share the same value\n    // as the updated attribute.\n    const query: QueryType = {\n      select: ['id'],\n      where: {},\n      populate: {\n        [startOfPath]: {\n          on: {\n            [targetComponentUID]: {\n              select: ['id'],\n              where: { [updatedAttribute.name]: updatedAttribute.value },\n            },\n          },\n        },\n      },\n    };\n\n    const { options, id } = componentContext.parentContent;\n\n    if (options?.isDraft !== undefined) {\n      query.where.published_at = options.isDraft ? { $eq: null } : { $ne: null };\n    }\n\n    if (id) {\n      query.where.id = { $ne: id };\n    }\n\n    if (options?.locale) {\n      query.where.locale = options.locale;\n    }\n\n    const parentModelQueryResult = await strapi.db\n      .query(componentContext.parentContent.model.uid)\n      .findMany(query);\n\n    // Filter the results to only include results that have components in the\n    // dynamic zone that match the target component type.\n    const filteredResults = parentModelQueryResult\n      .filter((result) => Array.isArray(result[startOfPath]) && result[startOfPath].length)\n      .flatMap((result) => result[startOfPath])\n      .filter((dynamicZoneComponent) => dynamicZoneComponent.__component === targetComponentUID);\n\n    if (filteredResults.length >= 1) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return validator.test('unique', 'This attribute must be unique', async (value) => {\n    /**\n     * If the attribute value is `null` or an empty string we want to skip the unique validation.\n     * Otherwise it'll only accept a single entry with that value in the database.\n     */\n    if (_.isNil(value) || value === '') {\n      return true;\n    }\n\n    /**\n     * We don't validate any unique constraint for draft entries.\n     */\n    if (options.isDraft) {\n      return true;\n    }\n\n    const hasPathToComponent = componentContext && componentContext.pathToComponent.length > 0;\n    if (hasPathToComponent) {\n      // Detect if we are validating within a dynamiczone by checking if the first\n      // path is a dynamiczone attribute in the parent content type.\n      const startOfPath = componentContext.pathToComponent[0];\n      const testingDZ =\n        componentContext.parentContent.model.attributes[startOfPath].type === 'dynamiczone';\n\n      if (testingDZ) {\n        return validateUniqueFieldWithinDynamicZoneComponent(startOfPath);\n      }\n\n      return validateUniqueFieldWithinComponent(value);\n    }\n\n    /**\n     * Here we are validating a scalar unique field from the content type's schema.\n     * We construct a query to check if the value is unique\n     * considering dimensions (e.g. locale, publication state) and excluding the current entity by its ID if available.\n     */\n    const scalarAttributeWhere: Record<string, any> = {\n      [updatedAttribute.name]: value,\n      publishedAt: { $notNull: true },\n    };\n\n    if (options?.locale) {\n      scalarAttributeWhere.locale = options.locale;\n    }\n\n    if (entity?.id) {\n      scalarAttributeWhere.id = { $ne: entity.id };\n    }\n\n    // The validation should pass if there is no other record found from the query\n    return !(await strapi.db\n      .query(model.uid)\n      .findOne({ where: scalarAttributeWhere, select: ['id'] }));\n  });\n};\n\n/* Type validators */\n\nconst stringValidator = (\n  metas: ValidatorMetas<\n    | Schema.Attribute.String\n    | Schema.Attribute.Text\n    | Schema.Attribute.RichText\n    | Schema.Attribute.Password\n    | Schema.Attribute.Email\n    | Schema.Attribute.UID\n  >,\n  options: ValidatorOptions\n) => {\n  let schema = yup.string().transform((val, originalVal) => originalVal);\n\n  schema = addMinLengthValidator(schema, metas, options);\n  schema = addMaxLengthValidator(schema, metas);\n  schema = addStringRegexValidator(schema, metas, options);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nexport const emailValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Email>,\n  options: ValidatorOptions\n) => {\n  const schema = stringValidator(metas, options);\n\n  if (options.isDraft) {\n    return schema;\n  }\n\n  return schema.email().min(\n    1,\n    // eslint-disable-next-line no-template-curly-in-string\n    '${path} cannot be empty'\n  );\n};\n\nexport const uidValidator = (\n  metas: ValidatorMetas<Schema.Attribute.UID>,\n  options: ValidatorOptions\n) => {\n  const schema = stringValidator(metas, options);\n\n  if (options.isDraft) {\n    return schema;\n  }\n\n  return schema.matches(/^[A-Za-z0-9-_.~]*$/);\n};\n\nexport const enumerationValidator = ({ attr }: { attr: Schema.Attribute.Enumeration }) => {\n  return yup\n    .string()\n    .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null as any));\n};\n\nexport const integerValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Integer | Schema.Attribute.BigInteger>,\n  options: ValidatorOptions\n) => {\n  let schema = yup.number().integer();\n\n  schema = addMinIntegerValidator(schema, metas, options);\n  schema = addMaxIntegerValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nexport const floatValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Decimal | Schema.Attribute.Float>,\n  options: ValidatorOptions\n) => {\n  let schema = yup.number();\n\n  schema = addMinFloatValidator(schema, metas, options);\n  schema = addMaxFloatValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nexport const bigintegerValidator = (\n  metas: ValidatorMetas<Schema.Attribute.BigInteger>,\n  options: ValidatorOptions\n) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas, options);\n};\n\nexport const datesValidator = (\n  metas: ValidatorMetas<\n    | Schema.Attribute.Date\n    | Schema.Attribute.DateTime\n    | Schema.Attribute.Time\n    | Schema.Attribute.Timestamp\n  >,\n  options: ValidatorOptions\n) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas, options);\n};\n\nexport const Validators = {\n  string: stringValidator,\n  text: stringValidator,\n  richtext: stringValidator,\n  password: stringValidator,\n  email: emailValidator,\n  enumeration: enumerationValidator,\n  boolean: () => yup.boolean(),\n  uid: uidValidator,\n  json: () => yup.mixed(),\n  integer: integerValidator,\n  biginteger: bigintegerValidator,\n  float: floatValidator,\n  decimal: floatValidator,\n  date: datesValidator,\n  time: datesValidator,\n  datetime: datesValidator,\n  timestamp: datesValidator,\n  blocks: blocksValidator,\n};\n"],"names":["_","value","options","yup","blocksValidator"],"mappings":"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"}