{"version":3,"file":"validator.mjs","sources":["../../../src/domain/content-type/validator.ts"],"sourcesContent":["import _ from 'lodash';\nimport { yup, strings } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\n\nconst LIFECYCLES = [\n  'beforeCreate',\n  'afterCreate',\n  'beforeFindOne',\n  'afterFindOne',\n  'beforeFindMany',\n  'afterFindMany',\n  'beforeCount',\n  'afterCount',\n  'beforeCreateMany',\n  'afterCreateMany',\n  'beforeUpdate',\n  'afterUpdate',\n  'beforeUpdateMany',\n  'afterUpdateMany',\n  'beforeDelete',\n  'afterDelete',\n  'beforeDeleteMany',\n  'afterDeleteMany',\n] as const;\n\n/**\n * For enumerations the least common denomiator is GraphQL, where\n * values needs to match the secure name regex:\n * GraphQL Spec https://spec.graphql.org/June2018/#sec-Names\n *\n * Therefore we need to make sure our users only use values, which\n * can be returned by GraphQL, by checking the regressed values\n * agains the GraphQL regex.\n *\n * TODO V5: check if we can avoid this coupling by moving this logic\n * into the GraphQL plugin.\n */\nconst GRAPHQL_ENUM_REGEX = /^[_A-Za-z][_0-9A-Za-z]*$/;\n\nconst lifecyclesShape = _.mapValues(_.keyBy(LIFECYCLES), () => yup.mixed().nullable().isFunction());\n\nconst contentTypeSchemaValidator = yup.object().shape({\n  schema: yup.object().shape({\n    info: yup\n      .object()\n      .shape({\n        displayName: yup.string().required(),\n        singularName: yup.string().isKebabCase().required(),\n        pluralName: yup.string().isKebabCase().required(),\n      })\n      .required(),\n    attributes: yup.object().test({\n      name: 'valuesCollide',\n      message: 'Some values collide when normalized',\n      test(attributes: Schema.ContentType['attributes']) {\n        for (const attrName of Object.keys(attributes)) {\n          const attr = attributes[attrName];\n          if (attr.type === 'enumeration') {\n            const regressedValues = attr.enum.map(strings.toRegressedEnumValue);\n\n            // should match the GraphQL regex\n            if (!regressedValues.every((value: string) => GRAPHQL_ENUM_REGEX.test(value))) {\n              const message = `Invalid enumeration value. Values should have at least one alphabetical character preceding the first occurence of a number. Update your enumeration '${attrName}'.`;\n\n              return this.createError({ message });\n            }\n\n            // should not contain empty values\n            if (regressedValues.some((value: string) => value === '')) {\n              return this.createError({\n                message: `At least one value of the enumeration '${attrName}' appears to be empty. Only alphanumerical characters are taken into account.`,\n              });\n            }\n\n            // should not collide\n            const duplicates = _.uniq(\n              regressedValues.filter(\n                (value: string, index: number, values: string[]) => values.indexOf(value) !== index\n              )\n            );\n\n            if (duplicates.length) {\n              const message = `Some enumeration values of the field '${attrName}' collide when normalized: ${duplicates.join(\n                ', '\n              )}. Please modify your enumeration.`;\n\n              return this.createError({ message });\n            }\n          }\n        }\n\n        return true;\n      },\n    }),\n  }),\n  actions: yup.object().onlyContainsFunctions(),\n  lifecycles: yup.object().shape(lifecyclesShape).noUnknown(),\n});\n\nconst validateContentTypeDefinition = (data: unknown) => {\n  return contentTypeSchemaValidator.validateSync(data, { strict: true, abortEarly: false });\n};\n\nexport { validateContentTypeDefinition };\n"],"names":[],"mappings":";;AAIA,MAAM,aAAa;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAcA,MAAM,qBAAqB;AAE3B,MAAM,kBAAkB,EAAE,UAAU,EAAE,MAAM,UAAU,GAAG,MAAM,IAAI,MAAM,EAAE,SAAS,EAAE,YAAY;AAElG,MAAM,6BAA6B,IAAI,OAAO,EAAE,MAAM;AAAA,EACpD,QAAQ,IAAI,OAAO,EAAE,MAAM;AAAA,IACzB,MAAM,IACH,OAAO,EACP,MAAM;AAAA,MACL,aAAa,IAAI,OAAO,EAAE,SAAS;AAAA,MACnC,cAAc,IAAI,OAAS,EAAA,YAAA,EAAc,SAAS;AAAA,MAClD,YAAY,IAAI,SAAS,cAAc,SAAS;AAAA,IACjD,CAAA,EACA,SAAS;AAAA,IACZ,YAAY,IAAI,OAAO,EAAE,KAAK;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS;AAAA,MACT,KAAK,YAA8C;AACjD,mBAAW,YAAY,OAAO,KAAK,UAAU,GAAG;AACxC,gBAAA,OAAO,WAAW,QAAQ;AAC5B,cAAA,KAAK,SAAS,eAAe;AAC/B,kBAAM,kBAAkB,KAAK,KAAK,IAAI,QAAQ,oBAAoB;AAG9D,gBAAA,CAAC,gBAAgB,MAAM,CAAC,UAAkB,mBAAmB,KAAK,KAAK,CAAC,GAAG;AACvE,oBAAA,UAAU,yJAAyJ,QAAQ;AAEjL,qBAAO,KAAK,YAAY,EAAE,SAAS;AAAA,YAAA;AAIrC,gBAAI,gBAAgB,KAAK,CAAC,UAAkB,UAAU,EAAE,GAAG;AACzD,qBAAO,KAAK,YAAY;AAAA,gBACtB,SAAS,0CAA0C,QAAQ;AAAA,cAAA,CAC5D;AAAA,YAAA;AAIH,kBAAM,aAAa,EAAE;AAAA,cACnB,gBAAgB;AAAA,gBACd,CAAC,OAAe,OAAe,WAAqB,OAAO,QAAQ,KAAK,MAAM;AAAA,cAAA;AAAA,YAElF;AAEA,gBAAI,WAAW,QAAQ;AACrB,oBAAM,UAAU,yCAAyC,QAAQ,8BAA8B,WAAW;AAAA,gBACxG;AAAA,cACD,CAAA;AAED,qBAAO,KAAK,YAAY,EAAE,SAAS;AAAA,YAAA;AAAA,UACrC;AAAA,QACF;AAGK,eAAA;AAAA,MAAA;AAAA,IAEV,CAAA;AAAA,EAAA,CACF;AAAA,EACD,SAAS,IAAI,OAAO,EAAE,sBAAsB;AAAA,EAC5C,YAAY,IAAI,OAAA,EAAS,MAAM,eAAe,EAAE,UAAU;AAC5D,CAAC;AAEK,MAAA,gCAAgC,CAAC,SAAkB;AAChD,SAAA,2BAA2B,aAAa,MAAM,EAAE,QAAQ,MAAM,YAAY,OAAO;AAC1F;"}