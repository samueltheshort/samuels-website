{"version":3,"file":"cron.js","sources":["../../src/utils/cron.ts"],"sourcesContent":["import { isEmpty, negate } from 'lodash/fp';\n\nconst DATE_FUNCTIONS = [\n  'getSeconds',\n  'getMinutes',\n  'getHours',\n  'getDate',\n  'getMonth',\n  'getDay',\n] as const;\n\nconst INTEGER_REGEX = /^\\d+$/;\nconst STEP_REGEX = /^\\*\\/\\d+$/;\nconst COMPONENTS: {\n  limit: number;\n  zeroBasedIndices: boolean;\n  functionName: (typeof DATE_FUNCTIONS)[number];\n}[] = [\n  { limit: 60, zeroBasedIndices: true, functionName: 'getSeconds' },\n  { limit: 60, zeroBasedIndices: true, functionName: 'getMinutes' },\n  { limit: 24, zeroBasedIndices: true, functionName: 'getHours' },\n  { limit: 31, zeroBasedIndices: false, functionName: 'getDate' },\n  { limit: 12, zeroBasedIndices: false, functionName: 'getMonth' },\n  { limit: 7, zeroBasedIndices: true, functionName: 'getDay' },\n];\n\nconst shift = (component: string, index: number, date: Date) => {\n  if (component === '*') {\n    return '*';\n  }\n\n  const { limit, zeroBasedIndices, functionName } = COMPONENTS[index];\n  const offset = +!zeroBasedIndices;\n  const currentValue = date[functionName]();\n\n  if (INTEGER_REGEX.test(component)) {\n    return ((Number.parseInt(component, 10) + currentValue) % limit) + offset;\n  }\n\n  if (STEP_REGEX.test(component)) {\n    const [, step] = component.split('/');\n    const frequency = Math.floor(limit / Number(step));\n    const list = Array.from({ length: frequency }, (_, index) => index * Number(step));\n    return list.map((value) => ((value + currentValue) % limit) + offset).sort((a, b) => a - b);\n  }\n\n  // Unsupported syntax\n  return component;\n};\n\n/**\n * Simulate an interval by shifting a cron expression using the specified date.\n * @param {string} rule A cron expression you want to shift.\n * @param {Date} date The date that's gonna be used as the start of the \"interval\", it defaults to now.\n * @returns The shifted cron expression.\n */\nexport const shiftCronExpression = (rule: string, date = new Date()) => {\n  const components = rule.trim().split(' ').filter(negate(isEmpty));\n  const secondsIncluded = components.length === 6;\n  return components\n    .map((component, index) => shift(component, secondsIncluded ? index : index + 1, date))\n    .join(' ');\n};\n"],"names":["index","negate","isEmpty"],"mappings":";;;AAWA,MAAM,gBAAgB;AACtB,MAAM,aAAa;AACnB,MAAM,aAIA;AAAA,EACJ,EAAE,OAAO,IAAI,kBAAkB,MAAM,cAAc,aAAa;AAAA,EAChE,EAAE,OAAO,IAAI,kBAAkB,MAAM,cAAc,aAAa;AAAA,EAChE,EAAE,OAAO,IAAI,kBAAkB,MAAM,cAAc,WAAW;AAAA,EAC9D,EAAE,OAAO,IAAI,kBAAkB,OAAO,cAAc,UAAU;AAAA,EAC9D,EAAE,OAAO,IAAI,kBAAkB,OAAO,cAAc,WAAW;AAAA,EAC/D,EAAE,OAAO,GAAG,kBAAkB,MAAM,cAAc,SAAS;AAC7D;AAEA,MAAM,QAAQ,CAAC,WAAmB,OAAe,SAAe;AAC9D,MAAI,cAAc,KAAK;AACd,WAAA;AAAA,EAAA;AAGT,QAAM,EAAE,OAAO,kBAAkB,aAAa,IAAI,WAAW,KAAK;AAC5D,QAAA,SAAS,CAAC,CAAC;AACX,QAAA,eAAe,KAAK,YAAY,EAAE;AAEpC,MAAA,cAAc,KAAK,SAAS,GAAG;AACjC,YAAS,OAAO,SAAS,WAAW,EAAE,IAAI,gBAAgB,QAAS;AAAA,EAAA;AAGjE,MAAA,WAAW,KAAK,SAAS,GAAG;AAC9B,UAAM,CAAG,EAAA,IAAI,IAAI,UAAU,MAAM,GAAG;AACpC,UAAM,YAAY,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC;AACjD,UAAM,OAAO,MAAM,KAAK,EAAE,QAAQ,UAAA,GAAa,CAAC,GAAGA,WAAUA,SAAQ,OAAO,IAAI,CAAC;AACjF,WAAO,KAAK,IAAI,CAAC,WAAY,QAAQ,gBAAgB,QAAS,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAAA,EAAA;AAIrF,SAAA;AACT;AAQO,MAAM,sBAAsB,CAAC,MAAc,OAAO,oBAAI,WAAW;AAChE,QAAA,aAAa,KAAK,OAAO,MAAM,GAAG,EAAE,OAAOC,UAAOC,GAAAA,OAAO,CAAC;AAC1D,QAAA,kBAAkB,WAAW,WAAW;AAC9C,SAAO,WACJ,IAAI,CAAC,WAAW,UAAU,MAAM,WAAW,kBAAkB,QAAQ,QAAQ,GAAG,IAAI,CAAC,EACrF,KAAK,GAAG;AACb;;"}