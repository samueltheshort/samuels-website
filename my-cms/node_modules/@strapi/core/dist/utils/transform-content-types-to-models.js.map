{"version":3,"file":"transform-content-types-to-models.js","sources":["../../src/utils/transform-content-types-to-models.ts"],"sourcesContent":["import { type Model, type Identifiers } from '@strapi/database';\nimport type { Struct, Schema } from '@strapi/types';\nimport { createId } from '@paralleldrive/cuid2';\nimport assert from 'node:assert';\nimport _ from 'lodash/fp';\n\n/**\n * Because strapi/database models don't know about things like components or dynamic zones, we use this file to convert them\n * to a relations format that it recognizes\n *\n * Therefore we have to keep an additional set of helpers/extensions to the database naming methods\n *\n * IMPORTANT!\n * If we use short versions of anything, we MUST call getNameFromTokens directly; attempting to shorten them ourselves\n * prevents the unshortened name map from being filled properly, so for example it will think that the short name\n * 'collection4f3a_cmps' maps to the unshortened 'collectionname_cmps' rather than 'collectionname_components'\n * Therefore, we only use the identifiers helpers in cases where we do not do any of our own shortening\n */\n\nexport const getComponentJoinTableName = (collectionName: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: collectionName, compressible: true },\n    { name: 'components', shortName: 'cmps', compressible: false },\n  ]);\n};\n\nexport const getDzJoinTableName = (collectionName: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: collectionName, compressible: true },\n    { name: 'components', shortName: 'cmps', compressible: false },\n  ]);\n};\n\nexport const getComponentJoinColumnEntityName = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: 'entity', compressible: false },\n    { name: 'id', compressible: false },\n  ]);\n};\n\nexport const getComponentJoinColumnInverseName = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: 'component', shortName: 'cmp', compressible: false },\n    { name: 'id', compressible: false },\n  ]);\n};\n\nexport const getComponentTypeColumn = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([{ name: 'component_type', compressible: false }]);\n};\n\nexport const getComponentFkIndexName = (contentType: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: contentType, compressible: true },\n    { name: 'entity', compressible: false },\n    { name: 'fk', compressible: false },\n  ]);\n};\n\n// const { ID_COLUMN: id, FIELD_COLUMN: field, ORDER_COLUMN: order } = identifiers;\n\nexport type LoadedContentTypeModel = Struct.ContentTypeSchema &\n  Required<Pick<Struct.ContentTypeSchema, 'collectionName' | 'uid' | 'modelName'>> &\n  Pick<Model, 'lifecycles'>;\n\n// Transforms an attribute (particularly for relation types) into the format that strapi/database accepts\nexport const transformAttribute = (\n  name: string,\n  attribute: Schema.Attribute.AnyAttribute,\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n) => {\n  switch (attribute.type) {\n    case 'media': {\n      return {\n        type: 'relation',\n        relation: attribute.multiple === true ? 'morphMany' : 'morphOne',\n        target: 'plugin::upload.file',\n        morphBy: 'related',\n      };\n    }\n    case 'component': {\n      const joinTableName = getComponentJoinTableName(contentType.collectionName, identifiers);\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\n      const compTypeColumn = getComponentTypeColumn(identifiers);\n      return {\n        type: 'relation',\n        relation: attribute.repeatable === true ? 'oneToMany' : 'oneToOne',\n        target: attribute.component,\n\n        // We need the join table name to be deterministic,\n        // We need to allow passing the join table name as an option\n        joinTable: {\n          name: joinTableName,\n          joinColumn: {\n            name: joinColumnEntityName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          inverseJoinColumn: {\n            name: joinColumnInverseName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          on: {\n            field: name,\n          },\n          orderColumnName: identifiers.ORDER_COLUMN,\n          orderBy: {\n            order: 'asc',\n          },\n          pivotColumns: [\n            joinColumnEntityName,\n            joinColumnInverseName,\n            identifiers.FIELD_COLUMN,\n            compTypeColumn,\n          ],\n        },\n      };\n    }\n    case 'dynamiczone': {\n      const joinTableName = getDzJoinTableName(contentType.collectionName, identifiers);\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\n      const compTypeColumn = getComponentTypeColumn(identifiers);\n\n      return {\n        type: 'relation',\n        relation: 'morphToMany',\n        // TODO: handle restrictions at some point\n        // target: attribute.components,\n        joinTable: {\n          name: joinTableName,\n          joinColumn: {\n            name: joinColumnEntityName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          morphColumn: {\n            idColumn: {\n              name: joinColumnInverseName,\n              referencedColumn: identifiers.ID_COLUMN,\n            },\n            typeColumn: {\n              name: compTypeColumn,\n            },\n            typeField: '__component',\n          },\n          on: {\n            field: name,\n          },\n          orderBy: {\n            order: 'asc',\n          },\n          pivotColumns: [\n            joinColumnEntityName,\n            joinColumnInverseName,\n            identifiers.FIELD_COLUMN,\n            compTypeColumn,\n          ],\n        },\n      };\n    }\n    default: {\n      return attribute;\n    }\n  }\n};\n\nexport const transformAttributes = (\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n) => {\n  return Object.keys(contentType.attributes! || {}).reduce((attrs, attrName) => {\n    return {\n      ...attrs,\n      [attrName]: transformAttribute(\n        attrName,\n        contentType.attributes[attrName]!,\n        contentType,\n        identifiers\n      ),\n    };\n  }, {});\n};\n\nexport const hasComponentsOrDz = (\n  contentType: LoadedContentTypeModel\n): contentType is LoadedContentTypeModel & { type: 'dynamiczone' | 'component' } => {\n  return Object.values(contentType.attributes || {}).some(\n    (({ type }: { type: string }) => type === 'dynamiczone' || type === 'component') as any\n  );\n};\n\nexport const createDocumentId = createId;\n\nconst createCompoLinkModel = (\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n): Model => {\n  const name = getComponentJoinTableName(contentType.collectionName, identifiers);\n\n  const entityId = getComponentJoinColumnEntityName(identifiers);\n  const componentId = getComponentJoinColumnInverseName(identifiers);\n  const compTypeColumn = getComponentTypeColumn(identifiers);\n  const fkIndex = getComponentFkIndexName(contentType.collectionName, identifiers);\n\n  return {\n    // TODO: make sure there can't be any conflicts with a prefix\n    singularName: name,\n    uid: name,\n    tableName: name,\n    attributes: {\n      [identifiers.ID_COLUMN]: {\n        type: 'increments',\n      },\n      [entityId]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [componentId]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [compTypeColumn]: {\n        type: 'string',\n      },\n      [identifiers.FIELD_COLUMN]: {\n        type: 'string',\n      },\n      [identifiers.ORDER_COLUMN]: {\n        type: 'float',\n        column: {\n          unsigned: true,\n          defaultTo: null,\n        },\n      },\n    },\n    indexes: [\n      {\n        name: identifiers.getIndexName([contentType.collectionName, identifiers.FIELD_COLUMN]),\n        columns: [identifiers.FIELD_COLUMN],\n      },\n      {\n        name: identifiers.getIndexName([contentType.collectionName, compTypeColumn]),\n        columns: [compTypeColumn],\n      },\n      {\n        name: fkIndex,\n        columns: [entityId],\n      },\n      {\n        // NOTE: since we don't include attribute names, we need to be careful not to create another unique index\n        name: identifiers.getUniqueIndexName([contentType.collectionName]),\n        columns: [entityId, componentId, identifiers.FIELD_COLUMN, compTypeColumn],\n        type: 'unique',\n      },\n    ],\n    foreignKeys: [\n      {\n        name: fkIndex,\n        columns: [entityId],\n        referencedColumns: [identifiers.ID_COLUMN],\n        referencedTable: identifiers.getTableName(contentType.collectionName),\n        onDelete: 'CASCADE',\n      },\n    ],\n  };\n};\n\nexport const transformContentTypesToModels = (\n  contentTypes: LoadedContentTypeModel[],\n  identifiers: Identifiers\n): Model[] => {\n  const models: Model[] = [];\n\n  contentTypes.forEach((contentType) => {\n    assert(contentType.collectionName, 'Content type \"collectionName\" is required');\n    assert(contentType.modelName, 'Content type \"modelName\" is required');\n    assert(contentType.uid, 'Content type \"uid\" is required');\n\n    // Add document id to content types\n    // as it is not documented\n    const documentIdAttribute: Record<string, Schema.Attribute.AnyAttribute> =\n      contentType.modelType === 'contentType'\n        ? { documentId: { type: 'string', default: createDocumentId } }\n        : {};\n\n    // TODO: this needs to be combined with getReservedNames, we should not be maintaining two lists\n    // Prevent user from creating a documentId attribute\n    const reservedAttributeNames = ['document_id', identifiers.ID_COLUMN];\n    Object.keys(contentType.attributes || {}).forEach((attributeName) => {\n      const snakeCasedAttributeName = _.snakeCase(attributeName);\n      if (reservedAttributeNames.includes(snakeCasedAttributeName)) {\n        throw new Error(\n          `The attribute \"${attributeName}\" is reserved and cannot be used in a model. Please rename \"${contentType.modelName}\" attribute \"${attributeName}\" to something else.`\n        );\n      }\n    });\n\n    if (hasComponentsOrDz(contentType)) {\n      const compoLinkModel = createCompoLinkModel(contentType, identifiers);\n      models.push(compoLinkModel);\n    }\n\n    const model: Model = {\n      uid: contentType.uid,\n      singularName: contentType.modelName,\n      tableName: contentType.collectionName, // This gets shortened in metadata.loadModels(), so we don't shorten here or it will happen twice\n      attributes: {\n        [identifiers.ID_COLUMN]: {\n          type: 'increments',\n        },\n        ...documentIdAttribute,\n        ...transformAttributes(contentType, identifiers),\n      },\n      indexes: contentType.indexes as Model['indexes'],\n      foreignKeys: contentType.foreignKeys as Model['foreignKeys'],\n      lifecycles: contentType?.lifecycles ?? {},\n    };\n\n    // Add indexes to model\n    if (contentType.modelType === 'contentType') {\n      model.indexes = [\n        ...(model.indexes || []),\n        {\n          name: identifiers.getIndexName([contentType.collectionName, 'documents']),\n          // Filter attributes that are not in the schema\n          columns: ['documentId', 'locale', 'publishedAt']\n            .filter((n) => model.attributes[n])\n            .map((name) => identifiers.getColumnName(_.snakeCase(name))),\n        },\n      ];\n    }\n\n    models.push(model);\n  });\n\n  return models;\n};\n"],"names":["createId","assert","_"],"mappings":"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"}