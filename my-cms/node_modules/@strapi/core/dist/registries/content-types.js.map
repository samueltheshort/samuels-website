{"version":3,"file":"content-types.js","sources":["../../src/registries/content-types.ts"],"sourcesContent":["import { pickBy, has } from 'lodash/fp';\nimport type { UID, Struct } from '@strapi/types';\nimport { createContentType, ContentTypeDefinition } from '../domain/content-type';\nimport { addNamespace, hasNamespace } from './namespace';\n\ntype ContentTypesInput = Record<string, ContentTypeDefinition>;\ntype ContentTypeExtendFn = (contentType: Struct.ContentTypeSchema) => Struct.ContentTypeSchema;\n\nconst validateKeySameToSingularName = (contentTypes: ContentTypesInput) => {\n  for (const ctName of Object.keys(contentTypes)) {\n    const contentType = contentTypes[ctName];\n\n    if (ctName !== contentType.schema.info.singularName) {\n      throw new Error(\n        `The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`\n      );\n    }\n  }\n};\n\nconst contentTypesRegistry = () => {\n  const contentTypes: Record<string, Struct.ContentTypeSchema> = {};\n\n  return {\n    /**\n     * Returns this list of registered contentTypes uids\n     */\n    keys() {\n      return Object.keys(contentTypes);\n    },\n\n    /**\n     * Returns the instance of a contentType. Instantiate the contentType if not already done\n     */\n    get(uid: UID.ContentType) {\n      return contentTypes[uid];\n    },\n\n    /**\n     * Returns a map with all the contentTypes in a namespace\n     */\n    getAll(namespace: string) {\n      return pickBy((_, uid) => hasNamespace(uid, namespace))(contentTypes);\n    },\n\n    /**\n     * Registers a contentType\n     */\n    set(uid: UID.ContentType, contentType: Struct.ContentTypeSchema) {\n      contentTypes[uid] = contentType;\n      return this;\n    },\n\n    /**\n     * Registers a map of contentTypes for a specific namespace\n     */\n    add(namespace: string, newContentTypes: ContentTypesInput) {\n      validateKeySameToSingularName(newContentTypes);\n\n      for (const rawCtName of Object.keys(newContentTypes)) {\n        const uid = addNamespace(rawCtName, namespace);\n\n        if (has(uid, contentTypes)) {\n          throw new Error(`Content-type ${uid} has already been registered.`);\n        }\n\n        contentTypes[uid] = createContentType(uid, newContentTypes[rawCtName]);\n      }\n    },\n\n    /**\n     * Wraps a contentType to extend it\n     */\n    extend(ctUID: UID.ContentType, extendFn: ContentTypeExtendFn) {\n      const currentContentType = this.get(ctUID);\n\n      if (!currentContentType) {\n        throw new Error(`Content-Type ${ctUID} doesn't exist`);\n      }\n\n      extendFn(currentContentType);\n\n      return this;\n    },\n  };\n};\n\nexport default contentTypesRegistry;\n"],"names":["namespace","pickBy","hasNamespace","addNamespace","has","createContentType"],"mappings":";;;;AAQA,MAAM,gCAAgC,CAAC,iBAAoC;AACzE,aAAW,UAAU,OAAO,KAAK,YAAY,GAAG;AACxC,UAAA,cAAc,aAAa,MAAM;AAEvC,QAAI,WAAW,YAAY,OAAO,KAAK,cAAc;AACnD,YAAM,IAAI;AAAA,QACR,6EAA6E,MAAM,QAAQ,YAAY,OAAO,KAAK,YAAY;AAAA,MACjI;AAAA,IAAA;AAAA,EACF;AAEJ;AAEA,MAAM,uBAAuB,MAAM;AACjC,QAAM,eAAyD,CAAC;AAEzD,SAAA;AAAA;AAAA;AAAA;AAAA,IAIL,OAAO;AACE,aAAA,OAAO,KAAK,YAAY;AAAA,IACjC;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAAsB;AACxB,aAAO,aAAa,GAAG;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA,IAKA,OAAOA,aAAmB;AACjB,aAAAC,GAAA,OAAO,CAAC,GAAG,QAAQC,uBAAa,KAAKF,WAAS,CAAC,EAAE,YAAY;AAAA,IACtE;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAAsB,aAAuC;AAC/D,mBAAa,GAAG,IAAI;AACb,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKA,IAAIA,aAAmB,iBAAoC;AACzD,oCAA8B,eAAe;AAE7C,iBAAW,aAAa,OAAO,KAAK,eAAe,GAAG;AAC9C,cAAA,MAAMG,UAAAA,aAAa,WAAWH,WAAS;AAEzC,YAAAI,GAAA,IAAI,KAAK,YAAY,GAAG;AAC1B,gBAAM,IAAI,MAAM,gBAAgB,GAAG,+BAA+B;AAAA,QAAA;AAGpE,qBAAa,GAAG,IAAIC,MAAAA,kBAAkB,KAAK,gBAAgB,SAAS,CAAC;AAAA,MAAA;AAAA,IAEzE;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,OAAwB,UAA+B;AACtD,YAAA,qBAAqB,KAAK,IAAI,KAAK;AAEzC,UAAI,CAAC,oBAAoB;AACvB,cAAM,IAAI,MAAM,gBAAgB,KAAK,gBAAgB;AAAA,MAAA;AAGvD,eAAS,kBAAkB;AAEpB,aAAA;AAAA,IAAA;AAAA,EAEX;AACF;;"}