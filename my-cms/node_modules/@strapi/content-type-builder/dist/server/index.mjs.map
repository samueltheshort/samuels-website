{"version":3,"file":"index.mjs","sources":["../../server/src/config.ts","../../server/src/bootstrap.ts","../../server/src/utils/attributes.ts","../../server/src/services/schema-builder/schema-handler.ts","../../server/src/services/schema-builder/component-builder.ts","../../server/src/services/constants.ts","../../server/src/services/schema-builder/content-type-builder.ts","../../server/src/services/schema-builder/index.ts","../../server/src/services/content-types.ts","../../server/src/services/components.ts","../../server/src/services/component-categories.ts","../../server/src/services/builder.ts","../../server/src/services/api-handler.ts","../../server/src/services/index.ts","../../server/src/utils/index.ts","../../server/src/controllers/builder.ts","../../server/src/controllers/validation/common.ts","../../server/src/controllers/validation/component-category.ts","../../server/src/controllers/component-categories.ts","../../server/src/controllers/validation/types.ts","../../server/src/controllers/validation/relations.ts","../../server/src/controllers/validation/model-schema.ts","../../server/src/utils/typeguards.ts","../../server/src/controllers/validation/data-transform.ts","../../server/src/controllers/validation/component.ts","../../server/src/controllers/components.ts","../../server/src/controllers/validation/content-type.ts","../../server/src/controllers/content-types.ts","../../server/src/controllers/index.ts","../../server/src/routes/admin.ts","../../server/src/routes/content-api.ts","../../server/src/routes/index.ts","../../server/src/index.ts"],"sourcesContent":["export default {\n  default: {},\n  validator() {},\n};\n","import type { Core } from '@strapi/types';\n\nexport default async ({ strapi }: { strapi: Core.Strapi }) => {\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Read',\n      uid: 'read',\n      pluginName: 'content-type-builder',\n    },\n  ];\n\n  await strapi.service('admin::permission').actionProvider.registerMany(actions);\n};\n","import _ from 'lodash';\nimport utils, { errors } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\n\nconst { ApplicationError } = errors;\n\nexport const isConfigurable = (attribute: Schema.Attribute.AnyAttribute) =>\n  _.get(attribute, 'configurable', true);\n\nexport const isRelation = (attribute: Schema.Attribute.AnyAttribute) =>\n  attribute.type === 'relation';\n\n/**\n * Formats a component's attributes\n */\nexport const formatAttributes = (model: any) => {\n  const { getVisibleAttributes } = utils.contentTypes;\n\n  // only get attributes that can be seen in the CTB\n  return getVisibleAttributes(model).reduce((acc: any, key) => {\n    acc[key] = formatAttribute(model.attributes[key]);\n    return acc;\n  }, {});\n};\n\n/**\n * Formats a component attribute\n */\nexport const formatAttribute = (attribute: Schema.Attribute.AnyAttribute & Record<string, any>) => {\n  const { configurable, required, autoPopulate, pluginOptions } = attribute;\n\n  if (attribute.type === 'media') {\n    return {\n      type: 'media',\n      multiple: !!attribute.multiple,\n      required: !!required,\n      configurable: configurable === false ? false : undefined,\n      private: !!attribute.private,\n      allowedTypes: attribute.allowedTypes,\n      pluginOptions,\n    };\n  }\n\n  if (attribute.type === 'relation') {\n    return {\n      ...attribute,\n      type: 'relation',\n      target: attribute.target,\n      targetAttribute: attribute.inversedBy || attribute.mappedBy || null,\n      configurable: configurable === false ? false : undefined,\n      private: !!attribute.private,\n      pluginOptions,\n      // TODO: remove\n      autoPopulate,\n    };\n  }\n\n  return attribute;\n};\n\n// TODO: move to schema builder\nexport const replaceTemporaryUIDs = (uidMap: any) => (schema: any) => {\n  return {\n    ...schema,\n    attributes: Object.keys(schema.attributes).reduce((acc: any, key) => {\n      const attr = schema.attributes[key];\n      if (attr.type === 'component') {\n        if (_.has(uidMap, attr.component)) {\n          acc[key] = {\n            ...attr,\n            component: uidMap[attr.component],\n          };\n\n          return acc;\n        }\n\n        if (!_.has(strapi.components, attr.component)) {\n          throw new ApplicationError('component.notFound');\n        }\n      }\n\n      if (\n        attr.type === 'dynamiczone' &&\n        _.intersection(attr.components, Object.keys(uidMap)).length > 0\n      ) {\n        acc[key] = {\n          ...attr,\n          components: attr.components.map((value: any) => {\n            if (_.has(uidMap, value)) return uidMap[value];\n\n            if (!_.has(strapi.components, value)) {\n              throw new ApplicationError('component.notFound');\n            }\n\n            return value;\n          }),\n        };\n\n        return acc;\n      }\n\n      acc[key] = attr;\n      return acc;\n    }, {}),\n  };\n};\n","import path from 'path';\nimport type { Internal, Struct } from '@strapi/types';\nimport fse from 'fs-extra';\nimport _ from 'lodash';\n\nimport { isConfigurable } from '../../utils/attributes';\n\nexport type Infos = {\n  category?: string;\n  modelName?: string;\n  plugin?: string;\n  uid?: Internal.UID.ContentType;\n  dir: string;\n  filename: string;\n  schema?: Struct.ContentTypeSchema;\n};\n\nexport default function createSchemaHandler(infos: Infos) {\n  const { category, modelName, plugin, uid, dir, filename, schema } = infos;\n\n  const initialState = {\n    modelName,\n    plugin,\n    category,\n    uid,\n    dir,\n    filename,\n    schema:\n      schema ||\n      ({\n        info: {},\n        options: {},\n        attributes: {},\n      } as Struct.ContentTypeSchema),\n  };\n\n  const state = _.cloneDeep(initialState);\n\n  // always keep it the same to rollback\n  Object.freeze(initialState.schema);\n\n  let modified = false;\n  let deleted = false;\n\n  return {\n    get modelName() {\n      return initialState.modelName;\n    },\n\n    get plugin() {\n      return initialState.plugin;\n    },\n\n    get category() {\n      return initialState.category;\n    },\n\n    get kind() {\n      return _.get(state.schema, 'kind', 'collectionType');\n    },\n\n    get uid() {\n      return state.uid;\n    },\n\n    get writable() {\n      return _.get(state, 'plugin') !== 'admin';\n    },\n\n    setUID(val: Internal.UID.ContentType) {\n      modified = true;\n\n      state.uid = val;\n      return this;\n    },\n\n    setDir(val: string) {\n      modified = true;\n\n      state.dir = val;\n      return this;\n    },\n\n    get schema() {\n      return _.cloneDeep(state.schema);\n    },\n\n    setSchema(val: Struct.ContentTypeSchema) {\n      modified = true;\n\n      state.schema = _.cloneDeep(val);\n      return this;\n    },\n\n    // get a particular path inside the schema\n    get(path: string[]) {\n      return _.get(state.schema, path);\n    },\n\n    // set a particular path inside the schema\n    set(path: string[] | string, val: unknown) {\n      if (!state.schema) return this;\n\n      modified = true;\n\n      const value = _.defaultTo(val, _.get(state.schema, path));\n      _.set(state.schema, path, value);\n\n      return this;\n    },\n\n    // delete a particular path inside the schema\n    unset(path: string[]) {\n      modified = true;\n\n      _.unset(state.schema, path);\n\n      return this;\n    },\n\n    delete() {\n      deleted = true;\n      return this;\n    },\n\n    getAttribute(key: string) {\n      return this.get(['attributes', key]);\n    },\n\n    setAttribute(key: string, attribute: any) {\n      return this.set(['attributes', key], attribute);\n    },\n\n    deleteAttribute(key: string) {\n      return this.unset(['attributes', key]);\n    },\n\n    setAttributes(newAttributes: Struct.SchemaAttributes) {\n      if (!this.schema) return this;\n\n      // delete old configurable attributes\n      for (const key in this.schema.attributes) {\n        if (isConfigurable((this.schema.attributes as any)[key])) {\n          this.deleteAttribute(key);\n        }\n      }\n\n      // set new Attributes\n      for (const key of Object.keys(newAttributes)) {\n        this.setAttribute(key, newAttributes[key as keyof Struct.SchemaAttributes]);\n      }\n\n      return this;\n    },\n\n    removeContentType(uid: Internal.UID.ContentType) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attribute = attributes[key];\n\n        if (attribute.target === uid) {\n          this.deleteAttribute(key);\n        }\n      });\n\n      return this;\n    },\n\n    // utils\n    removeComponent(uid: Internal.UID.Component) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.deleteAttribute(key);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attributes[key].components.filter(\n            (val: string) => val !== uid\n          );\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    updateComponent(uid: Internal.UID.Component, newUID: Internal.UID.Component) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.set(['attributes', key, 'component'], newUID);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attr.components.map((val: string) =>\n            val === uid ? newUID : val\n          );\n\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    // save the schema to disk\n    async flush() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      if (deleted) {\n        await fse.remove(initialPath);\n\n        const list = await fse.readdir(initialState.dir);\n        if (list.length === 0) {\n          await fse.remove(initialState.dir);\n        }\n\n        return;\n      }\n\n      if (modified) {\n        if (!state.schema) return Promise.resolve();\n\n        await fse.ensureFile(filePath);\n\n        await fse.writeJSON(\n          filePath,\n          {\n            kind: state.schema.kind,\n            collectionName: state.schema.collectionName,\n            info: state.schema.info,\n            options: state.schema.options,\n            pluginOptions: state.schema.pluginOptions,\n            attributes: state.schema.attributes,\n            config: (state.schema as any).config,\n          },\n          { spaces: 2 }\n        );\n\n        // remove from oldPath\n        if (initialPath !== filePath) {\n          await fse.remove(initialPath);\n\n          const list = await fse.readdir(initialState.dir);\n          if (list.length === 0) {\n            await fse.remove(initialState.dir);\n          }\n        }\n\n        return;\n      }\n\n      return Promise.resolve();\n    },\n\n    // reset the schema to its initial value\n    async rollback() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      // it was a creation so it needs to be deleted\n      if (!initialState.uid) {\n        await fse.remove(filePath);\n\n        const list = await fse.readdir(state.dir);\n        if (list.length === 0) {\n          await fse.remove(state.dir);\n        }\n        return;\n      }\n\n      if (modified || deleted) {\n        await fse.ensureFile(initialPath);\n        await fse.writeJSON(initialPath, initialState.schema, { spaces: 2 });\n\n        // remove\n        if (initialPath !== filePath) {\n          await fse.remove(filePath);\n\n          const list = await fse.readdir(state.dir);\n          if (list.length === 0) {\n            await fse.remove(state.dir);\n          }\n        }\n      }\n\n      return Promise.resolve();\n    },\n  };\n}\n","import path from 'path';\nimport type { Internal } from '@strapi/types';\nimport _ from 'lodash';\nimport pluralize from 'pluralize';\n\nimport { strings, errors } from '@strapi/utils';\nimport { isConfigurable } from '../../utils/attributes';\nimport createSchemaHandler from './schema-handler';\n\nconst { ApplicationError } = errors;\n\nexport default function createComponentBuilder() {\n  return {\n    createComponentUID({ category, displayName }: any) {\n      return `${strings.nameToSlug(category)}.${strings.nameToSlug(displayName)}`;\n    },\n\n    createNewComponentUIDMap(components: object[]) {\n      return components.reduce((uidMap: any, component: any) => {\n        uidMap[component.tmpUID] = this.createComponentUID(component);\n        return uidMap;\n      }, {});\n    },\n\n    /**\n     * create a component in the tmpComponent map\n     */\n    createComponent(this: any, infos: any) {\n      const uid = this.createComponentUID(infos);\n\n      if (this.components.has(uid)) {\n        throw new ApplicationError('component.alreadyExists');\n      }\n\n      const handler = createSchemaHandler({\n        dir: path.join(strapi.dirs.app.components, strings.nameToSlug(infos.category)),\n        filename: `${strings.nameToSlug(infos.displayName)}.json`,\n      });\n\n      // TODO: create a utility for this\n      // Duplicate in admin/src/components/FormModal/forms/utils/createCollectionName.ts\n      const collectionName = `components_${strings.nameToCollectionName(\n        infos.category\n      )}_${strings.nameToCollectionName(pluralize(infos.displayName))}`;\n\n      this.components.forEach((compo: any) => {\n        if (compo.schema.collectionName === collectionName) {\n          throw new ApplicationError('component.alreadyExists');\n        }\n      });\n\n      handler\n        .setUID(uid)\n        .set('collectionName', collectionName)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'icon'], infos.icon)\n        .set(['info', 'description'], infos.description)\n        .set('pluginOptions', infos.pluginOptions)\n        .set('config', infos.config)\n        .setAttributes(this.convertAttributes(infos.attributes));\n\n      if (this.components.size === 0) {\n        strapi.telemetry.send('didCreateFirstComponent');\n      } else {\n        strapi.telemetry.send('didCreateComponent');\n      }\n\n      this.components.set(uid, handler);\n\n      return handler;\n    },\n\n    /**\n     * create a component in the tmpComponent map\n     */\n    editComponent(this: any, infos: any) {\n      const { uid } = infos;\n\n      if (!this.components.has(uid)) {\n        throw new errors.ApplicationError('component.notFound');\n      }\n\n      const component = this.components.get(uid);\n\n      const [, nameUID] = uid.split('.');\n\n      const newCategory = strings.nameToSlug(infos.category);\n      const newUID = `${newCategory}.${nameUID}`;\n\n      if (newUID !== uid && this.components.has(newUID)) {\n        throw new errors.ApplicationError('component.edit.alreadyExists');\n      }\n\n      const newDir = path.join(strapi.dirs.app.components, newCategory);\n\n      const oldAttributes = component.schema.attributes;\n\n      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {\n        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);\n      });\n\n      component\n        .setUID(newUID)\n        .setDir(newDir)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'icon'], infos.icon)\n        .set(['info', 'description'], infos.description)\n        .set('pluginOptions', infos.pluginOptions)\n        .setAttributes(this.convertAttributes(newAttributes));\n\n      if (newUID !== uid) {\n        this.components.forEach((compo: any) => {\n          compo.updateComponent(uid, newUID);\n        });\n\n        this.contentTypes.forEach((ct: any) => {\n          ct.updateComponent(uid, newUID);\n        });\n      }\n\n      return component;\n    },\n\n    deleteComponent(this: any, uid: Internal.UID.Component) {\n      if (!this.components.has(uid)) {\n        throw new errors.ApplicationError('component.notFound');\n      }\n\n      this.components.forEach((compo: any) => {\n        compo.removeComponent(uid);\n      });\n\n      this.contentTypes.forEach((ct: any) => {\n        ct.removeComponent(uid);\n      });\n\n      return this.components.get(uid).delete();\n    },\n  };\n}\n","export const modelTypes = {\n  CONTENT_TYPE: 'CONTENT_TYPE',\n  COMPONENT: 'COMPONENT',\n} as const;\n\nexport const typeKinds = {\n  SINGLE_TYPE: 'singleType',\n  COLLECTION_TYPE: 'collectionType',\n} as const;\n\nexport const DEFAULT_TYPES = [\n  // advanced types\n  'media',\n\n  // scalar types\n  'string',\n  'text',\n  'richtext',\n  'blocks',\n  'json',\n  'enumeration',\n  'password',\n  'email',\n  'integer',\n  'biginteger',\n  'float',\n  'decimal',\n  'date',\n  'time',\n  'datetime',\n  'timestamp',\n  'boolean',\n\n  'relation',\n] as const;\n\nexport const VALID_UID_TARGETS = ['string', 'text'] as const;\n\nexport const coreUids = {\n  STRAPI_USER: 'admin::user',\n  PREFIX: 'strapi::',\n} as const;\n\nexport const pluginsUids = {\n  UPLOAD_FILE: 'plugin::upload.file',\n} as const;\n","import path from 'path';\nimport _ from 'lodash';\n\nimport { strings, errors } from '@strapi/utils';\nimport type { Schema, Internal } from '@strapi/types';\nimport { isRelation, isConfigurable } from '../../utils/attributes';\nimport { typeKinds } from '../constants';\nimport createSchemaHandler from './schema-handler';\nimport { CreateContentTypeInput } from '../../controllers/validation/content-type';\n\nconst { ApplicationError } = errors;\n\nconst reuseUnsetPreviousProperties = (\n  newAttribute: Schema.Attribute.AnyAttribute,\n  oldAttribute: Schema.Attribute.AnyAttribute\n) => {\n  _.defaults(\n    newAttribute,\n    _.omit(oldAttribute, [\n      'configurable',\n      'required',\n      'private',\n      'unique',\n      'pluginOptions',\n      'inversedBy',\n      'mappedBy',\n    ])\n  );\n};\n\nexport default function createComponentBuilder() {\n  return {\n    setRelation(this: any, { key, uid, attribute }: any) {\n      if (!_.has(attribute, 'target')) {\n        return;\n      }\n\n      const targetCT = this.contentTypes.get(attribute.target);\n      const targetAttribute = targetCT.getAttribute(attribute.targetAttribute);\n\n      if (!attribute.targetAttribute) {\n        return;\n      }\n\n      targetCT.setAttribute(\n        attribute.targetAttribute,\n        generateRelation({ key, attribute, uid, targetAttribute })\n      );\n    },\n\n    unsetRelation(this: any, attribute: any) {\n      if (!_.has(attribute, 'target')) {\n        return;\n      }\n\n      const targetCT = this.contentTypes.get(attribute.target);\n\n      const targetAttributeName = attribute.inversedBy || attribute.mappedBy;\n      const targetAttribute = targetCT.getAttribute(targetAttributeName);\n\n      if (!targetAttribute) return;\n\n      return targetCT.deleteAttribute(targetAttributeName);\n    },\n\n    /**\n     * Creates a content type in memory to be written to files later on\n     */\n    createContentType(this: any, infos: CreateContentTypeInput) {\n      const uid = createContentTypeUID(infos);\n\n      if (this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.alreadyExists');\n      }\n\n      const contentType = createSchemaHandler({\n        modelName: infos.singularName,\n        dir: path.join(\n          strapi.dirs.app.api,\n          infos.singularName,\n          'content-types',\n          infos.singularName\n        ),\n        filename: `schema.json`,\n      });\n\n      this.contentTypes.set(uid, contentType);\n\n      // support self referencing content type relation\n      Object.keys(infos.attributes).forEach((key) => {\n        const { target } = infos.attributes[key];\n        if (target === '__self__') {\n          infos.attributes[key].target = uid;\n        }\n      });\n\n      contentType\n        .setUID(uid)\n        .set('kind', infos.kind || typeKinds.COLLECTION_TYPE)\n        .set(\n          'collectionName',\n          infos.collectionName || strings.nameToCollectionName(infos.pluralName)\n        )\n        .set('info', {\n          singularName: infos.singularName,\n          pluralName: infos.pluralName,\n          displayName: infos.displayName,\n          description: infos.description,\n        })\n        .set('options', {\n          ...(infos.options ?? {}),\n          draftAndPublish: infos.draftAndPublish,\n        })\n        .set('pluginOptions', infos.pluginOptions)\n        .set('config', infos.config)\n        .setAttributes(this.convertAttributes(infos.attributes));\n\n      Object.keys(infos.attributes).forEach((key) => {\n        const attribute = infos.attributes[key];\n\n        if (isRelation(attribute)) {\n          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {\n            if (attribute.target === uid && attribute.targetAttribute !== undefined) {\n              // self referencing relation\n              const targetAttribute = infos.attributes[attribute.targetAttribute];\n\n              if (targetAttribute.dominant === undefined) {\n                attribute.dominant = true;\n              } else {\n                attribute.dominant = false;\n              }\n            } else {\n              attribute.dominant = true;\n            }\n          }\n\n          this.setRelation({\n            key,\n            uid,\n            attribute,\n          });\n        }\n      });\n\n      return contentType;\n    },\n\n    editContentType(this: any, infos: any) {\n      const { uid } = infos;\n\n      if (!this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.notFound');\n      }\n\n      const contentType = this.contentTypes.get(uid);\n\n      const oldAttributes = contentType.schema.attributes;\n\n      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {\n        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);\n      });\n\n      const newKeys = _.difference(Object.keys(newAttributes), Object.keys(oldAttributes));\n      const deletedKeys = _.difference(Object.keys(oldAttributes), Object.keys(newAttributes));\n      const remainingKeys = _.intersection(Object.keys(oldAttributes), Object.keys(newAttributes));\n\n      // remove old relations\n      deletedKeys.forEach((key) => {\n        const attribute = oldAttributes[key];\n\n        const targetAttributeName = attribute.inversedBy || attribute.mappedBy;\n\n        // if the old relation has a target attribute. we need to remove it in the target type\n        if (isConfigurable(attribute) && isRelation(attribute) && !_.isNil(targetAttributeName)) {\n          this.unsetRelation(attribute);\n        }\n      });\n\n      remainingKeys.forEach((key) => {\n        const oldAttribute = oldAttributes[key];\n        const newAttribute = newAttributes[key];\n\n        if (!isRelation(oldAttribute) && isRelation(newAttribute)) {\n          return this.setRelation({\n            key,\n            uid,\n            attribute: newAttributes[key],\n          });\n        }\n\n        if (isRelation(oldAttribute) && !isRelation(newAttribute)) {\n          return this.unsetRelation(oldAttribute);\n        }\n\n        if (isRelation(oldAttribute) && isRelation(newAttribute)) {\n          const oldTargetAttributeName = oldAttribute.inversedBy || oldAttribute.mappedBy;\n\n          const sameRelation = oldAttribute.relation === newAttribute.relation;\n          const targetAttributeHasChanged = oldTargetAttributeName !== newAttribute.targetAttribute;\n\n          if (!sameRelation || targetAttributeHasChanged) {\n            this.unsetRelation(oldAttribute);\n          }\n\n          // keep extra options that were set manually on oldAttribute\n          reuseUnsetPreviousProperties(newAttribute, oldAttribute);\n\n          if (oldAttribute.inversedBy) {\n            newAttribute.dominant = true;\n          } else if (oldAttribute.mappedBy) {\n            newAttribute.dominant = false;\n          }\n\n          return this.setRelation({\n            key,\n            uid,\n            attribute: newAttribute,\n          });\n        }\n      });\n\n      // add new relations\n      newKeys.forEach((key) => {\n        const attribute = newAttributes[key];\n\n        if (isRelation(attribute)) {\n          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {\n            if (attribute.target === uid && attribute.targetAttribute !== undefined) {\n              // self referencing relation\n              const targetAttribute = newAttributes[attribute.targetAttribute];\n\n              if (targetAttribute.dominant === undefined) {\n                attribute.dominant = true;\n              } else {\n                attribute.dominant = false;\n              }\n            } else {\n              attribute.dominant = true;\n            }\n          }\n\n          this.setRelation({\n            key,\n            uid,\n            attribute,\n          });\n        }\n      });\n\n      contentType\n        .set('kind', infos.kind || contentType.schema.kind)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'description'], infos.description)\n        .set('options', {\n          ...(infos.options ?? {}),\n          draftAndPublish: infos.draftAndPublish,\n        })\n        .set('pluginOptions', infos.pluginOptions)\n        .setAttributes(this.convertAttributes(newAttributes));\n\n      return contentType;\n    },\n\n    deleteContentType(this: any, uid: string) {\n      if (!this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.notFound');\n      }\n\n      this.components.forEach((compo: any) => {\n        compo.removeContentType(uid);\n      });\n\n      this.contentTypes.forEach((ct: any) => {\n        ct.removeContentType(uid);\n      });\n\n      return this.contentTypes.get(uid).delete();\n    },\n  };\n}\n\n/**\n * Returns a uid from a content type infos\n *\n * @param {object} options options\n * @param {string} options.singularName content-type singularName\n * @returns {string} uid\n */\nconst createContentTypeUID = ({\n  singularName,\n}: {\n  singularName: string;\n}): Internal.UID.ContentType => `api::${singularName}.${singularName}`;\n\nconst generateRelation = ({ key, attribute, uid, targetAttribute = {} }: any) => {\n  const opts: any = {\n    type: 'relation',\n    target: uid,\n    autoPopulate: targetAttribute.autoPopulate,\n    private: targetAttribute.private || undefined,\n    pluginOptions: targetAttribute.pluginOptions || undefined,\n  };\n\n  switch (attribute.relation) {\n    case 'oneToOne': {\n      opts.relation = 'oneToOne';\n\n      if (attribute.dominant) {\n        opts.mappedBy = key;\n      } else {\n        opts.inversedBy = key;\n      }\n      break;\n    }\n    case 'oneToMany': {\n      opts.relation = 'manyToOne';\n      opts.inversedBy = key;\n      break;\n    }\n    case 'manyToOne': {\n      opts.relation = 'oneToMany';\n      opts.mappedBy = key;\n      break;\n    }\n    case 'manyToMany': {\n      opts.relation = 'manyToMany';\n\n      if (attribute.dominant) {\n        opts.mappedBy = key;\n      } else {\n        opts.inversedBy = key;\n      }\n\n      break;\n    }\n    default:\n  }\n\n  // we do this just to make sure we have the same key order when writing to files\n  const { type, relation, target, ...restOptions } = opts;\n\n  return {\n    type,\n    relation,\n    target,\n    ...restOptions,\n  };\n};\n","import { join } from 'path';\nimport _ from 'lodash';\n\nimport { errors } from '@strapi/utils';\nimport createSchemaHandler from './schema-handler';\nimport createComponentBuilder from './component-builder';\nimport createContentTypeBuilder from './content-type-builder';\n\n/**\n * Creates a content type schema builder instance\n */\nexport default function createBuilder() {\n  const components = Object.values(strapi.components).map((componentInput) => ({\n    category: componentInput.category,\n    modelName: componentInput.modelName,\n    plugin: componentInput.modelName,\n    uid: componentInput.uid,\n    filename: componentInput.__filename__,\n    dir: join(strapi.dirs.app.components, componentInput.category),\n    schema: componentInput.__schema__,\n    config: componentInput.config,\n  }));\n\n  const contentTypes = Object.values<any>(strapi.contentTypes).map((contentTypeInput) => {\n    const dir = contentTypeInput.plugin\n      ? join(\n          strapi.dirs.app.extensions,\n          contentTypeInput.plugin,\n          'content-types',\n          contentTypeInput.info.singularName\n        )\n      : join(\n          strapi.dirs.app.api,\n          contentTypeInput.apiName,\n          'content-types',\n          contentTypeInput.info.singularName\n        );\n\n    return {\n      modelName: contentTypeInput.modelName,\n      plugin: contentTypeInput.plugin,\n      uid: contentTypeInput.uid,\n      filename: 'schema.json',\n      dir,\n      schema: contentTypeInput.__schema__,\n      config: contentTypeInput.config,\n    };\n  });\n\n  return createSchemaBuilder({\n    components,\n    contentTypes,\n  });\n}\n\ntype SchemaBuilderOptions = {\n  components: any;\n  contentTypes: any;\n};\n\nfunction createSchemaBuilder({ components, contentTypes }: SchemaBuilderOptions) {\n  const tmpComponents = new Map();\n  const tmpContentTypes = new Map();\n\n  // init temporary ContentTypes\n  Object.keys(contentTypes).forEach((key) => {\n    tmpContentTypes.set(contentTypes[key].uid, createSchemaHandler(contentTypes[key]));\n  });\n\n  // init temporary components\n  Object.keys(components).forEach((key) => {\n    tmpComponents.set(components[key].uid, createSchemaHandler(components[key]));\n  });\n\n  return {\n    get components() {\n      return tmpComponents;\n    },\n    get contentTypes() {\n      return tmpContentTypes;\n    },\n\n    /**\n     * Convert Attributes received from the API to the right syntax\n     */\n    convertAttributes(attributes: any) {\n      return Object.keys(attributes).reduce(\n        (acc, key) => {\n          const attribute = attributes[key];\n\n          const { configurable, private: isPrivate } = attribute;\n\n          const baseProperties = {\n            private: isPrivate === true ? true : undefined,\n            configurable: configurable === false ? false : undefined,\n          };\n\n          if (attribute.type === 'relation') {\n            const { target, relation, targetAttribute, dominant, ...restOfProperties } = attribute;\n\n            const attr = {\n              type: 'relation',\n              relation,\n              target,\n              ...restOfProperties,\n              ...baseProperties,\n            };\n\n            acc[key] = attr;\n\n            if (target && !this.contentTypes.has(target)) {\n              throw new errors.ApplicationError(`target: ${target} does not exist`);\n            }\n\n            if (_.isNil(targetAttribute)) {\n              return acc;\n            }\n\n            if (['oneToOne', 'manyToMany'].includes(relation) && dominant === true) {\n              attr.inversedBy = targetAttribute;\n            } else if (['oneToOne', 'manyToMany'].includes(relation) && dominant === false) {\n              attr.mappedBy = targetAttribute;\n            } else if (['oneToOne', 'manyToOne', 'manyToMany'].includes(relation)) {\n              attr.inversedBy = targetAttribute;\n            } else if (['oneToMany'].includes(relation)) {\n              attr.mappedBy = targetAttribute;\n            }\n\n            return acc;\n          }\n\n          acc[key] = {\n            ...attribute,\n            ...baseProperties,\n          };\n\n          return acc;\n        },\n        {} as Record<string, unknown>\n      );\n    },\n\n    ...createComponentBuilder(),\n    ...createContentTypeBuilder(),\n\n    /**\n     * Write all type to files\n     */\n    writeFiles() {\n      const schemas = [\n        ...Array.from(tmpComponents.values()),\n        ...Array.from(tmpContentTypes.values()),\n      ];\n\n      return Promise.all(schemas.map((schema) => schema.flush()))\n        .catch((error) => {\n          strapi.log.error('Error writing schema files');\n          strapi.log.error(error);\n          return this.rollback();\n        })\n        .catch((error) => {\n          strapi.log.error(\n            'Error rolling back schema files. You might need to fix your files manually'\n          );\n          strapi.log.error(error);\n\n          throw new errors.ApplicationError('Invalid schema edition');\n        });\n    },\n\n    /**\n     * rollback all files\n     */\n    rollback() {\n      return Promise.all(\n        [...Array.from(tmpComponents.values()), ...Array.from(tmpContentTypes.values())].map(\n          (schema) => schema.rollback()\n        )\n      );\n    },\n  };\n}\n","import _ from 'lodash';\nimport { getOr } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils, errors } from '@strapi/utils';\nimport type { UID, Struct } from '@strapi/types';\nimport { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';\nimport createBuilder from './schema-builder';\nimport { coreUids, pluginsUids } from './constants';\n\nconst { ApplicationError } = errors;\n\nexport const isContentTypeVisible = (model: Struct.ContentTypeSchema) =>\n  getOr(true, 'pluginOptions.content-type-builder.visible', model) === true;\n\nexport const getRestrictRelationsTo = (contentType: Struct.ContentTypeSchema) => {\n  const { uid } = contentType;\n  if (uid === coreUids.STRAPI_USER) {\n    // TODO: replace with an obj { relation: 'x', bidirectional: true|false }\n    return ['oneWay', 'manyWay'];\n  }\n\n  if (\n    uid.startsWith(coreUids.PREFIX) ||\n    uid === pluginsUids.UPLOAD_FILE ||\n    !isContentTypeVisible(contentType)\n  ) {\n    return [];\n  }\n\n  return null;\n};\n\n/**\n * Format a contentType info to be used by the front-end\n */\nexport const formatContentType = (contentType: any) => {\n  const { uid, kind, modelName, plugin, collectionName, info } = contentType;\n\n  return {\n    uid,\n    plugin,\n    apiID: modelName,\n    schema: {\n      ...contentTypesUtils.getOptions(contentType),\n      displayName: info.displayName,\n      singularName: info.singularName,\n      pluralName: info.pluralName,\n      description: _.get(info, 'description', ''),\n      pluginOptions: contentType.pluginOptions,\n      kind: kind || 'collectionType',\n      collectionName,\n      attributes: formatAttributes(contentType),\n      visible: isContentTypeVisible(contentType),\n      restrictRelationsTo: getRestrictRelationsTo(contentType),\n    },\n  };\n};\n\nexport const createContentTypes = async (contentTypes: any[]) => {\n  const builder = createBuilder();\n  const createdContentTypes: any[] = [];\n\n  for (const contentType of contentTypes) {\n    createdContentTypes.push(await createContentType(contentType, { defaultBuilder: builder }));\n  }\n\n  await builder.writeFiles();\n\n  return createdContentTypes;\n};\n\ntype CreateContentTypeOptions = {\n  defaultBuilder?: any; // TODO\n};\n\n/**\n * Creates a content type and handle the nested components sent with it\n */\nexport const createContentType = async (\n  { contentType, components }: any,\n  options: CreateContentTypeOptions = {}\n) => {\n  const builder = options.defaultBuilder || createBuilder();\n  const uidMap = builder.createNewComponentUIDMap(components || []);\n\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newContentType = builder.createContentType(replaceTmpUIDs(contentType));\n\n  // allow components to target the new contentType\n  const targetContentType = (infos: any) => {\n    Object.keys(infos.attributes).forEach((key) => {\n      const { target } = infos.attributes[key];\n      if (target === '__contentType__') {\n        infos.attributes[key].target = newContentType.uid;\n      }\n    });\n\n    return infos;\n  };\n\n  components?.forEach((component: any) => {\n    const options = replaceTmpUIDs(targetContentType(component));\n\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(options);\n    }\n\n    return builder.editComponent(options);\n  });\n\n  // generate api skeleton\n  await generateAPI({\n    displayName: contentType!.displayName || contentType!.info.displayName,\n    singularName: contentType!.singularName,\n    pluralName: contentType!.pluralName,\n    kind: contentType!.kind,\n  });\n\n  if (!options.defaultBuilder) {\n    await builder.writeFiles();\n  }\n\n  strapi.eventHub.emit('content-type.create', { contentType: newContentType });\n\n  return newContentType;\n};\n\n/**\n * Generate an API skeleton\n */\nexport const generateAPI = ({\n  singularName,\n  kind = 'collectionType',\n  pluralName,\n  displayName,\n}: any) => {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const strapiGenerators = require('@strapi/generators');\n  return strapiGenerators.generate(\n    'content-type',\n    {\n      kind,\n      singularName,\n      id: singularName,\n      pluralName,\n      displayName,\n      destination: 'new',\n      bootstrapApi: true,\n      attributes: [],\n    },\n    { dir: strapi.dirs.app.root }\n  );\n};\n\n/**\n * Edits a contentType and handle the nested contentTypes sent with it\n */\nexport const editContentType = async (\n  uid: UID.ContentType,\n  { contentType, components = [] }: any\n) => {\n  const builder = createBuilder();\n\n  const previousSchema = builder.contentTypes.get(uid).schema;\n  const previousKind = previousSchema.kind;\n  const newKind = contentType.kind || previousKind;\n\n  // Restore non-visible attributes from previous schema\n  const previousAttributes = previousSchema.attributes;\n  const prevNonVisibleAttributes = contentTypesUtils\n    .getNonVisibleAttributes(previousSchema)\n    .reduce((acc, key) => {\n      if (key in previousAttributes) {\n        acc[key] = previousAttributes[key];\n      }\n\n      return acc;\n    }, {} as any);\n  contentType.attributes = _.merge(prevNonVisibleAttributes, contentType.attributes);\n\n  if (newKind !== previousKind && newKind === 'singleType') {\n    const entryCount = await strapi.db.query(uid).count();\n    if (entryCount > 1) {\n      throw new ApplicationError(\n        'You cannot convert a collectionType to a singleType when having multiple entries in DB'\n      );\n    }\n  }\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedContentType = builder.editContentType({\n    uid,\n    ...replaceTmpUIDs(contentType),\n  });\n\n  components.forEach((component: any) => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  if (newKind !== previousKind) {\n    const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n    await apiHandler.backup(uid);\n\n    try {\n      await apiHandler.clear(uid);\n\n      // generate new api skeleton\n      await generateAPI({\n        displayName: updatedContentType.schema.info.displayName,\n        singularName: updatedContentType.schema.info.singularName,\n        pluralName: updatedContentType.schema.info.pluralName,\n        kind: updatedContentType.schema.kind,\n      });\n\n      await builder.writeFiles();\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n\n    return updatedContentType;\n  }\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('content-type.update', { contentType: updatedContentType });\n\n  return updatedContentType;\n};\n\nexport const deleteContentTypes = async (uids: UID.ContentType[]) => {\n  const builder = createBuilder();\n  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n\n  for (const uid of uids) {\n    await deleteContentType(uid, builder);\n  }\n\n  await builder.writeFiles();\n  for (const uid of uids) {\n    try {\n      await apiHandler.clear(uid);\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n  }\n};\n\n/**\n * Deletes a content type and the api files related to it\n */\nexport const deleteContentType = async (uid: UID.ContentType, defaultBuilder: any = undefined) => {\n  const builder = defaultBuilder || createBuilder();\n  // make a backup\n  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n  await apiHandler.backup(uid);\n\n  const contentType = builder.deleteContentType(uid);\n\n  if (!defaultBuilder) {\n    try {\n      await builder.writeFiles();\n      await apiHandler.clear(uid);\n    } catch (error) {\n      await apiHandler.rollback(uid);\n    }\n  }\n\n  strapi.eventHub.emit('content-type.delete', { contentType });\n\n  return contentType;\n};\n","import type { Internal, Struct } from '@strapi/types';\nimport { get, has } from 'lodash';\n\nimport { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';\nimport createBuilder from './schema-builder';\n\n/**\n * Formats a component attributes\n */\nexport const formatComponent = (component: any) => {\n  const { uid, modelName, connection, collectionName, info, category } = component;\n\n  return {\n    uid,\n    category,\n    apiId: modelName,\n    schema: {\n      displayName: get(info, 'displayName'),\n      description: get(info, 'description', ''),\n      icon: get(info, 'icon'),\n      connection,\n      collectionName,\n      pluginOptions: component.pluginOptions,\n      attributes: formatAttributes(component),\n    },\n  };\n};\n\n/**\n * Creates a component and handle the nested components sent with it\n */\nexport const createComponent = async ({ component, components = [] }: any) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newComponent = builder.createComponent(replaceTmpUIDs(component));\n\n  components.forEach((component: any) => {\n    if (!has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.create', { component: newComponent });\n\n  return newComponent;\n};\n\ntype ComponentToCreate = {\n  component: Struct.ComponentSchema;\n  components?: Struct.ComponentSchema[];\n};\n\nexport const editComponent = async (\n  uid: Internal.UID.Component,\n  { component, components = [] }: ComponentToCreate\n) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedComponent = builder.editComponent({\n    uid,\n    ...replaceTmpUIDs(component),\n  });\n\n  components.forEach((component) => {\n    if (!has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.update', { component: updatedComponent });\n\n  return updatedComponent;\n};\n\nexport const deleteComponent = async (uid: Internal.UID.Component) => {\n  const builder = createBuilder();\n\n  const deletedComponent = builder.deleteComponent(uid);\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.delete', { component: deletedComponent });\n\n  return deletedComponent;\n};\n","import { join } from 'path';\nimport { strings, errors } from '@strapi/utils';\nimport type { Struct } from '@strapi/types';\nimport createBuilder from './schema-builder';\n\ntype Infos = {\n  name: string;\n};\n\ninterface WorkingComponent extends Struct.ComponentSchema {\n  setUID: (uid: string) => WorkingComponent;\n  setDir: (dir: string) => WorkingComponent;\n  updateComponent: (oldUID: string, newUID: string) => void;\n}\n\n/**\n * Edit a category name and move components to the write folder\n */\nexport const editCategory = async (name: string, infos: Infos) => {\n  const newName = strings.nameToSlug(infos.name);\n\n  // don't do anything the name doesn't change\n  if (name === newName) return;\n\n  if (!categoryExists(name)) {\n    throw new errors.ApplicationError('category not found');\n  }\n\n  if (categoryExists(newName)) {\n    throw new errors.ApplicationError('Name already taken');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach((component: WorkingComponent) => {\n    const oldUID = component.uid;\n    const newUID = `${newName}.${component.modelName}`;\n\n    // only edit the components in this specific category\n    if (component.category !== name) return;\n\n    component.setUID(newUID).setDir(join(strapi.dirs.app.components, newName));\n\n    builder.components.forEach((compo: WorkingComponent) => {\n      compo.updateComponent(oldUID, newUID);\n    });\n\n    builder.contentTypes.forEach((ct: WorkingComponent) => {\n      ct.updateComponent(oldUID, newUID);\n    });\n  });\n\n  await builder.writeFiles();\n\n  return newName;\n};\n\n/**\n * Deletes a category and its components\n */\nexport const deleteCategory = async (name: string) => {\n  if (!categoryExists(name)) {\n    throw new errors.ApplicationError('category not found');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach((component) => {\n    if (component.category === name) {\n      builder.deleteComponent(component.uid);\n    }\n  });\n\n  await builder.writeFiles();\n};\n\n/**\n * Checks if a category exists\n */\nconst categoryExists = (name: string) => {\n  const matchingIndex = Object.values(strapi.components).findIndex(\n    (component) => component.category === name\n  );\n\n  return matchingIndex > -1;\n};\n","import { snakeCase } from 'lodash/fp';\n\n// use snake_case\nexport const reservedAttributes = [\n  // TODO: these need to come from a centralized place so we don't break things accidentally in the future and can share them outside the CTB, for example on Strapi bootstrap prior to schema db sync\n\n  // ID fields\n  'id',\n  'document_id',\n\n  // Creator fields\n  'created_at',\n  'updated_at',\n  'published_at',\n  'created_by_id',\n  'updated_by_id',\n  // does not actually conflict because the fields are called *_by_id but we'll leave it to avoid confusion\n  'created_by',\n  'updated_by',\n\n  // Used for Strapi functionality\n  'entry_id',\n  'status',\n  'localizations',\n  'meta',\n  'locale',\n  '__component',\n  '__contentType',\n\n  // We support ending with * to denote prefixes\n  'strapi*',\n  '_strapi*',\n  '__strapi*',\n];\n\n// use snake_case\nexport const reservedModels = [\n  'boolean',\n  'date',\n  'date_time',\n  'time',\n  'upload',\n  'document',\n  'then', // no longer an issue but still restricting for being a javascript keyword\n\n  // We support ending with * to denote prefixes\n  'strapi*',\n  '_strapi*',\n  '__strapi*',\n];\n\nexport const getReservedNames = () => {\n  return {\n    models: reservedModels,\n    attributes: reservedAttributes,\n  };\n};\n\n// compare snake case to check the actual column names that will be used in the database\nexport const isReservedModelName = (name: string) => {\n  const snakeCaseName = snakeCase(name);\n  if (reservedModels.includes(snakeCaseName)) {\n    return true;\n  }\n\n  if (\n    reservedModels\n      .filter((key) => key.endsWith('*'))\n      .map((key) => key.slice(0, -1))\n      .some((prefix) => snakeCaseName.startsWith(prefix))\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n// compare snake case to check the actual column names that will be used in the database\nexport const isReservedAttributeName = (name: string) => {\n  const snakeCaseName = snakeCase(name);\n  if (reservedAttributes.includes(snakeCaseName)) {\n    return true;\n  }\n\n  if (\n    reservedAttributes\n      .filter((key) => key.endsWith('*'))\n      .map((key) => key.slice(0, -1))\n      .some((prefix) => snakeCaseName.startsWith(prefix))\n  ) {\n    return true;\n  }\n\n  return false;\n};\n","import * as path from 'path';\nimport * as fse from 'fs-extra';\nimport type { Internal } from '@strapi/types';\n\n/**\n * Deletes the API folder of a contentType\n */\nexport async function clear(uid: Internal.UID.ContentType) {\n  // TODO double check if this is the correct way to get the apiName\n  const { apiName, modelName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n\n  await recursiveRemoveFiles(apiFolder, createDeleteApiFunction(modelName));\n  await deleteBackup(uid);\n}\n\n/**\n * Backups the API folder of a contentType\n * @param {string} uid content type uid\n */\nexport async function backup(uid: Internal.UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  // backup the api folder\n  await fse.copy(apiFolder, backupFolder);\n}\n\n/**\n * Deletes an API backup folder\n */\nasync function deleteBackup(uid: Internal.UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup');\n  const apiBackupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  await fse.remove(apiBackupFolder);\n\n  const list = await fse.readdir(backupFolder);\n  if (list.length === 0) {\n    await fse.remove(backupFolder);\n  }\n}\n\n/**\n * Rollbacks the API folder of a contentType\n */\nexport async function rollback(uid: Internal.UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  try {\n    await fse.access(backupFolder);\n  } catch {\n    throw new Error('Cannot rollback api that was not backed up');\n  }\n\n  await fse.remove(apiFolder);\n  await fse.copy(backupFolder, apiFolder);\n  await deleteBackup(uid);\n}\n\n/**\n * Creates a delete function to clear an api folder\n */\nconst createDeleteApiFunction = (baseName: string) => {\n  /**\n   * Delets a file in an api.\n   * Will only update routes.json instead of deleting it if other routes are present\n   */\n  return async (filePath: string) => {\n    const fileName = path.basename(filePath, path.extname(filePath));\n\n    const isSchemaFile = filePath.endsWith(`${baseName}/schema.json`);\n    if (fileName === baseName || isSchemaFile) {\n      return fse.remove(filePath);\n    }\n  };\n};\n\n/**\n * Deletes a folder recursively using a delete function\n * @param {string} folder folder to delete\n */\nconst recursiveRemoveFiles = async (folder: string, deleteFn: (file: string) => unknown) => {\n  const filesName = await fse.readdir(folder);\n\n  for (const fileName of filesName) {\n    const filePath = path.join(folder, fileName);\n\n    const stat = await fse.stat(filePath);\n\n    if (stat.isDirectory()) {\n      await recursiveRemoveFiles(filePath, deleteFn);\n    } else {\n      await deleteFn(filePath);\n    }\n  }\n\n  const files = await fse.readdir(folder);\n  if (files.length === 0) {\n    await fse.remove(folder);\n  }\n};\n","import * as contentTypes from './content-types';\nimport * as components from './components';\nimport * as componentCategories from './component-categories';\nimport * as builder from './builder';\nimport * as apiHandler from './api-handler';\n\nexport default {\n  'content-types': contentTypes,\n  components,\n  'component-categories': componentCategories,\n  builder,\n  'api-handler': apiHandler,\n};\n","import type * as components from '../services/components';\nimport type * as builder from '../services/builder';\nimport type * as contentTypes from '../services/content-types';\nimport type * as componentCategories from '../services/component-categories';\nimport type * as apiHandler from '../services/api-handler';\n\ntype S = {\n  'content-types': typeof contentTypes;\n  components: typeof components;\n  'component-categories': typeof componentCategories;\n  builder: typeof builder;\n  'api-handler': typeof apiHandler;\n};\n\nexport function getService<T extends keyof S>(\n  name: T\n): S[T] extends (...args: any[]) => any ? ReturnType<S[T]> : S[T] {\n  return strapi.plugin('content-type-builder').service(name);\n}\n","import type { Context } from 'koa';\nimport { getService } from '../utils';\n\nexport default {\n  getReservedNames(ctx: Context) {\n    ctx.body = getService('builder').getReservedNames();\n  },\n};\n","/* eslint-disable no-template-curly-in-string */\nimport { yup, strings } from '@strapi/utils';\nimport _ from 'lodash';\nimport { TestConfig } from 'yup';\n\nexport const validators = {\n  required: yup.boolean(),\n  unique: yup.boolean(),\n  minLength: yup.number().integer().positive(),\n  maxLength: yup.number().integer().positive(),\n};\n\nexport const NAME_REGEX = /^[A-Za-z][_0-9A-Za-z]*$/;\nexport const COLLECTION_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;\nexport const CATEGORY_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;\nexport const ICON_REGEX = /^[A-Za-z0-9][-A-Za-z0-9]*$/;\nexport const UID_REGEX = /^[A-Za-z0-9-_.~]*$/;\n\nexport type CommonTestConfig = TestConfig<unknown | undefined, Record<string, unknown>>;\n\nexport const isValidName: CommonTestConfig = {\n  name: 'isValidName',\n  message: `\\${path} must match the following regex: ${NAME_REGEX}`,\n  test: (val: unknown) => val === '' || NAME_REGEX.test(val as string),\n};\n\nexport const isValidIcon: CommonTestConfig = {\n  name: 'isValidIcon',\n  message: `\\${path} is not a valid icon name. Make sure your icon name starts with an alphanumeric character and only includes alphanumeric characters or dashes.`,\n  test: (val) => val === '' || ICON_REGEX.test(val as string),\n};\n\nexport const isValidUID: CommonTestConfig = {\n  name: 'isValidUID',\n  message: `\\${path} must match the following regex: ${UID_REGEX}`,\n  test: (val) => val === '' || UID_REGEX.test(val as string),\n};\n\nexport const isValidCategoryName: CommonTestConfig = {\n  name: 'isValidCategoryName',\n  message: `\\${path} must match the following regex: ${CATEGORY_NAME_REGEX}`,\n  test: (val) => val === '' || CATEGORY_NAME_REGEX.test(val as string),\n};\n\nexport const isValidCollectionName: CommonTestConfig = {\n  name: 'isValidCollectionName',\n  message: `\\${path} must match the following regex: ${COLLECTION_NAME_REGEX}`,\n  test: (val) => val === '' || COLLECTION_NAME_REGEX.test(val as string),\n};\n\nexport const isValidKey = (key: string): CommonTestConfig => ({\n  name: 'isValidKey',\n  message: `Attribute name '${key}' must match the following regex: ${NAME_REGEX}`,\n  test: () => NAME_REGEX.test(key),\n});\n\nexport const isValidEnum: CommonTestConfig = {\n  name: 'isValidEnum',\n  message: '${path} should not start with number',\n  test: (val) => val === '' || !strings.startsWithANumber(val as string),\n};\n\nexport const areEnumValuesUnique: CommonTestConfig = {\n  name: 'areEnumValuesUnique',\n  message: '${path} cannot contain duplicate values',\n  test(values) {\n    const filtered = [...new Set(values as string[])];\n\n    return filtered.length === (values as string[]).length;\n  },\n};\n\nexport const isValidRegExpPattern: CommonTestConfig = {\n  name: 'isValidRegExpPattern',\n  message: '${path} must be a valid RexExp pattern string',\n  test: (val) => val === '' || !!new RegExp(val as string),\n};\n\nexport const isValidDefaultJSON: CommonTestConfig = {\n  name: 'isValidDefaultJSON',\n  message: '${path} is not a valid JSON',\n  test(val) {\n    if (val === undefined) {\n      return true;\n    }\n\n    if (_.isNumber(val) || _.isNull(val) || _.isObject(val) || _.isArray(val)) {\n      return true;\n    }\n\n    try {\n      JSON.parse(val as string);\n\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\nimport { isValidCategoryName } from './common';\n\nconst componentCategorySchema = yup\n  .object({\n    name: yup.string().min(3).test(isValidCategoryName).required('name.required'),\n  })\n  .noUnknown();\n\nexport default validateYupSchema(componentCategorySchema);\n","import type { Context } from 'koa';\nimport { getService } from '../utils';\nimport validateComponentCategory from './validation/component-category';\n\nexport default {\n  async editCategory(ctx: Context) {\n    const body = ctx.request.body as any;\n\n    try {\n      await validateComponentCategory(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService = getService('component-categories');\n\n    const newName = await componentCategoryService.editCategory(name, body);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name: newName });\n  },\n\n  async deleteCategory(ctx: Context) {\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService = getService('component-categories');\n\n    await componentCategoryService.deleteCategory(name);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name });\n  },\n};\n","import _ from 'lodash';\nimport { yup } from '@strapi/utils';\n\nimport type { TestContext } from 'yup';\nimport type { Schema, Struct } from '@strapi/types';\n\nimport { modelTypes, VALID_UID_TARGETS } from '../../services/constants';\nimport {\n  validators,\n  areEnumValuesUnique,\n  isValidDefaultJSON,\n  isValidName,\n  isValidEnum,\n  isValidUID,\n  isValidRegExpPattern,\n} from './common';\n\nexport type GetTypeValidatorOptions = {\n  types: ReadonlyArray<string>;\n  attributes?: Struct.SchemaAttributes;\n  modelType?: (typeof modelTypes)[keyof typeof modelTypes];\n};\n\nconst maxLengthIsGreaterThanOrEqualToMinLength = {\n  name: 'isGreaterThanMin',\n  message: 'maxLength must be greater or equal to minLength',\n  test(this: TestContext, value: unknown) {\n    const { minLength } = this.parent;\n    return !(!_.isUndefined(minLength) && !_.isUndefined(value) && (value as number) < minLength);\n  },\n};\n\nexport const getTypeValidator = (\n  attribute: Schema.Attribute.AnyAttribute,\n  { types, modelType, attributes }: GetTypeValidatorOptions\n) => {\n  return yup.object({\n    type: yup\n      .string()\n      .oneOf([...types])\n      .required(),\n    configurable: yup.boolean().nullable(),\n    private: yup.boolean().nullable(),\n    pluginOptions: yup.object(),\n    ...getTypeShape(attribute, { modelType, attributes }),\n  } as any);\n};\n\nconst getTypeShape = (attribute: Schema.Attribute.AnyAttribute, { attributes }: any = {}) => {\n  switch (attribute.type) {\n    /**\n     * complex types\n     */\n\n    case 'media': {\n      return {\n        multiple: yup.boolean(),\n        required: validators.required,\n        allowedTypes: yup\n          .array()\n          .of(yup.string().oneOf(['images', 'videos', 'files', 'audios']))\n          .min(1),\n      };\n    }\n\n    case 'uid': {\n      return {\n        required: validators.required,\n        targetField: yup\n          .string()\n          .oneOf(\n            Object.keys(attributes!).filter((key) =>\n              VALID_UID_TARGETS.includes(_.get(attributes![key] as any, 'type'))\n            )\n          )\n          .nullable(),\n        default: yup\n          .string()\n          .test(\n            'isValidDefaultUID',\n            'cannot define a default UID if the targetField is set',\n            function (value) {\n              const { targetField } = this.parent;\n              return !!(_.isNil(targetField) || _.isNil(value));\n            }\n          )\n          .test(isValidUID),\n        minLength: validators.minLength,\n        maxLength: validators.maxLength.max(256).test(maxLengthIsGreaterThanOrEqualToMinLength),\n        options: yup.object().shape({\n          separator: yup.string(),\n          lowercase: yup.boolean(),\n          decamelize: yup.boolean(),\n          customReplacements: yup.array().of(yup.array().of(yup.string()).min(2).max(2)),\n          preserveLeadingUnderscore: yup.boolean(),\n        }),\n      };\n    }\n\n    /**\n     * scalar types\n     */\n    case 'string':\n    case 'text': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        unique: validators.unique,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n        regex: yup.string().test(isValidRegExpPattern),\n      };\n    }\n    case 'richtext': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'blocks': {\n      return {\n        required: validators.required,\n      };\n    }\n    case 'json': {\n      return {\n        default: yup.mixed().test(isValidDefaultJSON),\n        required: validators.required,\n      };\n    }\n    case 'enumeration': {\n      return {\n        enum: yup\n          .array()\n          .of(yup.string().test(isValidEnum).required())\n          .min(1)\n          .test(areEnumValuesUnique)\n          .required(),\n        default: yup.string().when('enum', (enumVal) => yup.string().oneOf(enumVal)),\n        enumName: yup.string().test(isValidName),\n        required: validators.required,\n      };\n    }\n    case 'password': {\n      return {\n        required: validators.required,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'email': {\n      return {\n        default: yup.string().email(),\n        required: validators.required,\n        unique: validators.unique,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'integer': {\n      return {\n        default: yup.number().integer(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number().integer(),\n        max: yup.number().integer(),\n      };\n    }\n    case 'biginteger': {\n      return {\n        default: yup.string().nullable().matches(/^\\d*$/),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.string().nullable().matches(/^\\d*$/),\n        max: yup.string().nullable().matches(/^\\d*$/),\n      };\n    }\n    case 'float': {\n      return {\n        default: yup.number(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n    case 'decimal': {\n      return {\n        default: yup.number(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n    case 'time':\n    case 'datetime':\n    case 'date': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        unique: validators.unique,\n      };\n    }\n    case 'boolean': {\n      return {\n        default: yup.boolean(),\n        required: validators.required,\n      };\n    }\n\n    case 'component': {\n      return {\n        required: validators.required,\n        repeatable: yup.boolean(),\n        // TODO: Add correct server validation for nested components\n        component: yup.string().required(),\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n\n    case 'dynamiczone': {\n      return {\n        required: validators.required,\n        components: yup\n          .array()\n          .of(yup.string().required())\n          .test('isArray', '${path} must be an array', (value) => Array.isArray(value))\n          .min(1),\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n\n    default: {\n      return {};\n    }\n  }\n};\n","import { isUndefined } from 'lodash/fp';\nimport { yup } from '@strapi/utils';\nimport type { TestContext, TestFunction } from 'yup';\nimport type { Schema, UID } from '@strapi/types';\nimport { typeKinds, coreUids } from '../../services/constants';\nimport { isValidName } from './common';\n\nconst STRAPI_USER_RELATIONS = ['oneToOne', 'oneToMany'];\n\nconst isValidRelation = (validNatures: ReadonlyArray<string>): TestFunction<string | undefined> =>\n  function (this: TestContext, value) {\n    // NOTE: In case of an undefined value, delegate the check to .required()\n    if (value === undefined) {\n      return true;\n    }\n\n    if (this.parent.target === coreUids.STRAPI_USER) {\n      if (!validNatures.includes(value) || !isUndefined(this.parent.targetAttribute)) {\n        return this.createError({\n          path: this.path,\n          message: `must be one of the following values: ${STRAPI_USER_RELATIONS.join(', ')}`,\n        });\n      }\n    }\n\n    return validNatures.includes(value)\n      ? true\n      : this.createError({\n          path: this.path,\n          message: `must be one of the following values: ${validNatures.join(', ')}`,\n        });\n  };\n\nexport const getRelationValidator = (\n  attribute: Schema.Attribute.Relation,\n  allowedRelations: ReadonlyArray<string>\n) => {\n  const contentTypesUIDs = Object.keys(strapi.contentTypes)\n    .filter((key) => strapi.contentTypes[key as UID.ContentType].kind === typeKinds.COLLECTION_TYPE)\n    .filter((key) => !key.startsWith(coreUids.PREFIX) || key === coreUids.STRAPI_USER)\n    .concat(['__self__', '__contentType__']);\n\n  const base = {\n    type: yup.string().oneOf(['relation']).required(),\n    relation: yup.string().test('isValidRelation', isValidRelation(allowedRelations)).required(),\n    configurable: yup.boolean().nullable(),\n    private: yup.boolean().nullable(),\n    pluginOptions: yup.object(),\n  };\n\n  switch (attribute.relation) {\n    case 'oneToOne':\n    case 'oneToMany':\n    case 'manyToOne':\n    case 'manyToMany':\n    case 'morphOne':\n    case 'morphMany': {\n      return yup.object({\n        ...base,\n        target: yup.string().oneOf(contentTypesUIDs).required(),\n        targetAttribute: yup.string().test(isValidName).nullable(),\n      });\n    }\n    case 'morphToOne':\n    case 'morphToMany':\n    default: {\n      return yup.object({ ...base });\n    }\n  }\n};\n","import { yup } from '@strapi/utils';\nimport _ from 'lodash';\nimport { snakeCase } from 'lodash/fp';\nimport { modelTypes, typeKinds } from '../../services/constants';\nimport { getService } from '../../utils';\nimport { isValidKey, isValidCollectionName } from './common';\nimport { getTypeValidator } from './types';\nimport { getRelationValidator } from './relations';\n\ntype ModelTypeInput = (typeof modelTypes)[keyof typeof modelTypes];\n\ntype CreateAttributesInput = {\n  types: ReadonlyArray<string>;\n  relations: ReadonlyArray<string>;\n  modelType?: ModelTypeInput;\n};\n\nexport const createSchema = (\n  types: CreateAttributesInput['types'],\n  relations: CreateAttributesInput['relations'],\n  { modelType }: { modelType?: ModelTypeInput } = {}\n) => {\n  const shape = {\n    description: yup.string(),\n    options: yup.object(),\n    pluginOptions: yup.object(),\n    collectionName: yup.string().nullable().test(isValidCollectionName),\n    attributes: createAttributesValidator({ types, relations, modelType }),\n    draftAndPublish: yup.boolean(),\n  } as any;\n\n  if (modelType === modelTypes.CONTENT_TYPE) {\n    shape.kind = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]).nullable();\n  }\n\n  return yup.object(shape).noUnknown();\n};\n\nconst createAttributesValidator = ({ types, modelType, relations }: CreateAttributesInput) => {\n  return yup.lazy((attributes) => {\n    return yup\n      .object()\n      .shape(\n        _.mapValues(attributes, (attribute, key) => {\n          if (isForbiddenKey(key)) {\n            return forbiddenValidator();\n          }\n\n          if (isConflictingKey(key, attributes)) {\n            return conflictingKeysValidator(key);\n          }\n\n          if (attribute.type === 'relation') {\n            return getRelationValidator(attribute, relations).test(isValidKey(key));\n          }\n\n          if (_.has(attribute, 'type')) {\n            return getTypeValidator(attribute, { types, modelType, attributes }).test(\n              isValidKey(key)\n            );\n          }\n\n          return typeOrRelationValidator;\n        })\n      )\n      .required('attributes.required');\n  });\n};\n\nconst isConflictingKey = (key: string, attributes: Record<string, any>) => {\n  const snakeCaseKey = snakeCase(key);\n\n  return Object.keys(attributes).some((existingKey) => {\n    if (existingKey === key) return false; // don't compare against itself\n    return snakeCase(existingKey) === snakeCaseKey;\n  });\n};\n\nconst isForbiddenKey = (key: string) => {\n  return getService('builder').isReservedAttributeName(key);\n};\n\nconst forbiddenValidator = () => {\n  const reservedNames = [...getService('builder').getReservedNames().attributes];\n\n  return yup.mixed().test({\n    name: 'forbiddenKeys',\n    message: `Attribute keys cannot be one of ${reservedNames.join(', ')}`,\n    test: () => false,\n  });\n};\n\nconst conflictingKeysValidator = (key: string) => {\n  return yup.mixed().test({\n    name: 'conflictingKeys',\n    message: `Attribute ${key} conflicts with an existing key`,\n    test: () => false,\n  });\n};\n\nconst typeOrRelationValidator = yup.object().test({\n  name: 'mustHaveTypeOrTarget',\n  message: 'Attribute must have either a type or a target',\n  test: () => false,\n});\n","import type { Schema } from '@strapi/types';\n\nexport const hasDefaultAttribute = (\n  attribute: Schema.Attribute.AnyAttribute\n): attribute is Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown> => {\n  return 'default' in attribute;\n};\n","import type { Struct } from '@strapi/types';\nimport _ from 'lodash';\nimport { hasDefaultAttribute } from '../../utils/typeguards';\n\nexport const removeEmptyDefaults = (\n  data: Partial<Struct.ContentTypeSchema> | Partial<Struct.ComponentSchema> | undefined\n) => {\n  const { attributes } = data || {};\n\n  Object.keys(attributes!).forEach((attributeName) => {\n    const attribute = attributes![attributeName];\n\n    if (hasDefaultAttribute(attribute) && attribute.default === '') {\n      attribute.default = undefined;\n    }\n  });\n};\n\nexport const removeDeletedUIDTargetFields = (data: Struct.ContentTypeSchema) => {\n  if (_.has(data, 'attributes')) {\n    Object.values(data.attributes).forEach((attribute) => {\n      if (\n        attribute.type === 'uid' &&\n        !_.isUndefined(attribute.targetField) &&\n        !_.has(data.attributes, attribute.targetField)\n      ) {\n        attribute.targetField = undefined;\n      }\n    });\n  }\n};\n","import _ from 'lodash';\nimport { yup, validateYupSchema } from '@strapi/utils';\n\nimport type { Struct } from '@strapi/types';\nimport { modelTypes, DEFAULT_TYPES } from '../../services/constants';\nimport { isValidCategoryName, isValidIcon } from './common';\nimport { createSchema } from './model-schema';\nimport { removeEmptyDefaults } from './data-transform';\n\nexport const VALID_RELATIONS = ['oneToOne', 'oneToMany'];\nexport const VALID_TYPES = [...DEFAULT_TYPES, 'component', 'customField'];\n\nexport const componentSchema = createSchema(VALID_TYPES, VALID_RELATIONS, {\n  modelType: modelTypes.COMPONENT,\n})\n  .shape({\n    displayName: yup.string().min(1).required('displayName.required'),\n    icon: yup.string().nullable().test(isValidIcon),\n    category: yup.string().nullable().test(isValidCategoryName).required('category.required'),\n  })\n  .required()\n  .noUnknown();\n\nexport const nestedComponentSchema = yup.array().of(\n  componentSchema\n    .shape({\n      uid: yup.string(),\n      tmpUID: yup.string(),\n    })\n    .test({\n      name: 'mustHaveUIDOrTmpUID',\n      message: 'Component must have a uid or a tmpUID',\n      test(attr: unknown) {\n        if (_.has(attr, 'uid') && _.has(attr, 'tmpUID')) return false;\n        if (!_.has(attr, 'uid') && !_.has(attr, 'tmpUID')) return false;\n        return true;\n      },\n    })\n    .required()\n    .noUnknown()\n);\n\nexport const componentInputSchema = yup\n  .object({\n    component: componentSchema,\n    components: nestedComponentSchema,\n  })\n  .noUnknown();\n\nexport const validateComponentInput = validateYupSchema(componentInputSchema);\n\nconst updateComponentInputSchema = yup\n  .object({\n    component: componentSchema,\n    components: nestedComponentSchema,\n  })\n  .noUnknown();\n\nexport const validateUpdateComponentInput = (data: {\n  component?: Struct.ComponentSchema;\n  components?: Struct.ComponentSchema[];\n}) => {\n  if (_.has(data, 'component') && data.component) {\n    removeEmptyDefaults(data.component);\n  }\n\n  if (_.has(data, 'components') && Array.isArray(data.components)) {\n    data.components.forEach((data) => {\n      if (_.has(data, 'uid')) {\n        removeEmptyDefaults(data);\n      }\n    });\n  }\n\n  return validateYupSchema(updateComponentInputSchema)(data);\n};\n","import _ from 'lodash';\nimport type { Context } from 'koa';\nimport type { UID } from '@strapi/types';\nimport { getService } from '../utils';\nimport { validateComponentInput, validateUpdateComponentInput } from './validation/component';\n\n/**\n * Components controller\n */\n\nexport default {\n  /**\n   * GET /components handler\n   * Returns a list of available components\n   * @param {Object} ctx - koa context\n   */\n  async getComponents(ctx: Context) {\n    const componentService = getService('components');\n    const componentUIDs = Object.keys(strapi.components) as UID.Component[];\n\n    const data = componentUIDs.map((uid) => {\n      return componentService.formatComponent(strapi.components[uid]);\n    });\n\n    ctx.send({ data });\n  },\n\n  /**\n   * GET /components/:uid\n   * Returns a specific component\n   * @param {Object} ctx - koa context\n   */\n  async getComponent(ctx: Context) {\n    const { uid } = ctx.params;\n\n    const component = strapi.components[uid];\n\n    if (!component) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    const componentService = getService('components');\n\n    ctx.send({ data: componentService.formatComponent(component) });\n  },\n\n  /**\n   * POST /components\n   * Creates a component and returns its infos\n   * @param {Object} ctx - koa context\n   */\n  async createComponent(ctx: Context) {\n    const body = ctx.request.body as any;\n\n    try {\n      await validateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = await componentService.createComponent({\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  /**\n   * PUT /components/:uid\n   * Updates a component and return its infos\n   * @param {Object} ctx - koa context - enhanced koa context\n   */\n  async updateComponent(ctx: Context) {\n    const { uid } = ctx.params;\n    const body = ctx.request.body as any;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = (await componentService.editComponent(uid, {\n        component: body.component,\n        components: body.components,\n      })) as any;\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  /**\n   * DELETE /components/:uid\n   * Deletes a components and returns its old infos\n   * @param {Object} ctx - koa context\n   */\n  async deleteComponent(ctx: Context) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = await componentService.deleteComponent(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n};\n","/* eslint-disable no-template-curly-in-string */ // yup templates need to be in this format\n\nimport { flatMap, getOr, has, snakeCase } from 'lodash/fp';\nimport { yup, validateYupSchema } from '@strapi/utils';\n\nimport type { Struct, Internal } from '@strapi/types';\nimport { getService } from '../../utils';\nimport { modelTypes, DEFAULT_TYPES, typeKinds } from '../../services/constants';\nimport { createSchema } from './model-schema';\nimport { removeEmptyDefaults, removeDeletedUIDTargetFields } from './data-transform';\nimport { nestedComponentSchema } from './component';\n\n// Input flattens some fields of the \"info\" into the root type\nexport type CreateContentTypeInput = {\n  contentType?: Partial<Struct.ContentTypeSchema> & Partial<Struct.ContentTypeSchemaInfo>;\n  components?: Array<\n    Partial<Struct.ComponentSchema> &\n      Partial<Struct.SchemaInfo> & { tmpUID?: Internal.UID.Component }\n  >;\n  singularName: Struct.ContentTypeSchemaInfo['singularName'];\n  attributes: Struct.SchemaAttributes & Record<string, any>;\n  kind: Struct.ContentTypeKind;\n  collectionName?: Struct.CollectionTypeSchema['collectionName'];\n  pluralName: Struct.ContentTypeSchemaInfo['pluralName'];\n  displayName: Struct.ContentTypeSchemaInfo['displayName'];\n  description: Struct.ContentTypeSchemaInfo['description'];\n  options?: Struct.SchemaOptions;\n  draftAndPublish?: Struct.SchemaOptions['draftAndPublish'];\n  pluginOptions?: Struct.ContentTypeSchema['pluginOptions'];\n  config?: object;\n};\n\n/**\n * Allowed relation per type kind\n */\nconst VALID_RELATIONS = {\n  [typeKinds.SINGLE_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n  [typeKinds.COLLECTION_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'manyToOne',\n    'manyToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n} as const;\n\n/**\n * Allowed types\n */\nconst VALID_TYPES = [...DEFAULT_TYPES, 'uid', 'component', 'dynamiczone', 'customField'];\n\n/**\n * Returns a yup schema to validate a content type payload\n */\nconst createContentTypeSchema = (data: CreateContentTypeInput, { isEdition = false } = {}) => {\n  const kind: keyof typeof VALID_RELATIONS = getOr(\n    typeKinds.COLLECTION_TYPE,\n    'contentType.kind',\n    data\n  );\n  const contentTypeSchema = createSchema(VALID_TYPES, VALID_RELATIONS[kind] || [], {\n    modelType: modelTypes.CONTENT_TYPE,\n  })\n    .shape({\n      displayName: yup.string().min(1).required(),\n      singularName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n      pluralName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(nameIsNotExistingCollectionName(isEdition)) // TODO: v5: require singularName to not match a collection name\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n    })\n    .test(\n      'singularName-not-equal-pluralName',\n      '${path}: singularName and pluralName should be different',\n      (value) => value.singularName !== value.pluralName\n    );\n\n  return yup\n    .object({\n      // FIXME .noUnknown(false) will strip off the unwanted properties without throwing an error\n      // Why not having .noUnknown() ? Because we want to be able to add options relatable to EE features\n      // without having any reference to them in CE.\n      // Why not handle an \"options\" object in the content-type ? The admin panel needs lots of rework\n      // to be able to send this options object instead of top-level attributes.\n      // @nathan-pichon 20/02/2023\n      contentType: contentTypeSchema.required().noUnknown(false),\n      components: nestedComponentSchema,\n    })\n    .noUnknown();\n};\n\n/**\n * Validator for content type creation\n */\nexport const validateContentTypeInput = (data: CreateContentTypeInput) => {\n  return validateYupSchema(createContentTypeSchema(data))(data);\n};\n\n/**\n * Validator for content type edition\n */\nexport const validateUpdateContentTypeInput = (data: CreateContentTypeInput) => {\n  if (has('contentType', data)) {\n    removeEmptyDefaults(data.contentType);\n    removeDeletedUIDTargetFields(data.contentType as Struct.ContentTypeSchema);\n  }\n\n  if (has('components', data) && Array.isArray(data.components)) {\n    data.components.forEach((comp) => {\n      if (has('uid', comp)) {\n        removeEmptyDefaults(comp as Struct.ComponentSchema);\n      }\n    });\n  }\n\n  return validateYupSchema(createContentTypeSchema(data, { isEdition: true }))(data);\n};\n\nconst forbiddenContentTypeNameValidator = () => {\n  const reservedNames = getService('builder').getReservedNames().models;\n\n  return {\n    name: 'forbiddenContentTypeName',\n    message: `Content Type name cannot be one of ${reservedNames.join(', ')}`,\n    test(value: unknown) {\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      return !getService('builder').isReservedModelName(value);\n    },\n  };\n};\n\nconst nameIsAvailable = (isEdition: boolean) => {\n  // TODO TS: if strapi.contentTypes (ie, ContentTypes) works as an ArrayLike and is used like this, we may want to ensure it is typed so that it can be without using as\n  const usedNames = flatMap((ct: Struct.ContentTypeSchema) => {\n    return [ct.info?.singularName, ct.info?.pluralName];\n  })(strapi.contentTypes as any);\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\nconst nameIsNotExistingCollectionName = (isEdition: boolean) => {\n  const usedNames = Object.keys(strapi.contentTypes).map(\n    (key) => strapi.contentTypes[key as Internal.UID.ContentType].collectionName\n  ) as string[];\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\n/**\n * Validates type kind\n */\nconst kindSchema = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]);\n\nexport const validateKind = validateYupSchema(kindSchema);\n","import _ from 'lodash';\nimport type { Context } from 'koa';\nimport type {} from 'koa-body';\nimport type { Internal } from '@strapi/types';\nimport { getService } from '../utils';\nimport {\n  validateContentTypeInput,\n  validateUpdateContentTypeInput,\n  validateKind,\n} from './validation/content-type';\n\nexport default {\n  async getContentTypes(ctx: Context) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypeService = getService('content-types');\n\n    const contentTypes = Object.keys(strapi.contentTypes)\n      .filter(\n        (uid) =>\n          !kind ||\n          _.get(strapi.contentTypes[uid as Internal.UID.ContentType], 'kind', 'collectionType') ===\n            kind\n      )\n      .map((uid) =>\n        contentTypeService.formatContentType(strapi.contentTypes[uid as Internal.UID.ContentType])\n      );\n\n    ctx.send({\n      data: contentTypes,\n    });\n  },\n\n  getContentType(ctx: Context) {\n    const { uid } = ctx.params;\n\n    const contentType = strapi.contentTypes[uid];\n\n    if (!contentType) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    const contentTypeService = getService('content-types');\n\n    ctx.send({ data: contentTypeService.formatContentType(contentType) });\n  },\n\n  async createContentType(ctx: Context) {\n    const body = ctx.request.body as any;\n\n    try {\n      await validateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const contentType = await contentTypeService.createContentType({\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      const metricsPayload = {\n        eventProperties: {\n          kind: contentType.kind,\n        },\n      };\n\n      if (_.isEmpty(strapi.apis)) {\n        await strapi.telemetry.send('didCreateFirstContentType', metricsPayload);\n      } else {\n        await strapi.telemetry.send('didCreateContentType', metricsPayload);\n      }\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: contentType.uid } }, 201);\n    } catch (err) {\n      strapi.log.error(err);\n      await strapi.telemetry.send('didNotCreateContentType', {\n        eventProperties: { error: (err as Error).message || err },\n      });\n      ctx.send({ error: (err as Error).message || 'Unknown error' }, 400);\n    }\n  },\n\n  async updateContentType(ctx: Context) {\n    const { uid } = ctx.params;\n    const body = ctx.request.body as any;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const component = await contentTypeService.editContentType(uid, {\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  async deleteContentType(ctx: Context) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const component = await contentTypeService.deleteContentType(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);\n    }\n  },\n};\n","import builder from './builder';\nimport componentCategories from './component-categories';\nimport components from './components';\nimport contentTypes from './content-types';\n\nconst exportObject = {\n  builder,\n  'component-categories': componentCategories,\n  components,\n  'content-types': contentTypes,\n};\n\nexport default exportObject;\n","export default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/reserved-names',\n      handler: 'builder.getReservedNames',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types',\n      handler: 'content-types.getContentTypes',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types/:uid',\n      handler: 'content-types.getContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/content-types',\n      handler: 'content-types.createContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/content-types/:uid',\n      handler: 'content-types.updateContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/content-types/:uid',\n      handler: 'content-types.deleteContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/components',\n      handler: 'components.getComponents',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/components/:uid',\n      handler: 'components.getComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/components',\n      handler: 'components.createComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/components/:uid',\n      handler: 'components.updateComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/components/:uid',\n      handler: 'components.deleteComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/component-categories/:name',\n      handler: 'component-categories.editCategory',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/component-categories/:name',\n      handler: 'component-categories.deleteCategory',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n  ],\n};\n","export default {\n  type: 'content-api',\n  routes: [\n    {\n      method: 'GET',\n      path: '/content-types',\n      handler: 'content-types.getContentTypes',\n    },\n    {\n      method: 'GET',\n      path: '/content-types/:uid',\n      handler: 'content-types.getContentType',\n    },\n    {\n      method: 'GET',\n      path: '/components',\n      handler: 'components.getComponents',\n    },\n    {\n      method: 'GET',\n      path: '/components/:uid',\n      handler: 'components.getComponent',\n    },\n  ],\n};\n","import admin from './admin';\nimport contentApi from './content-api';\n\nexport default {\n  admin,\n  'content-api': contentApi,\n};\n","// eslint-disable-next-line import/no-extraneous-dependencies\nimport '@strapi/types';\n\nimport config from './config';\nimport bootstrap from './bootstrap';\nimport services from './services';\nimport controllers from './controllers';\nimport routes from './routes';\n\nexport default () => ({\n  config,\n  bootstrap,\n  services,\n  controllers,\n  routes,\n});\n"],"names":["strapi","ApplicationError","path","uid","fse","createComponentBuilder","components","contentTypes","createContentTypeBuilder","contentTypesUtils","builder","options","apiHandler","component","componentCategories","VALID_RELATIONS","VALID_TYPES","data","has","controllers"],"mappings":"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"}