{"version":3,"file":"index.js","sources":["../src/domain/permission/index.ts","../src/engine/hooks.ts","../src/engine/abilities/casl-ability.ts","../src/engine/index.ts"],"sourcesContent":["import _ from 'lodash/fp';\n\nconst PERMISSION_FIELDS = ['action', 'subject', 'properties', 'conditions'] as const;\n\nconst sanitizePermissionFields = _.pick(PERMISSION_FIELDS);\n\nexport interface Permission {\n  action: string;\n  actionParameters?: Record<string, unknown>;\n  subject?: string | object | null;\n  properties?: Record<string, any>;\n  conditions?: string[];\n}\n\n/**\n * Creates a permission with default values for optional properties\n */\nconst getDefaultPermission = (): Pick<Permission, 'conditions' | 'properties' | 'subject'> => ({\n  conditions: [],\n  properties: {},\n  subject: null,\n});\n\n/**\n * Create a new permission based on given attributes\n *\n * @param {object} attributes\n */\nconst create = _.pipe(_.pick(PERMISSION_FIELDS), _.merge(getDefaultPermission()));\n\n/**\n * Add a condition to a permission\n */\nconst addCondition = _.curry((condition: string, permission: Permission): Permission => {\n  const { conditions } = permission;\n\n  const newConditions = Array.isArray(conditions)\n    ? _.uniq(conditions.concat(condition))\n    : [condition];\n\n  return _.set('conditions', newConditions, permission);\n});\n\n/**\n * Gets a property or a part of a property from a permission.\n */\nconst getProperty = _.curry(\n  <T extends keyof Permission['properties']>(\n    property: T,\n    permission: Permission\n  ): Permission['properties'][T] => _.get(`properties.${property}`, permission)\n);\n\nexport { create, sanitizePermissionFields, addCondition, getProperty };\n","import { cloneDeep, has, isArray } from 'lodash/fp';\nimport { hooks } from '@strapi/utils';\n\nimport * as domain from '../domain';\nimport type { Permission } from '../domain/permission';\nimport type { PermissionRule } from '../types';\n\nexport interface PermissionEngineHooks {\n  'before-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\n  'format.permission': ReturnType<typeof hooks.createAsyncSeriesWaterfallHook>;\n  'after-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\n  'before-evaluate.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\n  'before-register.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\n}\n\nexport type HookName = keyof PermissionEngineHooks;\n\n/**\n * Create a hook map used by the permission Engine\n */\nconst createEngineHooks = (): PermissionEngineHooks => ({\n  'before-format::validate.permission': hooks.createAsyncBailHook(),\n  'format.permission': hooks.createAsyncSeriesWaterfallHook(),\n  'after-format::validate.permission': hooks.createAsyncBailHook(),\n  'before-evaluate.permission': hooks.createAsyncSeriesHook(),\n  'before-register.permission': hooks.createAsyncSeriesHook(),\n});\n\n/**\n * Create a context from a domain {@link Permission} used by the validate hooks\n */\nconst createValidateContext = (permission: Permission) => ({\n  get permission(): Readonly<Permission> {\n    return cloneDeep(permission);\n  },\n});\n\n/**\n * Create a context from a domain {@link Permission} used by the before valuate hook\n */\nconst createBeforeEvaluateContext = (permission: Permission) => ({\n  get permission(): Readonly<Permission> {\n    return cloneDeep(permission);\n  },\n\n  addCondition(condition: string) {\n    Object.assign(permission, domain.permission.addCondition(condition, permission));\n\n    return this;\n  },\n});\n\ninterface WillRegisterContextParams {\n  permission: PermissionRule;\n  options: Record<string, unknown>;\n}\n\n/**\n * Create a context from a casl Permission & some options\n * @param caslPermission\n */\nconst createWillRegisterContext = ({ permission, options }: WillRegisterContextParams) => ({\n  ...options,\n\n  get permission() {\n    return cloneDeep(permission);\n  },\n\n  condition: {\n    and(rawConditionObject: unknown) {\n      if (!permission.condition) {\n        permission.condition = { $and: [] };\n      }\n\n      if (isArray(permission.condition.$and)) {\n        permission.condition.$and.push(rawConditionObject);\n      }\n\n      return this;\n    },\n\n    or(rawConditionObject: unknown) {\n      if (!permission.condition) {\n        permission.condition = { $and: [] };\n      }\n\n      if (isArray(permission.condition.$and)) {\n        const orClause = permission.condition.$and.find(has('$or'));\n\n        if (orClause) {\n          orClause.$or.push(rawConditionObject);\n        } else {\n          permission.condition.$and.push({ $or: [rawConditionObject] });\n        }\n      }\n\n      return this;\n    },\n  },\n});\n\nexport {\n  createEngineHooks,\n  createValidateContext,\n  createBeforeEvaluateContext,\n  createWillRegisterContext,\n};\n","import * as sift from 'sift';\nimport qs from 'qs';\nimport { AbilityBuilder, Ability } from '@casl/ability';\nimport { pick, isNil, isObject } from 'lodash/fp';\nimport type { ParametrizedAction, PermissionRule } from '../../types';\n\nexport interface CustomAbilityBuilder {\n  can(permission: PermissionRule): ReturnType<AbilityBuilder<Ability>['can']>;\n  buildParametrizedAction: (parametrizedAction: ParametrizedAction) => string;\n  build(): Ability;\n}\n\nconst allowedOperations = [\n  '$or',\n  '$and',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n] as const;\n\nconst operations = pick(allowedOperations, sift);\n\nconst conditionsMatcher = (conditions: unknown) => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nconst buildParametrizedAction = ({ name, params }: ParametrizedAction) => {\n  return `${name}?${qs.stringify(params)}`;\n};\n\n/**\n * Casl Ability Builder.\n */\nexport const caslAbilityBuilder = (): CustomAbilityBuilder => {\n  const { can, build, ...rest } = new AbilityBuilder(Ability);\n\n  return {\n    can(permission: PermissionRule) {\n      const { action, subject, properties = {}, condition } = permission;\n      const { fields } = properties;\n\n      const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\n\n      return can(\n        caslAction,\n        isNil(subject) ? 'all' : subject,\n        fields,\n        isObject(condition) ? condition : undefined\n      );\n    },\n\n    buildParametrizedAction({ name, params }: ParametrizedAction) {\n      return `${name}?${qs.stringify(params)}`;\n    },\n\n    build() {\n      const ability = build({ conditionsMatcher });\n\n      function decorateCan(originalCan: Ability['can']) {\n        return function (...args: Parameters<Ability['can']>) {\n          const [action, ...rest] = args;\n          const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\n\n          // Call the original `can` method\n          return originalCan.apply(ability, [caslAction, ...rest]);\n        };\n      }\n\n      ability.can = decorateCan(ability.can);\n      return ability;\n    },\n\n    ...rest,\n  };\n};\n","import _ from 'lodash/fp';\nimport qs from 'qs';\nimport { Ability } from '@casl/ability';\nimport { providerFactory } from '@strapi/utils';\n\nimport {\n  createEngineHooks,\n  createWillRegisterContext,\n  createBeforeEvaluateContext,\n  createValidateContext,\n} from './hooks';\nimport type { PermissionEngineHooks, HookName } from './hooks';\n\nimport * as abilities from './abilities';\nimport { Permission } from '../domain/permission';\nimport type { PermissionRule } from '../types';\n\nexport { abilities };\n\ntype Provider = Omit<ReturnType<typeof providerFactory>, 'register'> & {\n  register(...args: unknown[]): Promise<Provider> | Provider;\n};\n\ntype ActionProvider = Provider;\ntype ConditionProvider = Provider;\n\nexport interface Engine {\n  hooks: PermissionEngineHooks;\n  on(hook: HookName, handler: (...args: any[]) => any): Engine;\n  generateAbility(permissions: Permission[], options?: object): Promise<Ability>;\n  createRegisterFunction(\n    can: (permission: PermissionRule) => unknown,\n    options: Record<string, unknown>\n  ): (permission: PermissionRule) => Promise<unknown>;\n}\n\nexport interface EngineParams {\n  providers: { action: ActionProvider; condition: ConditionProvider };\n  abilityBuilderFactory?(): abilities.CustomAbilityBuilder;\n}\n\ninterface EvaluateParams {\n  options: Record<string, unknown>;\n  register: (permission: PermissionRule) => Promise<unknown>;\n  permission: Permission;\n}\n\ninterface Condition {\n  name: string;\n  handler(...params: unknown[]): boolean | object;\n}\n\n/**\n * Create a default state object for the engine\n */\nconst createEngineState = () => {\n  const hooks = createEngineHooks();\n\n  return { hooks };\n};\n\nconst newEngine = (params: EngineParams): Engine => {\n  const { providers, abilityBuilderFactory = abilities.caslAbilityBuilder } = params;\n\n  const state = createEngineState();\n\n  const runValidationHook = async (hook: HookName, context: unknown) =>\n    state.hooks[hook].call(context);\n\n  /**\n   * Evaluate a permission using local and registered behaviors (using hooks).\n   * Validate, format (add condition, etc...), evaluate (evaluate conditions) and register a permission\n   */\n  const evaluate = async (params: EvaluateParams) => {\n    const { options, register } = params;\n\n    const preFormatValidation = await runValidationHook(\n      'before-format::validate.permission',\n      createBeforeEvaluateContext(params.permission)\n    );\n\n    if (preFormatValidation === false) {\n      return;\n    }\n\n    const permission = (await state.hooks['format.permission'].call(\n      params.permission\n    )) as Permission;\n\n    const afterFormatValidation = await runValidationHook(\n      'after-format::validate.permission',\n      createValidateContext(permission)\n    );\n\n    if (afterFormatValidation === false) {\n      return;\n    }\n\n    await state.hooks['before-evaluate.permission'].call(createBeforeEvaluateContext(permission));\n\n    const {\n      action: actionName,\n      subject,\n      properties,\n      conditions = [],\n      actionParameters = {},\n    } = permission;\n\n    let action = actionName;\n\n    if (actionParameters && Object.keys(actionParameters).length > 0) {\n      action = `${actionName}?${qs.stringify(actionParameters)}`;\n    }\n\n    if (conditions.length === 0) {\n      return register({ action, subject, properties });\n    }\n\n    const resolveConditions = _.map(providers.condition.get);\n\n    const removeInvalidConditions = _.filter((condition: Condition) =>\n      _.isFunction(condition.handler)\n    );\n\n    const evaluateConditions = (conditions: Condition[]) => {\n      return Promise.all(\n        conditions.map(async (condition) => ({\n          condition,\n          result: await condition.handler(\n            _.merge(options, { permission: _.cloneDeep(permission) })\n          ),\n        }))\n      );\n    };\n\n    const removeInvalidResults = _.filter(\n      ({ result }) => _.isBoolean(result) || _.isObject(result)\n    );\n\n    const evaluatedConditions = await Promise.resolve(conditions)\n      .then(resolveConditions)\n      .then(removeInvalidConditions)\n      .then(evaluateConditions)\n      .then(removeInvalidResults);\n\n    const resultPropEq = _.propEq('result');\n    const pickResults = _.map(_.prop('result'));\n\n    if (evaluatedConditions.every(resultPropEq(false))) {\n      return;\n    }\n\n    if (_.isEmpty(evaluatedConditions) || evaluatedConditions.some(resultPropEq(true))) {\n      return register({ action, subject, properties });\n    }\n\n    const results = pickResults(evaluatedConditions).filter(_.isObject);\n\n    if (_.isEmpty(results)) {\n      return register({ action, subject, properties });\n    }\n\n    return register({\n      action,\n      subject,\n      properties,\n      condition: { $and: [{ $or: results }] },\n    });\n  };\n\n  return {\n    get hooks() {\n      return state.hooks;\n    },\n\n    /**\n     * Create a register function that wraps a `can` function\n     * used to register a permission in the ability builder\n     */\n    createRegisterFunction(can, options: Record<string, unknown>) {\n      return async (permission: PermissionRule) => {\n        const hookContext = createWillRegisterContext({ options, permission });\n\n        await state.hooks['before-register.permission'].call(hookContext);\n\n        return can(permission);\n      };\n    },\n\n    /**\n     * Register a new handler for a given hook\n     */\n    on(hook, handler) {\n      const validHooks = Object.keys(state.hooks);\n      const isValidHook = validHooks.includes(hook);\n\n      if (!isValidHook) {\n        throw new Error(\n          `Invalid hook supplied when trying to register an handler to the permission engine. Got \"${hook}\" but expected one of ${validHooks.join(\n            ', '\n          )}`\n        );\n      }\n\n      state.hooks[hook].register(handler);\n\n      return this;\n    },\n\n    /**\n     * Generate an ability based on the instance's\n     * ability builder and the given permissions\n     */\n    async generateAbility(permissions, options: Record<string, unknown> = {}) {\n      const { can, build } = abilityBuilderFactory();\n\n      for (const permission of permissions) {\n        const register = this.createRegisterFunction(can, options);\n\n        await evaluate({ permission, options, register });\n      }\n\n      return build();\n    },\n  };\n};\n\nexport { newEngine as new };\n"],"names":["_","hooks","cloneDeep","domain.permission.addCondition","isArray","has","pick","sift","qs","AbilityBuilder","Ability","isNil","isObject","ability","rest","abilities.caslAbilityBuilder","params","conditions"],"mappings":"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"}