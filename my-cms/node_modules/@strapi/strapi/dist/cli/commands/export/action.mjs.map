{"version":3,"file":"action.mjs","sources":["../../../../src/cli/commands/export/action.ts"],"sourcesContent":["import { isObject, isString, isFinite, toNumber } from 'lodash/fp';\nimport fs from 'fs-extra';\nimport chalk from 'chalk';\nimport type { Core } from '@strapi/types';\n\nimport {\n  engine as engineDataTransfer,\n  strapi as strapiDataTransfer,\n  file as fileDataTransfer,\n} from '@strapi/data-transfer';\n\nimport {\n  getDefaultExportName,\n  buildTransferTable,\n  DEFAULT_IGNORED_CONTENT_TYPES,\n  createStrapiInstance,\n  formatDiagnostic,\n  loadersFactory,\n  exitMessageText,\n  abortTransfer,\n  getTransferTelemetryPayload,\n  setSignalHandler,\n} from '../../utils/data-transfer';\nimport { exitWith } from '../../utils/helpers';\n\nconst {\n  providers: { createLocalFileDestinationProvider },\n} = fileDataTransfer;\nconst {\n  providers: { createLocalStrapiSourceProvider },\n} = strapiDataTransfer;\n\nconst BYTES_IN_MB = 1024 * 1024;\n\ninterface CmdOptions {\n  file?: string;\n  encrypt?: boolean;\n  verbose?: boolean;\n  key?: string;\n  compress?: boolean;\n  only?: (keyof engineDataTransfer.TransferGroupFilter)[];\n  exclude?: (keyof engineDataTransfer.TransferGroupFilter)[];\n  throttle?: number;\n  maxSizeJsonl?: number;\n}\n\n/**\n * Export command.\n *\n * It transfers data from a local Strapi instance to a file\n *\n * @param {ExportCommandOptions} opts\n */\nexport default async (opts: CmdOptions) => {\n  // Validate inputs from Commander\n  if (!isObject(opts)) {\n    exitWith(1, 'Could not parse command arguments');\n  }\n\n  const strapi = await createStrapiInstance();\n\n  const source = createSourceProvider(strapi);\n  const destination = createDestinationProvider(opts);\n\n  const engine = engineDataTransfer.createTransferEngine(source, destination, {\n    versionStrategy: 'ignore', // for an export to file, versionStrategy will always be skipped\n    schemaStrategy: 'ignore', // for an export to file, schemaStrategy will always be skipped\n    exclude: opts.exclude,\n    only: opts.only,\n    throttle: opts.throttle,\n    transforms: {\n      links: [\n        {\n          filter(link) {\n            return (\n              !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) &&\n              !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type)\n            );\n          },\n        },\n      ],\n      entities: [\n        {\n          filter(entity) {\n            return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);\n          },\n        },\n      ],\n    },\n  });\n\n  engine.diagnostics.onDiagnostic(formatDiagnostic('export', opts.verbose));\n\n  const progress = engine.progress.stream;\n\n  const { updateLoader } = loadersFactory();\n\n  progress.on(`stage::start`, ({ stage, data }) => {\n    updateLoader(stage, data).start();\n  });\n\n  progress.on('stage::finish', ({ stage, data }) => {\n    updateLoader(stage, data).succeed();\n  });\n\n  progress.on('stage::progress', ({ stage, data }) => {\n    updateLoader(stage, data);\n  });\n\n  progress.on('transfer::start', async () => {\n    console.log(`Starting export...`);\n\n    await strapi.telemetry.send('didDEITSProcessStart', getTransferTelemetryPayload(engine));\n  });\n\n  let results: engineDataTransfer.ITransferResults<typeof source, typeof destination>;\n  let outFile: string;\n  try {\n    // Abort transfer if user interrupts process\n    setSignalHandler(() => abortTransfer({ engine, strapi }));\n\n    results = await engine.transfer();\n    outFile = results.destination?.file?.path ?? '';\n    const outFileExists = await fs.pathExists(outFile);\n    if (!outFileExists) {\n      throw new engineDataTransfer.errors.TransferEngineTransferError(\n        `Export file not created \"${outFile}\"`\n      );\n    }\n\n    // Note: we need to await telemetry or else the process ends before it is sent\n    await strapi.telemetry.send('didDEITSProcessFinish', getTransferTelemetryPayload(engine));\n\n    try {\n      const table = buildTransferTable(results.engine);\n      console.log(table?.toString());\n    } catch (e) {\n      console.error('There was an error displaying the results of the transfer.');\n    }\n\n    console.log(`Export archive is in ${chalk.green(outFile)}`);\n    exitWith(0, exitMessageText('export'));\n  } catch {\n    await strapi.telemetry.send('didDEITSProcessFail', getTransferTelemetryPayload(engine));\n    exitWith(1, exitMessageText('export', true));\n  }\n};\n\n/**\n * It creates a local strapi destination provider\n */\nconst createSourceProvider = (strapi: Core.Strapi) => {\n  return createLocalStrapiSourceProvider({\n    async getStrapi() {\n      return strapi;\n    },\n  });\n};\n\n/**\n * It creates a local file destination provider based on the given options\n */\nconst createDestinationProvider = (opts: CmdOptions) => {\n  const { file, compress, encrypt, key, maxSizeJsonl } = opts;\n\n  const filepath = isString(file) && file.length > 0 ? file : getDefaultExportName();\n\n  const maxSizeJsonlInMb = isFinite(toNumber(maxSizeJsonl))\n    ? toNumber(maxSizeJsonl) * BYTES_IN_MB\n    : undefined;\n\n  return createLocalFileDestinationProvider({\n    file: {\n      path: filepath,\n      maxSizeJsonl: maxSizeJsonlInMb,\n    },\n    encryption: {\n      enabled: encrypt ?? false,\n      key: encrypt ? key : undefined,\n    },\n    compression: {\n      enabled: compress ?? false,\n    },\n  });\n};\n"],"names":["fileDataTransfer","strapiDataTransfer","strapi","engine","engineDataTransfer","fs","file"],"mappings":"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"}