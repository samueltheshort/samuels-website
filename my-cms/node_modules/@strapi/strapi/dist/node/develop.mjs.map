{"version":3,"file":"develop.mjs","sources":["../../src/node/develop.ts"],"sourcesContent":["import * as tsUtils from '@strapi/typescript-utils';\nimport { strings } from '@strapi/utils';\nimport chokidar from 'chokidar';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport cluster from 'node:cluster';\nimport { createStrapi } from '@strapi/core';\n\nimport type { CLIContext } from '../cli/types';\nimport { checkRequiredDependencies } from './core/dependencies';\nimport { getTimer, prettyTime, type TimeMeasurer } from './core/timer';\nimport { createBuildContext } from './create-build-context';\nimport type { WebpackWatcher } from './webpack/watch';\nimport type { ViteWatcher } from './vite/watch';\n\nimport { writeStaticClientFiles } from './staticFiles';\n\ninterface DevelopOptions extends CLIContext {\n  /**\n   * Which bundler to use for building.\n   *\n   * @default webpack\n   */\n  bundler?: 'webpack' | 'vite';\n  polling?: boolean;\n  open?: boolean;\n  watchAdmin?: boolean;\n}\n\n// This method removes all non-admin build files from the dist directory\nconst cleanupDistDirectory = async ({\n  tsconfig,\n  logger,\n  timer,\n}: Pick<DevelopOptions, 'tsconfig' | 'logger'> & { timer: TimeMeasurer }) => {\n  const distDir = tsconfig?.config?.options?.outDir;\n\n  if (\n    !distDir || // we don't have a dist dir\n    (await fs\n      .access(distDir)\n      .then(() => false)\n      .catch(() => true)) // it doesn't exist -- if it does but no access, that will be caught later\n  ) {\n    return;\n  }\n\n  const timerName = `cleaningDist${Date.now()}`;\n  timer.start(timerName);\n  const cleaningSpinner = logger.spinner(`Cleaning dist dir ${distDir}`).start();\n\n  try {\n    const dirContent = await fs.readdir(distDir);\n    const validFilenames = dirContent\n      // Ignore the admin build folder\n      .filter((filename) => filename !== 'build');\n    for (const filename of validFilenames) {\n      await fs.rm(path.resolve(distDir, filename), { recursive: true });\n    }\n  } catch (err: unknown) {\n    const generatingDuration = timer.end(timerName);\n    cleaningSpinner.text = `Error cleaning dist dir: ${err} (${prettyTime(generatingDuration)})`;\n    cleaningSpinner?.fail();\n    return;\n  }\n\n  const generatingDuration = timer.end(timerName);\n  cleaningSpinner.text = `Cleaning dist dir (${prettyTime(generatingDuration)})`;\n  cleaningSpinner?.succeed();\n};\n\nconst develop = async ({\n  cwd,\n  polling,\n  logger,\n  tsconfig,\n  watchAdmin,\n  ...options\n}: DevelopOptions) => {\n  const timer = getTimer();\n\n  if (cluster.isPrimary) {\n    const { didInstall } = await checkRequiredDependencies({ cwd, logger }).catch((err) => {\n      logger.error(err.message);\n      process.exit(1);\n    });\n\n    if (didInstall) {\n      return;\n    }\n\n    if (tsconfig?.config) {\n      // Build without diagnostics in case schemas have changed\n      await cleanupDistDirectory({ tsconfig, logger, timer });\n      await tsUtils.compile(cwd, { configOptions: { ignoreDiagnostics: true } });\n    }\n\n    /**\n     * IF we're not watching the admin we're going to build it, this makes\n     * sure that at least the admin is built for users & they can interact\n     * with the application.\n     */\n    if (!watchAdmin) {\n      timer.start('createBuildContext');\n      const contextSpinner = logger.spinner(`Building build context`).start();\n      console.log('');\n\n      const ctx = await createBuildContext({\n        cwd,\n        logger,\n        tsconfig,\n        options,\n      });\n      const contextDuration = timer.end('createBuildContext');\n      contextSpinner.text = `Building build context (${prettyTime(contextDuration)})`;\n      contextSpinner.succeed();\n\n      timer.start('creatingAdmin');\n      const adminSpinner = logger.spinner(`Creating admin`).start();\n\n      await writeStaticClientFiles(ctx);\n\n      if (ctx.bundler === 'webpack') {\n        const { build: buildWebpack } = await import('./webpack/build');\n        await buildWebpack(ctx);\n      } else if (ctx.bundler === 'vite') {\n        const { build: buildVite } = await import('./vite/build');\n        await buildVite(ctx);\n      }\n\n      const adminDuration = timer.end('creatingAdmin');\n      adminSpinner.text = `Creating admin (${prettyTime(adminDuration)})`;\n      adminSpinner.succeed();\n    }\n\n    cluster.on('message', async (worker, message) => {\n      switch (message) {\n        case 'reload': {\n          if (tsconfig?.config) {\n            // Build without diagnostics in case schemas have changed\n            await cleanupDistDirectory({ tsconfig, logger, timer });\n            await tsUtils.compile(cwd, { configOptions: { ignoreDiagnostics: true } });\n          }\n          logger.debug('cluster has the reload message, sending the worker kill message');\n          worker.send('kill');\n          break;\n        }\n        case 'killed': {\n          logger.debug('cluster has the killed message, forking the cluster');\n          cluster.fork();\n          break;\n        }\n        case 'stop': {\n          process.exit(1);\n          break;\n        }\n        default:\n          break;\n      }\n    });\n\n    cluster.fork();\n  }\n\n  if (cluster.isWorker) {\n    timer.start('loadStrapi');\n    const loadStrapiSpinner = logger.spinner(`Loading Strapi`).start();\n\n    const strapi = createStrapi({\n      appDir: cwd,\n      distDir: tsconfig?.config.options.outDir ?? '',\n      autoReload: true,\n      serveAdminPanel: !watchAdmin,\n    });\n\n    /**\n     * If we're watching the admin panel then we're going to attach the watcher\n     * as a strapi middleware.\n     */\n    let bundleWatcher: WebpackWatcher | ViteWatcher | undefined;\n\n    const strapiInstance = await strapi.load();\n\n    if (watchAdmin) {\n      timer.start('createBuildContext');\n      const contextSpinner = logger.spinner(`Building build context`).start();\n      console.log('');\n\n      const ctx = await createBuildContext({\n        cwd,\n        logger,\n        strapi,\n        tsconfig,\n        options,\n      });\n      const contextDuration = timer.end('createBuildContext');\n      contextSpinner.text = `Building build context (${prettyTime(contextDuration)})`;\n      contextSpinner.succeed();\n\n      timer.start('creatingAdmin');\n      const adminSpinner = logger.spinner(`Creating admin`).start();\n\n      await writeStaticClientFiles(ctx);\n\n      if (ctx.bundler === 'webpack') {\n        const { watch: watchWebpack } = await import('./webpack/watch');\n        bundleWatcher = await watchWebpack(ctx);\n      } else if (ctx.bundler === 'vite') {\n        const { watch: watchVite } = await import('./vite/watch');\n        bundleWatcher = await watchVite(ctx);\n      }\n\n      const adminDuration = timer.end('creatingAdmin');\n      adminSpinner.text = `Creating admin (${prettyTime(adminDuration)})`;\n      adminSpinner.succeed();\n    }\n\n    const loadStrapiDuration = timer.end('loadStrapi');\n    loadStrapiSpinner.text = `Loading Strapi (${prettyTime(loadStrapiDuration)})`;\n    loadStrapiSpinner.succeed();\n\n    // For TS projects, type generation is a requirement for the develop command so that the server can restart\n    // For JS projects, we respect the experimental autogenerate setting\n    if (tsconfig?.config || strapi.config.get('typescript.autogenerate') !== false) {\n      timer.start('generatingTS');\n      const generatingTsSpinner = logger.spinner(`Generating types`).start();\n\n      await tsUtils.generators.generate({\n        strapi: strapiInstance,\n        pwd: cwd,\n        rootDir: undefined,\n        logger: { silent: true, debug: false },\n        artifacts: { contentTypes: true, components: true },\n      });\n\n      const generatingDuration = timer.end('generatingTS');\n      generatingTsSpinner.text = `Generating types (${prettyTime(generatingDuration)})`;\n      generatingTsSpinner.succeed();\n    }\n\n    if (tsconfig?.config) {\n      timer.start('compilingTS');\n      const compilingTsSpinner = logger.spinner(`Compiling TS`).start();\n\n      await cleanupDistDirectory({ tsconfig, logger, timer });\n      await tsUtils.compile(cwd, { configOptions: { ignoreDiagnostics: false } });\n\n      const compilingDuration = timer.end('compilingTS');\n      compilingTsSpinner.text = `Compiling TS (${prettyTime(compilingDuration)})`;\n      compilingTsSpinner.succeed();\n    }\n\n    const restart = async () => {\n      if (strapiInstance.reload.isWatching && !strapiInstance.reload.isReloading) {\n        strapiInstance.reload.isReloading = true;\n        strapiInstance.reload();\n      }\n    };\n\n    const watcher = chokidar\n      .watch(cwd, {\n        ignoreInitial: true,\n        usePolling: polling,\n        ignored: [\n          /(^|[/\\\\])\\../, // dot files\n          /tmp/,\n          '**/src/admin/**',\n          '**/src/plugins/**/admin/**',\n          '**/dist/src/plugins/test/admin/**',\n          '**/documentation',\n          '**/documentation/**',\n          '**/node_modules',\n          '**/node_modules/**',\n          '**/plugins.json',\n          '**/build',\n          '**/build/**',\n          '**/log',\n          '**/log/**',\n          '**/logs',\n          '**/logs/**',\n          '**/*.log',\n          '**/index.html',\n          '**/public',\n          '**/public/**',\n          strapiInstance.dirs.static.public,\n          strings.joinBy('/', strapiInstance.dirs.static.public, '**'),\n          '**/*.db*',\n          '**/exports/**',\n          '**/dist/**',\n          '**/*.d.ts',\n          '**/.yalc/**',\n          '**/yalc.lock',\n          // TODO v6: watch only src folder by default, and flip this to watchIncludeFiles\n          ...strapiInstance.config.get('admin.watchIgnoreFiles', []),\n        ],\n      })\n      .on('add', (path) => {\n        strapiInstance.log.info(`File created: ${path}`);\n        restart();\n      })\n      .on('change', (path) => {\n        strapiInstance.log.info(`File changed: ${path}`);\n        restart();\n      })\n      .on('unlink', (path) => {\n        strapiInstance.log.info(`File deleted: ${path}`);\n        restart();\n      });\n\n    process.on('message', async (message) => {\n      switch (message) {\n        case 'kill': {\n          logger.debug(\n            'child process has the kill message, destroying the strapi instance and sending the killed process message'\n          );\n          await watcher.close();\n\n          await strapiInstance.destroy();\n\n          if (bundleWatcher) {\n            bundleWatcher.close();\n          }\n          process.send?.('killed');\n          break;\n        }\n        default:\n          break;\n      }\n    });\n\n    strapiInstance.start();\n  }\n};\n\nexport { develop };\nexport type { DevelopOptions };\n"],"names":["generatingDuration","path"],"mappings":"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"}