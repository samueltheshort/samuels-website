{"version":3,"file":"dependencies.mjs","sources":["../../../src/node/core/dependencies.ts"],"sourcesContent":["import os from 'node:os';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport semver, { SemVer } from 'semver';\nimport resolveFrom from 'resolve-from';\nimport execa, { CommonOptions, ExecaReturnValue } from 'execa';\nimport readPkgUp, { PackageJson } from 'read-pkg-up';\nimport type { BuildOptions } from '../build';\nimport { getPackageManager } from './managers';\n\n/**\n * From V5 this will be imported from the package.json of `@strapi/strapi`.\n */\nconst PEER_DEPS = {\n  react: '^18.0.0',\n  'react-dom': '^18.0.0',\n  'react-router-dom': '^6.0.0',\n  'styled-components': '^6.0.0',\n};\n\ninterface CheckRequiredDependenciesResult {\n  didInstall: boolean;\n}\n\ninterface DepToInstall {\n  name: string;\n  wantedVersion: string;\n  declaredVersion?: never;\n}\n\n/**\n * Checks the user's project that it has declared and installed the required dependencies\n * needed by the Strapi admin project. Whilst generally speaking most modules will be\n * declared by the actual packages there are some packages where you only really want one of\n * and thus they are declared as peer dependencies â€“ react / styled-components / etc.\n *\n * If these deps are not installed or declared, then we prompt the user to correct this. In\n * V4 this is not a hard requirement, but in V5 it will be. Might as well get people started now.\n */\nconst checkRequiredDependencies = async ({\n  cwd,\n  logger,\n}: Pick<BuildOptions, 'cwd' | 'logger'>): Promise<CheckRequiredDependenciesResult> => {\n  /**\n   * This enables us to use experimental deps for libraries like\n   * react or styled-components. This is useful for testing against.\n   */\n  if (process.env.USE_EXPERIMENTAL_DEPENDENCIES === 'true') {\n    logger.warn('You are using experimental dependencies that may not be compatible with Strapi.');\n    return { didInstall: false };\n  }\n\n  const pkg = await readPkgUp({ cwd });\n\n  if (!pkg) {\n    throw new Error(`Could not find package.json at path: ${cwd}`);\n  }\n\n  logger.debug('Loaded package.json:', os.EOL, pkg.packageJson);\n\n  interface DepToReview {\n    name: string;\n    wantedVersion: string;\n    declaredVersion: string;\n  }\n\n  /**\n   * Run through each of the peer deps and figure out if they need to be\n   * installed or they need their version checked against.\n   */\n  const { install, review } = Object.entries(PEER_DEPS).reduce<{\n    install: DepToInstall[];\n    review: DepToReview[];\n  }>(\n    (acc, [name, version]) => {\n      if (!pkg.packageJson.dependencies) {\n        throw new Error(`Could not find dependencies in package.json at path: ${cwd}`);\n      }\n\n      const declaredVersion = pkg.packageJson.dependencies[name];\n\n      if (!declaredVersion) {\n        acc.install.push({\n          name,\n          wantedVersion: version,\n        });\n      } else {\n        acc.review.push({\n          name,\n          wantedVersion: version,\n          declaredVersion,\n        });\n      }\n\n      return acc;\n    },\n    {\n      install: [],\n      review: [],\n    }\n  );\n\n  if (install.length > 0) {\n    logger.info(\n      'The Strapi admin needs to install the following dependencies:',\n      os.EOL,\n      install.map(({ name, wantedVersion }) => `  - ${name}@${wantedVersion}`).join(os.EOL)\n    );\n\n    await installDependencies(install, {\n      cwd,\n      logger,\n    });\n\n    const [file, ...args] = process.argv;\n\n    /**\n     * Re-run the same command after installation e.g. strapi build because the yarn.lock might\n     * not be the same and could break installations. It's not the best solution, but it works.\n     */\n    await execa(file, args, { cwd, stdio: 'inherit' });\n    return { didInstall: true };\n  }\n\n  if (review.length) {\n    const errors: string[] = [];\n\n    for (const dep of review) {\n      // The version specified in package.json could be incorrect, eg `foo`\n      let minDeclaredVersion: SemVer | null = null;\n      try {\n        minDeclaredVersion = semver.minVersion(dep.declaredVersion);\n      } catch (err) {\n        // Intentional fall-through (variable will be left as null, throwing below)\n      }\n\n      if (!minDeclaredVersion) {\n        errors.push(\n          `The declared dependency, ${dep.name} has an invalid version in package.json: ${dep.declaredVersion}`\n        );\n      } else if (!semver.satisfies(minDeclaredVersion, dep.wantedVersion)) {\n        /**\n         * The delcared version should be semver compatible with our required version\n         * of the dependency. If it's not, we should advise the user to change it.\n         */\n        logger.warn(\n          [\n            `Declared version of ${dep.name} (${minDeclaredVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\n            'You may experience issues, we recommend you change this.',\n          ].join(os.EOL)\n        );\n      }\n\n      const installedVersion = await getModuleVersion(dep.name, cwd);\n\n      if (!installedVersion) {\n        /**\n         * TODO: when we know the packageManager we can advise the actual install command.\n         */\n        errors.push(\n          `The declared dependency, ${dep.name} is not installed. You should install before re-running this command`\n        );\n      } else if (!semver.satisfies(installedVersion, dep.wantedVersion)) {\n        logger.warn(\n          [\n            `Declared version of ${dep.name} (${installedVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\n            'You may experience issues, we recommend you change this.',\n          ].join(os.EOL)\n        );\n      }\n    }\n\n    if (errors.length > 0 && process.env.NODE_ENV === 'development') {\n      throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);\n    }\n  }\n\n  return { didInstall: false };\n};\n\nconst getModule = async (name: string, cwd: string): Promise<PackageJson | null> => {\n  const modulePackagePath = resolveFrom.silent(cwd, path.join(name, 'package.json'));\n  if (!modulePackagePath) {\n    return null;\n  }\n  const file = await fs.readFile(modulePackagePath, 'utf8').then((res) => JSON.parse(res));\n\n  return file;\n};\n\nconst getModuleVersion = async (name: string, cwd: string): Promise<string | null> => {\n  const pkg = await getModule(name, cwd);\n\n  return pkg?.version || null;\n};\n\nconst installDependencies = async (\n  install: DepToInstall[],\n  { cwd, logger }: Pick<BuildOptions, 'cwd' | 'logger'>\n) => {\n  const packageManager = getPackageManager();\n\n  if (!packageManager) {\n    logger.error(\n      'Could not find a supported package manager, please install the dependencies manually.'\n    );\n    process.exit(1);\n  }\n\n  const execOptions: CommonOptions<'utf8'> = {\n    encoding: 'utf8',\n    cwd,\n    stdio: 'inherit',\n  };\n\n  const packages = install.map(({ name, wantedVersion }) => `${name}@${wantedVersion}`);\n\n  let result: ExecaReturnValue<string> | undefined;\n\n  if (packageManager === 'npm') {\n    const npmArgs = ['install', '--legacy-peer-deps', '--save', ...packages];\n    logger.info(`Running 'npm ${npmArgs.join(' ')}'`);\n    result = await execa('npm', npmArgs, execOptions);\n  } else if (packageManager === 'yarn') {\n    const yarnArgs = ['add', ...packages];\n    logger.info(`Running 'yarn ${yarnArgs.join(' ')}'`);\n    result = await execa('yarn', yarnArgs, execOptions);\n  } else if (packageManager === 'pnpm') {\n    const pnpmArgs = ['add', '--save-prod', ...packages];\n    logger.info(`Running 'pnpm ${pnpmArgs.join(' ')}'`);\n    result = await execa('pnpm', pnpmArgs, execOptions);\n  }\n\n  if (result?.exitCode || result?.failed) {\n    throw new Error('Package installation failed');\n  }\n};\n\nexport { checkRequiredDependencies, getModule };\nexport type { CheckRequiredDependenciesResult, PackageJson };\n"],"names":[],"mappings":"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"}