{"version":3,"file":"plugins.js","sources":["../../../src/node/core/plugins.ts"],"sourcesContent":["import os from 'node:os';\nimport path from 'node:path';\nimport fs from 'node:fs';\nimport camelCase from 'lodash/camelCase';\nimport { env } from '@strapi/utils';\nimport { getModule, PackageJson } from './dependencies';\nimport { convertModulePathToSystemPath, convertSystemPathToModulePath, loadFile } from './files';\nimport type { BaseContext } from '../types';\nimport { isError } from './errors';\n\ninterface LocalPluginMeta {\n  name: string;\n  /**\n   * camelCased version of the plugin name\n   */\n  importName: string;\n  /**\n   * The path to the plugin, relative to the app's root directory\n   * in system format\n   */\n  path: string;\n  /**\n   * The path to the plugin, relative to the runtime directory\n   * in module format (i.e. with forward slashes) because thats\n   * where it should be used as an import\n   */\n  modulePath: string;\n  type: 'local';\n}\n\ninterface ModulePluginMeta {\n  name: string;\n  /**\n   * camelCased version of the plugin name\n   */\n  importName: string;\n  /**\n   * Modules don't have a path because we never resolve them to their node_modules\n   * because we simply do not require it.\n   */\n  path?: never;\n  /**\n   * The path to the plugin, relative to the app's root directory\n   * in module format (i.e. with forward slashes)\n   */\n  modulePath: string;\n  type: 'module';\n}\n\ntype PluginMeta = LocalPluginMeta | ModulePluginMeta;\n\ninterface StrapiPlugin extends PackageJson {\n  strapi: {\n    description?: string;\n    displayName?: string;\n    kind: 'plugin';\n    name?: string;\n    required?: boolean;\n  };\n}\n\nconst validatePackageHasStrapi = (\n  pkg: PackageJson\n): pkg is PackageJson & { strapi: Record<string, unknown> } =>\n  'strapi' in pkg &&\n  typeof pkg.strapi === 'object' &&\n  !Array.isArray(pkg.strapi) &&\n  pkg.strapi !== null;\n\nconst validatePackageIsPlugin = (pkg: PackageJson): pkg is StrapiPlugin =>\n  validatePackageHasStrapi(pkg) && pkg.strapi.kind === 'plugin';\n\nconst getEnabledPlugins = async ({\n  cwd,\n  logger,\n  runtimeDir,\n  strapi,\n}: Pick<BaseContext, 'cwd' | 'logger' | 'strapi' | 'runtimeDir'>): Promise<\n  Record<string, PluginMeta>\n> => {\n  const plugins: Record<string, PluginMeta> = {};\n\n  /**\n   * This is the list of dependencies that are installed in the user's project.\n   * It will include libraries like \"react\", so we need to collect the ones that\n   * are plugins.\n   */\n  const deps = strapi.config.get('info.dependencies', {});\n\n  logger.debug(\"Dependencies from user's project\", os.EOL, deps);\n\n  for (const dep of Object.keys(deps)) {\n    const pkg = await getModule(dep, cwd);\n\n    if (pkg && validatePackageIsPlugin(pkg)) {\n      const name = pkg.strapi.name || pkg.name;\n\n      if (!name) {\n        /**\n         * Unlikely to happen, but you never know.\n         */\n        throw Error(\n          \"You're trying to import a plugin that doesn't have a name â€“ check the package.json of that plugin!\"\n        );\n      }\n\n      plugins[name] = {\n        name,\n        importName: camelCase(name),\n        type: 'module',\n        modulePath: dep,\n      };\n    }\n  }\n\n  const userPluginsFile = await loadUserPluginsFile(strapi.dirs.app.config);\n\n  logger.debug(\"User's plugins file\", os.EOL, userPluginsFile);\n\n  for (const [userPluginName, userPluginConfig] of Object.entries(userPluginsFile)) {\n    if (userPluginConfig.enabled && userPluginConfig.resolve) {\n      const sysPath = convertModulePathToSystemPath(userPluginConfig.resolve);\n      plugins[userPluginName] = {\n        name: userPluginName,\n        importName: camelCase(userPluginName),\n        type: 'local',\n        /**\n         * User plugin paths are resolved from the entry point\n         * of the app, because that's how you import them.\n         */\n        modulePath: convertSystemPathToModulePath(path.relative(runtimeDir, sysPath)),\n        path: sysPath,\n      };\n    }\n  }\n\n  return plugins;\n};\n\nconst PLUGIN_CONFIGS = ['plugins.js', 'plugins.mjs', 'plugins.ts'];\n\ntype UserPluginConfigFile = Record<string, { enabled: boolean; resolve: string }>;\n\nconst loadUserPluginsFile = async (root: string): Promise<UserPluginConfigFile> => {\n  for (const file of PLUGIN_CONFIGS) {\n    const filePath = path.join(root, file);\n    const configFile = await loadFile(filePath);\n\n    if (configFile) {\n      /**\n       * Configs can be a function or they can be just an object!\n       */\n      return typeof configFile === 'function' ? configFile({ env }) : configFile;\n    }\n  }\n\n  return {};\n};\n\nconst getMapOfPluginsWithAdmin = (plugins: Record<string, PluginMeta>) => {\n  /**\n   * This variable stores the import paths for plugins.\n   * The keys are the module paths of the plugins, and the values are the paths\n   * to the admin part of the plugins, which is either loaded from the\n   * package.json exports or from the legacy strapi-admin.js file.\n   */\n  const pluginImportPaths: Record<string, string> = {};\n\n  return Object.values(plugins)\n    .filter((plugin) => {\n      if (!plugin) {\n        return false;\n      }\n\n      /**\n       * There are two ways a plugin should be imported, either it's local to the strapi app,\n       * or it's an actual npm module that's installed and resolved via node_modules.\n       *\n       * We first check if the plugin is local to the strapi app, using a regular `fs.existsSync` because\n       * the pathToPlugin will be relative i.e. `/Users/my-name/strapi-app/src/plugins/my-plugin`.\n       *\n       * If the file doesn't exist well then it's probably a node_module, so instead we use `require.resolve`\n       * which will resolve the path to the module in node_modules. If it fails with the specific code `MODULE_NOT_FOUND`\n       * then it doesn't have an admin part to the package.\n       */\n      try {\n        const localPluginPath = plugin.path;\n        if (localPluginPath) {\n          // Here we are loading a locally installed plugin\n          const packageJsonPath = path.join(localPluginPath, 'package.json');\n\n          if (fs.existsSync(packageJsonPath)) {\n            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\n            const localAdminPath = packageJson?.exports?.['./strapi-admin']?.import;\n\n            if (localAdminPath) {\n              pluginImportPaths[plugin.modulePath] = localAdminPath;\n              return true;\n            }\n          }\n\n          // Check if legacy admin file exists in local plugin\n          if (fs.existsSync(path.join(localPluginPath, 'strapi-admin.js'))) {\n            pluginImportPaths[plugin.modulePath] = 'strapi-admin';\n            return true;\n          }\n        }\n\n        // This plugin is a module, so we need to check if it has a strapi-admin export\n        if (require.resolve(`${plugin.modulePath}/strapi-admin`)) {\n          pluginImportPaths[plugin.modulePath] = 'strapi-admin';\n          return true;\n        }\n\n        return false;\n      } catch (err) {\n        if (\n          isError(err) &&\n          'code' in err &&\n          (err.code === 'MODULE_NOT_FOUND' || err.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED')\n        ) {\n          /**\n           * the plugin does not contain FE code, so we\n           * don't want to import it anyway\n           */\n          return false;\n        }\n\n        throw err;\n      }\n    })\n    .map((plugin) => ({\n      ...plugin,\n      modulePath: `${plugin.modulePath}/${pluginImportPaths[plugin.modulePath]}`,\n    }));\n};\n\nexport { getEnabledPlugins, getMapOfPluginsWithAdmin };\nexport type { PluginMeta, LocalPluginMeta, ModulePluginMeta };\n"],"names":["os","getModule","camelCase","convertModulePathToSystemPath","convertSystemPathToModulePath","path","loadFile","env","fs","isError"],"mappings":"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"}