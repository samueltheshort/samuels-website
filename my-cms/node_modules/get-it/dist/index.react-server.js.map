{"version":3,"file":"index.react-server.js","sources":["../src/request/browser/fetchXhr.ts","../node_modules/parse-headers/parse-headers.js","../src/request/browser-request.ts","../src/index.browser.ts","../src/index.react-server.ts"],"sourcesContent":["/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: (() => void) | undefined\n  onerror: ((error?: any) => void) | undefined\n  onreadystatechange: (() => void) | undefined\n  ontimeout: XMLHttpRequest['ontimeout'] | undefined\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText'] = ''\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status'] | undefined\n  statusText: XMLHttpRequest['statusText'] | undefined\n  withCredentials: XMLHttpRequest['withCredentials'] | undefined\n\n  /**\n   * Private implementation details\n   */\n  #method!: string\n  #url!: string\n  #resHeaders!: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  #init: RequestInit = {}\n  #useAbortSignal?: boolean\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange?.()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init: RequestInit, useAbortSignal = true) {\n    this.#init = init\n    this.#useAbortSignal = useAbortSignal\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      ...this.#init,\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function' && this.#useAbortSignal) {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        this.onreadystatechange?.()\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange?.()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort?.()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n","var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n","import type {HttpRequest, MiddlewareResponse, RequestOptions} from 'get-it'\nimport parseHeaders from 'parse-headers'\n\nimport {FetchXhr} from './browser/fetchXhr'\n\n/**\n * Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\n * @public\n */\nexport const adapter = (\n  typeof XMLHttpRequest === 'function' ? ('xhr' as const) : ('fetch' as const)\n) satisfies import('../types').RequestAdapter\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport const httpRequester: HttpRequest = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts) as RequestOptions\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  if (xhr instanceof FetchXhr && typeof options.fetch === 'object') {\n    xhr.setInit(options.fetch, options.useAbortSignal ?? true)\n  }\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    // If fetch is used then rethrow the original error\n    if (xhr instanceof FetchXhr) {\n      onError(\n        event instanceof Error\n          ? event\n          : new Error(`Request error while attempting to reach is ${options.url}`, {cause: event}),\n      )\n    } else {\n      onError(\n        new Error(\n          `Request error while attempting to reach is ${options.url}${\n            event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n          }`,\n        ),\n      )\n    }\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method!,\n    options.url,\n    true, // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`,\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: typeof options\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse(): MiddlewareResponse {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method!,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status!,\n      statusMessage: xhr.statusText!,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n","import {createRequester} from './createRequester'\nimport {httpRequester} from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport type * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester,\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment = 'browser' satisfies ExportEnv\n\n/** @public */\nexport {adapter} from './request/browser-request'\n","import type {ExportEnv} from './types'\n\nexport * from './index.browser'\n\n/** @public */\nexport const environment = 'react-server' satisfies ExportEnv\n"],"names":["parseHeaders","trim","string","replace","headers","result","headersArr","split","i","length","row","index","indexOf","key","slice","toLowerCase","value","arg","Object","prototype","toString","call","push","FetchXhr","onabort","onerror","onreadystatechange","ontimeout","readyState","response","responseText","responseType","status","statusText","withCredentials","method","url","resHeaders","controller","init","useAbortSignal","open","_async","this","abort","getAllResponseHeaders","setRequestHeader","name","setInit","send","body","textBody","options","AbortController","EventTarget","signal","document","credentials","fetch","then","res","forEach","text","arrayBuffer","resBody","catch","err","adapter","XMLHttpRequest","XmlHttpRequest","httpRequester","context","callback","opts","applyMiddleware","timers","injectedResponse","cbTimer","setTimeout","clearTimeout","xhr","delays","timeout","aborted","loaded","timedOut","event","onError","Error","cause","lengthComputable","total","stopTimers","socket","timeoutRequest","statusCode","statusMessage","onLoad","hasOwnProperty","rawBody","request","connect","code","error","channels","publish","force","isNetworkError","getIt","initMiddleware","httpRequest","createRequester","environment"],"mappings":"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","x_google_ignoreList":[1]}